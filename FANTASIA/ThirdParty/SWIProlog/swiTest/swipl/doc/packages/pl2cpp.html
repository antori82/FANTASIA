<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
<title>A C++ interface to SWI-Prolog</title>
<style type="text/css">

/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef, dt.multidef
{ color: #fff;
padding: 2px 10px 0px 10px;
margin-bottom: 5px;
font-size: 18px;
vertical-align: middle;
overflow: hidden;
}

dt.pubdef { background-color: #0c3d6e; }
dt.multidef { background-color: #ef9439; }

.bib dd
{ margin-bottom: 1em;
}

.bib dt
{ float: left;
margin-right: 1.3ex;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{
}

span.sec-title
{
}

span.pred-ext
{ font-weight: bold;
}

span.pred-tag
{ float: right;
padding-top: 0.2em;
font-size: 80%;
font-style: italic;
color: #fff;
}

div.caption
{ width: 80%;
margin: auto;
text-align:center;
}

/* Footnotes */
.fn {
color: red;
font-size: 70%;
}

.fn-text, .fnp {
position: absolute;
top: auto;
left: 10%;
border: 1px solid #000;
box-shadow: 5px 5px 5px #888;
display: none;
background: #fff;
color: #000;
margin-top: 25px;
padding: 8px 12px;
font-size: larger;
}

sup:hover span.fn-text
{ display: block;
}

/* Lists */

dl.latex
{ margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.latex dl.latex dd.defbody
{ margin-bottom: 0.5ex;
}

/* PlDoc Tags */

dl.tags
{ font-size: 90%;
margin-left: 5ex;
margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.tags dt
{ margin-left: 0pt;
font-weight: bold;
}

dl.tags dd
{ margin-left: 3ex;
}

td.param
{ font-style: italic;
font-weight: bold;
}

/* Index */

dt.index-sep
{ font-weight: bold;
font-size: +1;
margin-top: 1ex;
}

/* Tables */

table.center
{ margin: auto;
}

table.latex
{ border-collapse:collapse;
}

table.latex tr
{ vertical-align: text-top;
}

table.latex td,th
{ padding: 2px 1em;
}

table.latex tr.hline td,th
{ border-top: 1px solid black;
}

table.frame-box
{ border: 2px solid black;
}

</style>
</head>
<body style="background:white"> 
<div class="title">A C++ interface to SWI-Prolog</div>
<div class="author">Jan Wielemaker &amp; Peter Ludemann <br>
SWI-Prolog Solutions b.v. <br>
E-mail: <a class="url" href="mailto:jan@swi-prolog.org">jan@swi-prolog.org</a></div>
<div class="abstract">
<div class="abstract-title">Abstract</div> This document describes a C++ 
interface to SWI-Prolog. SWI-Prolog could be used with C++ for a very 
long time, but only by calling the extern "C" functions of the 
C-interface. The interface described here provides a true C++ layer 
around the C-interface for much more concise and natural programming 
from C++. The interface deals with automatic type-conversion to and from 
native C data-types, transparent mapping of exceptions, making queries 
to Prolog and registering foreign predicates.

<p>This document describes version&nbsp;2 of the C++ interface. Version&nbsp;1 
is considered <i>deprecated</i>. Version 2 is implemented by
<code>SWI-cpp2.h</code> and <code>SWI-cpp2.cpp</code>. This is a much 
more mature C++ interface has been designed and implemented by Peter 
Ludemann.
</div>

<h1><a id="document-contents">Table of Contents</a></h1>

<div class="toc">
<div class="toc-h1"><a class="sec" href="#sec:1"><span class="sec-nr">1</span> <span class="sec-title">A 
C++ interface to SWI-Prolog</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:1.1"><span class="sec-nr">1.1</span> <span class="sec-title">Summary 
of changes between Versions 1 and 2</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:1.2"><span class="sec-nr">1.2</span> <span class="sec-title">A 
simple example</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:1.3"><span class="sec-nr">1.3</span> <span class="sec-title">Sample 
code</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:1.4"><span class="sec-nr">1.4</span> <span class="sec-title">Introduction</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.4.1"><span class="sec-nr">1.4.1</span> <span class="sec-title">Acknowledgements</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:1.5"><span class="sec-nr">1.5</span> <span class="sec-title">The 
life of a PREDICATE</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:1.6"><span class="sec-nr">1.6</span> <span class="sec-title">Overview</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.6.1"><span class="sec-nr">1.6.1</span> <span class="sec-title">Design 
philosophy of the classes</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.6.2"><span class="sec-nr">1.6.2</span> <span class="sec-title">Summary 
of files</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.6.3"><span class="sec-nr">1.6.3</span> <span class="sec-title">Summary 
of classes</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.6.4"><span class="sec-nr">1.6.4</span> <span class="sec-title">Wrapper 
functions</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.6.5"><span class="sec-nr">1.6.5</span> <span class="sec-title">Naming 
conventions, utility functions and methods</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.6.6"><span class="sec-nr">1.6.6</span> <span class="sec-title">PlTerm 
class</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.6.7"><span class="sec-nr">1.6.7</span> <span class="sec-title">PlTermScoped 
class (experimental)</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.6.8"><span class="sec-nr">1.6.8</span> <span class="sec-title">Blobs</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.6.8.1"><span class="sec-nr">1.6.8.1</span> <span class="sec-title">A 
review of C++ features used by the API</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.6.8.2"><span class="sec-nr">1.6.8.2</span> <span class="sec-title">How 
to define a blob using C++</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.6.8.3"><span class="sec-nr">1.6.8.3</span> <span class="sec-title">The 
life of a PlBlob</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.6.8.4"><span class="sec-nr">1.6.8.4</span> <span class="sec-title">C++ 
exceptions and blobs</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.6.8.5"><span class="sec-nr">1.6.8.5</span> <span class="sec-title">Sample 
PlBlob code (connection to database)</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.6.8.6"><span class="sec-nr">1.6.8.6</span> <span class="sec-title">Discussion 
of the sample PlBlob code</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.6.8.7"><span class="sec-nr">1.6.8.7</span> <span class="sec-title">Sample 
PlBlob code (wrapping a pointer)</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.6.8.8"><span class="sec-nr">1.6.8.8</span> <span class="sec-title">Discussion 
of the sample PlBlob code (wrapping a pointer)</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.6.8.9"><span class="sec-nr">1.6.8.9</span> <span class="sec-title">Identifying 
blobs by atoms</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.6.9"><span class="sec-nr">1.6.9</span> <span class="sec-title">Limitations 
of the interface</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.6.9.1"><span class="sec-nr">1.6.9.1</span> <span class="sec-title">Strings</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.6.9.2"><span class="sec-nr">1.6.9.2</span> <span class="sec-title">Stream 
I/O</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.6.9.3"><span class="sec-nr">1.6.9.3</span> <span class="sec-title">Object 
handles</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.6.10"><span class="sec-nr">1.6.10</span> <span class="sec-title">Linking 
embedded applications using swipl-ld</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:1.7"><span class="sec-nr">1.7</span> <span class="sec-title">Examples</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.7.1"><span class="sec-nr">1.7.1</span> <span class="sec-title">Hello(World)</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.7.2"><span class="sec-nr">1.7.2</span> <span class="sec-title">Adding 
numbers</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.7.3"><span class="sec-nr">1.7.3</span> <span class="sec-title">Average 
of solutions - calling a Prolog goal</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:1.8"><span class="sec-nr">1.8</span> <span class="sec-title">Rationale 
for changes from version 1</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.8.1"><span class="sec-nr">1.8.1</span> <span class="sec-title">Implicit 
constructors and conversion operators</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.8.2"><span class="sec-nr">1.8.2</span> <span class="sec-title">Strings</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:1.9"><span class="sec-nr">1.9</span> <span class="sec-title">Porting 
from version 1 to version 2</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:1.10"><span class="sec-nr">1.10</span> <span class="sec-title">The 
class PlFail</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.10.1"><span class="sec-nr">1.10.1</span> <span class="sec-title">PlCheckFail(), 
and PlEx() convenience functions</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:1.11"><span class="sec-nr">1.11</span> <span class="sec-title">Overview 
of accessing and changing values</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.11.1"><span class="sec-nr">1.11.1</span> <span class="sec-title">Converting 
PlTerm to native C and C++ types</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.11.2"><span class="sec-nr">1.11.2</span> <span class="sec-title">Unification</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.11.3"><span class="sec-nr">1.11.3</span> <span class="sec-title">Comparison</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.11.4"><span class="sec-nr">1.11.4</span> <span class="sec-title">Analysing 
compound terms</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.11.5"><span class="sec-nr">1.11.5</span> <span class="sec-title">Miscellaneous</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.11.6"><span class="sec-nr">1.11.6</span> <span class="sec-title">The 
class PlTerm_string</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.11.7"><span class="sec-nr">1.11.7</span> <span class="sec-title">The 
class PlCodeList</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.11.8"><span class="sec-nr">1.11.8</span> <span class="sec-title">The 
class PlCharList</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.11.9"><span class="sec-nr">1.11.9</span> <span class="sec-title">The 
class PlCompound</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.11.10"><span class="sec-nr">1.11.10</span> <span class="sec-title">The 
class PlTerm_tail</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.11.11"><span class="sec-nr">1.11.11</span> <span class="sec-title">The 
class PlTermv</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.11.12"><span class="sec-nr">1.11.12</span> <span class="sec-title">The 
class PlAtom - Supporting Prolog constants</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.11.12.1"><span class="sec-nr">1.11.12.1</span> <span class="sec-title">Direct 
comparision to char *</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.11.12.2"><span class="sec-nr">1.11.12.2</span> <span class="sec-title">Direct 
comparision to PlAtom</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.11.12.3"><span class="sec-nr">1.11.12.3</span> <span class="sec-title">Extraction 
of the atom and comparison to PlAtom</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.11.12.4"><span class="sec-nr">1.11.12.4</span> <span class="sec-title">Extraction 
of the atom and comparison to char *</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.11.13"><span class="sec-nr">1.11.13</span> <span class="sec-title">Classes 
for the recorded database: PlRecord and PlRecordExternalCopy</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:1.12"><span class="sec-nr">1.12</span> <span class="sec-title">The 
class PlRegister</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:1.13"><span class="sec-nr">1.13</span> <span class="sec-title">The 
class PlQuery</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.13.1"><span class="sec-nr">1.13.1</span> <span class="sec-title">The 
class PlFrame - Unification and foreign frames</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:1.14"><span class="sec-nr">1.14</span> <span class="sec-title">The 
PREDICATE and PREDICATE_NONDET macros</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.14.1"><span class="sec-nr">1.14.1</span> <span class="sec-title">Variations 
of the PREDICATE macro</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.14.2"><span class="sec-nr">1.14.2</span> <span class="sec-title">Non-deterministic 
predicates</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.14.3"><span class="sec-nr">1.14.3</span> <span class="sec-title">Controlling 
the Prolog destination module</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:1.15"><span class="sec-nr">1.15</span> <span class="sec-title">Exceptions</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.15.1"><span class="sec-nr">1.15.1</span> <span class="sec-title">The 
class PlException</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.15.1.1"><span class="sec-nr">1.15.1.1</span> <span class="sec-title">The 
function PlTypeError</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.15.1.2"><span class="sec-nr">1.15.1.2</span> <span class="sec-title">The 
function PlDomainError</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:1.16"><span class="sec-nr">1.16</span> <span class="sec-title">Embedded 
applications</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:1.17"><span class="sec-nr">1.17</span> <span class="sec-title">Considerations</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.17.1"><span class="sec-nr">1.17.1</span> <span class="sec-title">The 
C++ versus the C interface</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.17.2"><span class="sec-nr">1.17.2</span> <span class="sec-title">Notes 
on exceptions</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.17.3"><span class="sec-nr">1.17.3</span> <span class="sec-title">Global 
terms, atoms, and functors</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.17.4"><span class="sec-nr">1.17.4</span> <span class="sec-title">Atom 
map utilities</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.17.5"><span class="sec-nr">1.17.5</span> <span class="sec-title">Static 
linking and embedding</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.17.6"><span class="sec-nr">1.17.6</span> <span class="sec-title">Status 
and compiler versions</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:1.18"><span class="sec-nr">1.18</span> <span class="sec-title">Conclusions</span></a></div>
</div>
<h1 id="sec:cpp2"><a id="sec:1"><span class="sec-nr">1</span> <span class="sec-title">A 
C++ interface to SWI-Prolog</span></a></h1>

<a id="sec:cpp2"></a>

<p><h2 id="sec:summary-cpp2-changes"><a id="sec:1.1"><span class="sec-nr">1.1</span> <span class="sec-title">Summary 
of changes between Versions 1 and 2</span></a></h2>

<a id="sec:summary-cpp2-changes"></a>

<p>Version&nbsp;1 is in <code>SWI-cpp.h</code>; version&nbsp;2 is in <code>SWI-cpp2.h</code>,
<code>SWI-cpp2.cpp</code>, <code>SWI-cpp2-plx.h</code>, and <code>SWI-cpp2-atommap.h</code>.

<p>The overall structure of the API has been retained - that is, it is a 
thin layer of lightweight classes on top of the interface provided by
<code>SWI-Prolog.h</code>. Based on experience with the API, most of the 
conversion operators and some of the comparison operators have been 
removed or deprecated, and replaced by &ldquo;getter&rdquo; methods; the 
overloaded constructors have been replaced by subclasses for the various 
types. Some changes were also made to ensure that the
<code><code>[]</code></code> operator for <code>PlTerm</code> and <code>PlTermv</code> 
doesn't cause unexpected implicit conversions.<sup class="fn">1<span class="fn-text">If 
there is an implicit conversion operator from <code>PlTerm</code> to <code>term_t</code> 
and also to <code>char*</code>, then the <code><code>[]</code></code> 
operator is ambiguous if <code>f</code> is overloaded to accept a <code>term_t</code> 
or <code>char*</code> in the code <code>PlTerm t=...; f(t[0])</code>.</span></sup>

<p>Prolog errors are now converted to C++ exceptions (which contain the 
exception term rather being a subclass of <code>PlTerm</code> as in 
version 1), where they can be caught and thrown using the usual C++ 
mechanisms; and the subclasses that create exceptions have been changed 
to functions. In addition, an exception type <code>PlFail</code> has 
been added, together with <code>PlCheckFail</code>, to allow more 
compact code by &ldquo;short circuit&rdquo; return to Prolog on failure.

<p>A convenience class for creating blobs has been added, so that an 
existing structure can be converted to a blob with only a few lines of 
code. More specifically:

<p>
<ul class="latex">
<li><code>SWI-cpp2.cpp</code> has been added, containing the 
implementation of some functions. This is included by default from <code>SWI-cpp2.h</code> 
or can be compiled separately.
<li>The constructor <b>PlTerm()</b> is restricted to a few unambiguous 
cases - instead, you should use the appropriate subclass constructors 
that specify the type (<b>PlTerm_var()</b>,
<b>PlTerm_atom()</b>, etc.).
<li>Wrapper functions have been provided for almost all the PL_*() 
functions in <code>SWI-Prolog.h</code>, and have the same names with the &ldquo;PL&rdquo; replaced 
by &ldquo;Plx&rdquo; .<sup class="fn">2<span class="fn-text"> &ldquo;Pl&rdquo; is 
used throughout the <code>SWI-cpp2.h</code> interface, and the &ldquo;x&rdquo; is 
for &ldquo;eXtended with eXception handling.&rsquo;</span></sup> Where 
appropriate, these check return codes and throw a C++ exception (created 
from the Prolog error). See <a class="sec" href="#sec:1.6.4">section 
1.6.4</a>. Many of these wrapper functions are also methods in the <code>PlAtom</code> 
and <code>PlTerm</code> classes, with the arguments changed from
<code>atom_t</code> and <code>term_t</code> to <code>PlAtom</code> and <code>PlTerm</code> 
and in some cases <code>char*</code> and <code>wchar_t*</code> changed 
to <code>std::string</code> and <code>std::wstring</code>. These 
wrappers are available if you include <code>SWI-cpp2.h</code> (they are 
in a separate <code>SWI-cpp2-plx.h</code> file for ease of maintenance).
<li>Instead of returning <code>false</code> from a foreign predicate to 
indicate failure, you can throw <b>PlFail()</b>. The convenience 
function <a class="func" href="#PlCheckFail()">PlCheckFail(rc)</a> can 
be used to throw <b>PlFail()</b> if <code>false</code> is returned from 
a function in
<code>SWI-Prolog.h</code>. If the wrapper functions or class methods are 
used, Prolog errors result in a C++ <code>PlException</code> exception.<sup class="fn">3<span class="fn-text">If 
a &ldquo;Plx_&rdquo; wrapper is used to call a <code>SWI-Prolog.h</code> 
function, a Prolog error will have already resulted in throwing <code>PlException</code></span></sup>;
<a class="func" href="#PlCheckFail()">PlCheckFail(rc)</a> is used to 
additionally throw
<code>PlFail</code>, similar to returning <code>false</code> from the 
top-level of a foreign predicate - Prolog will check for an error and 
call <a id="idx:throw1:1"></a><span class="pred-ext">throw/1</span> if 
appropriate.
<li>The <code>PlException</code> class is now a subclass of <code>std::exception</code> 
and encapsulates a Prolog error. Prolog errors are converted into <code>throw <b>PlException(...)</b></code>. 
If the user code does not catch the <code>PlException</code>, the <a class="func" href="#PREDICATE()">PREDICATE()</a> 
macro converts the error to a Prolog error upon return to the Prolog 
caller.
<li>The C++ constructors, functions, and methods use the wrapper 
functions to throw a C++ exception on error (this C++ exception is 
converted to a Prolog exception when control returns to Prolog).
<li>The &ldquo;cast&rdquo; operators (e.g., <code>(char*)t</code>, <code>(int64_t)t</code>,
<code>static_cast&lt;char*&gt;(t)</code>) have been deprecated, replaced 
by &ldquo;getters&rdquo; (e.g.,
<code>t.<a class="func" href="#as_string()">as_string()</a></code>, <code>t.<b>as_int64_t()</b></code>).
<li>The overloaded assignment operator for unification is deprecated, 
replaced by <a class="func" href="#PlTerm::unify_term()">PlTerm::unify_term()</a>, <a class="func" href="#PlTerm::unify_atom()">PlTerm::unify_atom()</a>, 
etc., and the helper <a class="func" href="#PlCheckFail()">PlCheckFail()</a>.
<li>Many of the equality and inequality operators are deprecated; 
replaced by the <a class="func" href="#PlTerm::as_string()">PlTerm::as_string()</a> 
or <a class="func" href="#PlTerm::get_nchars()">PlTerm::get_nchars()</a> 
methods and the associated
<code>std::string</code>, comparison operators. The <a class="func" href="#PlTerm::as_string()">PlTerm::as_string()</a> 
method allows specifying the encoding to use whereas the <code><code>==</code></code> 
and similar operators do not allow for this.
<li>Methods that return <code>char*</code> have been replaced by methods 
that return <code>std::string</code> to ensure that lifetime issues 
don't cause subtle bugs.<sup class="fn">4<span class="fn-text">If you 
want to return a <code>char*</code> from a function, you should not do <code>return 
t.<a class="func" href="#as_string()">as_string()</a>.<b>c_str()</b></code> 
because that will return a pointer to local or stack memory. Instead, 
you should change your interface to return a <code>std::string</code> 
and apply the <code><b>c_str()</b></code> method to it. These lifetime 
errors can <em>sometimes</em> be caught by specifying the Gnu C++ or 
Clang options <code>-Wreturn-stack-address</code> or <code>-Wreturn-local-addr</code> 
- as of 2023-04, Clang seems to do a better analysis.</span></sup>
<li>Most constructors, methods, and functions that accept <code>char*</code> 
or <code>wchar_t*</code> arguments also accept <code>std::string</code> 
or <code>std::wstring</code> arguments. Where possible, encoding 
information can also be specified.
<li>Type-checking methods have been added: <a class="func" href="#PlTerm::type()">PlTerm::type()</a>,
<a class="func" href="#PlTerm::is_variable()">PlTerm::is_variable()</a>, <a class="func" href="#PlTerm::is_atom()">PlTerm::is_atom()</a>, 
etc.
<li><code>PlString</code> has been renamed to <code>PlTerm_string</code> 
to make it clear that it's a term that contains a Prolog string.
<li>More <code>PL_...(term_t, ...)</code> methods have been added to <code>PlTerm</code>, 
and <code>PL_...(atom_t, ...)</code> methods have been added to <code>PlAtom</code>. 
Where appropriate, the arguments use <code>PlTerm</code>, <code>PlAtom</code>, 
etc. instead of <code>term_t</code>, <code>atom_t</code>, etc.
<li>Most functions/methods that return an <code>int</code> for 
true/false now return a C++ <code>bool</code>.
<li>The wrapped C types fields (<code>term_t</code>, <code>atom_t</code>, 
etc.) have been renamed from <code>handle</code>, <code>ref</code>, etc. 
to
<code>C_</code>.<sup class="fn">5<span class="fn-text">This is done by 
subclassing from <code>Wrapped&lt;<var>term_t</var>&gt;</code>, <code>Wrapped&lt;<var>atom_t</var>&gt;</code>, 
etc., which define the field <code>C_</code>, standard constructors, the 
methods <a class="func" href="#is_null()">is_null()</a>, <a class="func" href="#not_null()">not_null()</a>, <a class="func" href="#reset()">reset()</a>, 
reset(v), reset_wrapped(v), plus the constant <code>null</code>.</span></sup> 
This value can be accessed by the <b>unwrap()</b> and <b>unwrap_as_ptr()</b> 
methods. There is also a &ldquo;friend&rdquo; function <b>PlUnwrapAsPtr()</b>.
<li>A convenience function <code>PlControl::context_unique_ptr&lt;<var>ContextType</var>&gt;()</code> 
has been added, to simplify dynamic memory allocation in 
non-deterministic predicates.
<li>A convenience function <a class="func" href="#PlRewindOnFail()">PlRewindOnFail()</a> 
has been added, to simplify non-deterministic code that does 
backtracking by checking unification results.
<li><code>PlStringBuffers</code> provides a simpler interface for 
allocating strings on the stack than <b>PL_STRINGS_MARK()</b> and <b>PL_STRINGS_RELEASE()</b>. 
However, this is mostly not needed because most functions now use <code>std::string</code>: 
see <a class="sec" href="#sec:1.6.9.1">section 1.6.9.1</a>.
<li><code>PlStream</code> provides a simpler interface for streams than
<b>PL_get_stream()</b>, <b>PL_acquire_stream()</b>, and <b>PL_release_stream()</b>. 
See <a class="sec" href="#sec:1.6.9.2">section 1.6.9.2</a>.
<li>Wrapper classes for <code>record_t</code> have been added. The
<code>PlRecordExternalCopy</code> class contains the opaque handle, as a 
convenience.
<li>Wrapper class for <code>control_t</code> has been added and the
<a class="func" href="#PREDICATE_NONDET()">PREDICATE_NONDET()</a> has 
been modified to use it.
</ul>

<p>More details on the rationale and how to port from version 1 to 
version 1 are given in <a class="sec" href="#sec:1.8">section 1.8</a> 
and
<a class="sec" href="#sec:1.9">section 1.9</a>.

<p><h2 id="sec:cpp2-foreign-example"><a id="sec:1.2"><span class="sec-nr">1.2</span> <span class="sec-title">A 
simple example</span></a></h2>

<a id="sec:cpp2-foreign-example"></a>

<p>Here is the &ldquo;simple example&rdquo; in the
<a class="url" href="https://www.swi-prolog.org/pldoc/man?section=foreign-example">Foreign 
Language Interface</a>, rewritten in C++. As before, it is compiled by

<pre class="code">
  swipl-ld -o calc -goal true calc.cpp calc.pl
</pre>

<pre class="code">
#include &lt;string&gt;
#include &lt;SWI-cpp2.h&gt;

int main(int argc, char **argv) {

  PlEngine e(argv[0]);

  // combine all the arguments in a single string
  std::string expression;
  for (int n = 1; n &lt; argc; n++) {
    if (n != 1) {
      expression.append(" ");
    }
    expression.append(argv[n]);
  }

  // Lookup calc/1 and make the arguments and call

  PlPredicate pred("calc", 1, "user");
  PlTerm_string h0(expression);
  PlQuery q(pred, PlTermv(h0), PL_Q_NORMAL);

  return q.next_solution() ? 0 : 1;
}
</pre>

<p><h2 id="sec:cpp2-sample-code"><a id="sec:1.3"><span class="sec-nr">1.3</span> <span class="sec-title">Sample 
code</span></a></h2>

<a id="sec:cpp2-sample-code"></a>

<p>The file
<a class="url" href="https://github.com/SWI-Prolog/packages-cpp/blob/master/test_cpp.cpp">test_cpp.cpp</a> 
contains examples of Prolog predicates written in C++. This file is used 
for testing (called from
<a class="url" href="https://github.com/SWI-Prolog/packages-cpp/blob/master/test_cpp.pl">test_cpp.pl</a>). 
Notable examples:
<ul class="latex">
<li><a id="idx:addnum3:2"></a><span class="pred-ext">add_num/3</span> - 
same as <code>A3 is A1+A2</code>, converting the sum to an integer if 
possible.
<li><a id="idx:namearity3:3"></a><span class="pred-ext">name_arity/3</span> 
- C++ implementation of <a id="idx:functor3:4"></a><span class="pred-ext">functor/3</span>.
<li><a id="idx:average3:5"></a><span class="pred-ext">average/3</span> - 
computes the average of all the solutions to <var>Goal</var>
<li><a id="idx:canunify2:6"></a><span class="pred-ext">can_unify/2</span> 
- tests whether the two arguments can unify with each other, without 
instantiating anything (similar to <a id="idx:unifiable3:7"></a><span class="pred-ext">unifiable/3</span>).
<li><a id="idx:eq11:8"></a><span class="pred-ext">eq1/1</span>, <a id="idx:eq22:9"></a><span class="pred-ext">eq2/2</span>, <a id="idx:eq32:10"></a><span class="pred-ext">eq3/2</span> 
- three different ways of implementing =/2.
<li><a id="idx:writelist1:11"></a><span class="pred-ext">write_list/1</span> 
- outputs the elements of a list, each on a new line.
<li><a id="idx:cappend3:12"></a><span class="pred-ext">cappend/3</span> 
- appends two lists (requires that the two lists are instantiated).
<li><a id="idx:squareroots2:13"></a><span class="pred-ext">square_roots/2</span> 
- same as <code>bagof(Sqrt, X^(between(0,4,X), Sqrt is sqrt(X)), A2)</code>.
<li><a id="idx:rangecpp3:14"></a><span class="pred-ext">range_cpp/3</span> 
- on backtracking, generates all integers starting at <var>A1</var> and 
less than <var>A2</var> (that is, one less than <a id="idx:between3:15"></a><span class="pred-ext">between/3</span>).
<li><a id="idx:intinfo2:16"></a><span class="pred-ext">int_info/2</span> 
- on backtracking generates all the integral types with their minimum 
and maximum values.
</ul>

<p>The file
<a class="url" href="https://github.com/SWI-Prolog/packages-cpp/blob/master/test_cpp.cpp">likes.cpp</a> 
contains a simple program that calls the Prolog predicate <a id="idx:likes2:17"></a><span class="pred-ext">likes/2</span> 
and
<a id="idx:happy1:18"></a><span class="pred-ext">happy/1</span> (these 
predicates are defined in
<a class="url" href="https://github.com/SWI-Prolog/packages-cpp/blob/master/test_cpp.pl">likes.pl</a>. 
The usage and how to compile the code are in comments in <code>likes.cpp</code>

<p><h2 id="sec:cpp2-intro"><a id="sec:1.4"><span class="sec-nr">1.4</span> <span class="sec-title">Introduction</span></a></h2>

<a id="sec:cpp2-intro"></a>

<p>C++ provides a number of features that make it possible to define a 
more natural and concise interface to dynamically typed languages than 
plain C does. Using type-conversion (<em>casting</em>) and overloading, 
native data-types can be easily translated into appropriate Prolog 
types, automatic destructors can be used to deal with most of the 
cleanup required and C++ exception handling can be used to map Prolog 
exceptions and interface conversion errors to C++ exceptions, which are 
automatically mapped to Prolog exceptions as control is turned back to 
Prolog.

<p>However, there are subtle differences between Prolog and C++ that can 
lead to confusion; in particular, the lifetime of terms do not fit well 
with the C++ notion of constructor/destructor. It might be possible to 
handle this with &ldquo;smart pointers&rdquo; , but that would lead to 
other complications, so the decision was made to provide a thin layer 
between the underlying C functions and the C++ 
classes/methods/functions.

<p>More information on the SWI-Prolog native types is given in
<a class="url" href="https://www.swi-prolog.org/pldoc/man?section=foreigntypes">Interface 
Data Types</a>.

<p>It would be tempting to use C++ implicit conversion operators and 
method overloading to automatically convert between C++ types such as
<code>std::string</code> and <code>int64_t</code> and Prolog foreign 
language interface types such as <code>term_t</code> and <code>atom_t</code>. 
However, types such as <code>term_t</code> are unsigned integers, so 
many of the automatic type conversions can inadvertently do something 
other than what the programmer intended, resulting in subtle bugs that 
are difficult to find. Therefore Version 2 of this interface reduces the 
amount of automatic conversion and introduces some redundancy, to avoid 
these subtle bugs, by using &ldquo;getter&rdquo; methods rather than 
conversion operators, and using naming conventions for explicitly 
specifying constructors.

<p><h3 id="sec:cpp2-acknowledgements"><a id="sec:1.4.1"><span class="sec-nr">1.4.1</span> <span class="sec-title">Acknowledgements</span></a></h3>

<a id="sec:cpp2-acknowledgements"></a>

<p>I would like to thank Anjo Anjewierden for comments on the 
definition, implementation and documentation of the original C++ 
interface. Peter Ludemann implemented the current version (2) of the 
interface (see
<a class="sec" href="#sec:1.1">section 1.1</a>).

<p><h2 id="sec:cpp2-life-of-a-predicate"><a id="sec:1.5"><span class="sec-nr">1.5</span> <span class="sec-title">The 
life of a PREDICATE</span></a></h2>

<a id="sec:cpp2-life-of-a-predicate"></a>

<p>A foreign predicate is defined using the <a class="func" href="#PREDICATE()">PREDICATE()</a> 
macro, plus a few variations on this, such as
<a class="func" href="#PREDICATE_NONDET()">PREDICATE_NONDET()</a>, <a class="func" href="#NAMED_PREDICATE()">NAMED_PREDICATE()</a>, 
and
<a class="func" href="#NAMED_PREDICATE_NONDET()">NAMED_PREDICATE_NONDET()</a>. 
These define an internal name for the function, register it with the 
SWI-Prolog runtime (where it will be picked up by the <a id="idx:useforeignlibrary1:19"></a><span class="pred-ext">use_foreign_library/1</span> 
directive), and define the names <code>A1</code>, <code>A2</code>, etc. 
for the arguments.<sup class="fn">6<span class="fn-text">You can define 
your own names for the arguments, for example: <code>auto dir=A1, db=A2;</code> 
or <code>PlTerm options(A3);</code>.</span></sup> If a non-deterministic 
predicate is being defined, an additional parameter <code>handle</code> 
is defined (of type
<code>PlControl</code>).

<p>The foreign predicate returns a value:
<ul class="latex">
<li><code>true</code> - success
<li><code>false</code> - failure or an error (see <a class="sec" href="#sec:1.15">section 
1.15</a> and <a class="url" href="https://www.swi-prolog.org/pldoc/man?section=foreign-exceptions">Prolog 
exceptions in foreign code</a>).
<li> &ldquo;retry&rdquo; - for non-deterministic predicates, gives a &ldquo;context&rdquo; for 
backtracking / redoing the call for the next solution.
</ul>
If a predicate fails, it could be simple failure (the equivalent of 
calling the builtin <a id="idx:fail0:20"></a><span class="pred-ext">fail/0</span> 
predicate) or an error (the equivalent of calling the <a id="idx:throw1:21"></a><span class="pred-ext">throw/1</span> 
predicate). When a Prolog exception is raised, it is important that a 
return be made to the calling environment as soon as possible. In C 
code, this requires checking every call for failure, which can become 
cumbersome; with the C++ API, most errors are thrown as exceptions to 
the enclosing <a class="func" href="#PREDICATE()">PREDICATE()</a> 
wrapper, and turned back into Prolog errors.

<p>The C++ API provides Plx_*() functions that are the same as the 
PL_*() functions except that where appropriate they check for exceptions 
and thrown a <b>PlException()</b>.

<p>Addditionally, the function <a class="func" href="#PlCheckFail()">PlCheckFail()</a> 
can be used to check for failure and throw a <code>PlFail</code> 
exception that is handled before returning to Prolog with failure.

<p>The following three snippets do essentially the same thing (for 
implementing the equivalent of =/2); however the first version (with
<a class="func" href="#PlTerm::unify_term()">PlTerm::unify_term()</a>) 
and second version (with <b>Plx_unify()</b>) throw a C++ <code>PlExceptionFail</code> 
exception if there's an error and otherwise return <code>true</code> or <code>false</code>; 
the third version (with <a class="func" href="#PlCheckFail()">PlCheckFail()</a>) 
throws a <code>PlFail</code> exception for failure (and <code>PlExceptionFail</code> 
for an error) and otherwise returns <code>true</code> - the <a class="func" href="#PREDICATE()">PREDICATE()</a> 
wrapper handles all of these appropriately and reports the same result 
back to Prolog; but you might wish to distinguish the two situations in 
more complex code.

<pre class="code">
PREDICATE(eq, 2)
{ return A1.unify_term(A2);
}
</pre>

<pre class="code">
PREDICATE(eq, 2)
{ return Plx_unify(A1.unwrap(), A2.unwrap()));
}
</pre>

<pre class="code">
PREDICATE(eq, 2)
{ PlCheckFail(A1.unify_term(A2));
  return true;
}
</pre>

<p><h2 id="sec:cpp2-overview"><a id="sec:1.6"><span class="sec-nr">1.6</span> <span class="sec-title">Overview</span></a></h2>

<a id="sec:cpp2-overview"></a>

<p>One useful area for exploiting C++ features is type-conversion. 
Prolog variables are dynamically typed and all information is passed 
around using the C-interface type <code>term_t</code>. In C++,
<code>term_t</code> is embedded in the <em>lightweight</em> class
<code>PlTerm</code>. Other lightweight classes, such as <code>PlAtom</code> 
for
<code>atom_t</code> are also provided. Constructors and operator 
definitions provide flexible operations and integration with important 
C-types (<code>char*</code>, <code>wchar_t*</code>, <code>long</code> 
and
<code>double</code>), plus the C++-types (<code>std::string</code>,
<code>std::wstring</code>). (<code>char*</code> and <code>wchar_t*</code> 
are deprecated in the C++ API; <code>std::string</code> and
<code>std::wstring</code> are safer and should be used instead.)

<p>Another useful area is in handling errors and cleanup. Prolog errors 
can be modeled using C++ exceptions; and C++'s destructors can be used 
to clean up error situations, to prevent memory and other resource 
leaks.

<p><h3 id="sec:cpp2-philosophy"><a id="sec:1.6.1"><span class="sec-nr">1.6.1</span> <span class="sec-title">Design 
philosophy of the classes</span></a></h3>

<a id="sec:cpp2-philosophy"></a>

<p>See also <a class="sec" href="#sec:1.6.5">section 1.6.5</a> for more 
on naming conventions and standard methods.

<p>The general philosophy for C++ classes is that a &ldquo;half-created&rdquo; object 
should not be possible - that is, the constructor should either succeed 
with a completely usable object or it should throw an exception. This 
API tries to follow that philosophy, but there are some important 
exceptions and caveats. (For more on how the C++ and Prolog exceptions 
interrelate, see <a class="sec" href="#sec:1.15">section 1.15</a>.)

<p>Most of the PL_*() functions have corresponding wrapper methods. For 
example, <a class="func" href="#PlTerm::get_atom()">PlTerm::get_atom()</a> 
calls <b>Plx_get_atom()</b>, which calls
<b>PL_get_atom()</b>. If the <b>PL_get_atom()</b> has an error, it 
creates a Prolog error; the <b>Plx_get_atom()</b> wrapper checks for 
this and converts the error to a C++ exception, which is thrown; upon 
return to Prolog, the exception is turned back into a Prolog error. 
Therfore, code typically does not need to check for errors.

<p>Some functions return <code>false</code> to indicate either failure 
or an error, for example <a class="func" href="#PlTerm::unify_term()">PlTerm::unify_term()</a>; 
for such methods, a check is made for an error and an exception is 
thrown, so the return value of
<code>false</code> only means failure. (The whole thing can be wrapped 
in
<a class="func" href="#PlCheckFail()">PlCheckFail()</a>, in which case a <code>PlFail</code> 
exception is thrown, which is converted to failure in Prolog.) For more 
on this, see
<a class="sec" href="#sec:1.6.4">section 1.6.4</a>, and for handling 
failure, see
<a class="sec" href="#sec:1.13.1">section 1.13.1</a>.

<p>For PL_*() functions that take or return <code>char*</code> or
<code>wchar_t*</code> values, there are also wrapper functions and 
methods that use <code>std::string</code> or <code>std::wstring</code>. 
Because these copy the values, there is usually no need to enclose the 
calls with
<code>PlStringBuffers</code> (which wraps <b>PL_STRING_MARK()</b> and
<b>PL_STRING_RELEASE()</b>). See also the rationale for string:
<a class="sec" href="#sec:1.8.2">section 1.8.2</a>.

<p>Many of the classes (<code>PlAtom</code>, <code>PlTerm</code>, etc.) 
are thin wrappers around the C interface's types (<code>atom_t</code>,
<code>term_t</code>, etc.). As such, they inherit the concept of &ldquo;null&rdquo; from 
these types (which is abstracted as <code>PlAtom::null</code>,
<code>PlTerm::null</code>, etc., which typically is equivalent to
<code>0</code>). Normally, you shouldn't need to check whether the 
object is &ldquo;fully created&rdquo; , for the rare situations where a 
check is needed, the methods <a class="func" href="#is_null()">is_null()</a> 
and <a class="func" href="#not_null()">not_null()</a> are provided.

<p>Most of the classes have constructors that create a &ldquo;complete&rdquo; object. 
For example,

<pre class="code">
PlAtom foo("foo");
</pre>

<p>will ensure that the object <code>foo</code> is useable and will 
throw an exception if the atom can't be created. However, if you choose 
to create a <code>PlAtom</code> object from an <code>atom_t</code> 
value, no checking is done (similarly, no checking is done if you create 
a <code>PlTerm</code> object from a <code>term_t</code> value).

<p>In many situations, you will be using a term; for these, there are 
special constructors. For example:

<pre class="code">
PlTerm_atom foo("foo"); // Same as PlTerm(PlAtom("foo"))
PlTerm_string str("a string");
</pre>

<p>To help avoid programming errors, some of the classes do not have a 
default &ldquo;empty&rdquo; constructor. For example, if you with to 
create a
<code>PlAtom</code> that is uninitialized, you must explicitly use
<code><a class="func" href="#PlAtom()">PlAtom(PlAtom::null)</a></code>. 
This make some code a bit more cumbersome because you can't omit the 
default constructors in struct initalizers.

<p>Many of the classes have an <a class="func" href="#as_string()">as_string()</a> 
method<sup class="fn">7<span class="fn-text">This might be changed in 
future to <b>to_string()</b>, to be consistent with <code><b>std::to_string()</b></code></span></sup>, 
which is useful for debugging.

<p>The method names such as
<b>as_int32_t()</b> were chosen itnstead of <b>to_int32_t()</b> because 
they imply that the representation is already an <code>int32_t</code>, 
and not that the value is converted to a <code>int32_t</code>. That is, 
if the value is a float, <code>int32_t</code> will fail with an error 
rather than (for example) truncating the floating point value to fit 
into a 32-bit integer.

<p>Many of the classes wrap long-lived items, such as atoms, functors, 
predicates, or modules. For these, it's often a good idea to define them 
as <code>static</code> variables that get created at load time, so that 
a lookup for each use isn't needed (atoms are unique, so
<code><a class="func" href="#PlAtom()">PlAtom("foo")</a></code> requires 
a lookup for an atom <code>foo</code> and creates one if it isn't 
found).

<p>C code sometimes creates objects &ldquo;lazily&rdquo; on first use:

<pre class="code">
void my_function(...)
{ static atom_t ATOM_foo = 0;
   ...
  if ( ! foo  )
     foo = PL_new_atom("foo");
   ...
}
</pre>

<p>For C++, this can be done in a simpler way, because C++ will call a 
local &ldquo;<code>static</code>&rdquo; constructor on first use.

<pre class="code">
void my_function(...)
{ static PlAtom ATOM_foo("foo");
}
</pre>

<p>The class <code>PlTerm</code> (which wraps <code>term_t</code>) is 
the most used. Although a <code>PlTerm</code> object can be created from 
a <code>term_t</code> value, it is intended to be used with a 
constructor that gives it an initial value. The default constructor 
calls <b>PL_new_term_ref()</b> and throws an exception if this fails. 
The various constructors are described in
<a class="sec" href="#sec:1.6.6">section 1.6.6</a>. Note that the 
default constructor is not public; to create a &ldquo;variable&rdquo; term, 
you should use the subclass constructor <b>PlTerm_var()</b>.

<p><h3 id="sec:cpp2-files-summary"><a id="sec:1.6.2"><span class="sec-nr">1.6.2</span> <span class="sec-title">Summary 
of files</span></a></h3>

<a id="sec:cpp2-files-summary"></a>

<p>The following files are provided:
<ul class="latex">
<li><code>SWI-cpp2.h</code> - Include this file to get the C++ API. It 
automatically includes
<code>SWI-cpp2-plx.h</code> and <code>SWI-cpp2.cpp</code>, unless the 
macro <code>_SWI_CPP2_CPP_SEPARATE</code> is defined, in which case you 
must compile <code>SWI-cpp2.cpp</code> separately.

<p>
<li><code>SWI-cpp2.cpp</code> - Contains the implementations of some 
methods and functions. If you wish to compile this separately, you must 
define the macro <code>_SWI_CPP2_CPP_SEPARATE</code> before your include 
for <code>SWI-cpp2.h</code>.

<p>
<li><code>SWI-cpp2-plx.h</code> - Contains the wrapper functions for the 
most of the functions in
<code>SWI-Prolog.h</code>. This file is not intended to be used by 
itself, but is <code>#include</code>d by <code>SWI-cpp2.h</code>.

<p>
<li><code>SWI-cpp2-atommap.h</code> - Contains a utility class for 
mapping atom-to-atom or atom-to-term, which is useful for naming 
long-lived blobs instead of having to pass them around as arguments.

<p>
<li><code>test_cpp.cpp</code>, <code>test_cpp.pl</code> - Contains 
various tests, including some longer sequences of code that can help in 
understanding how the C++ API is intended to be used. In addition, there 
are <code>test_ffi.cpp</code>, <code>test_ffi.pl</code>, which often 
have the same tests written in C, without the C++ API.

<p>
</ul>

<p><h3 id="sec:cpp2-class-summary"><a id="sec:1.6.3"><span class="sec-nr">1.6.3</span> <span class="sec-title">Summary 
of classes</span></a></h3>

<a id="sec:cpp2-class-summary"></a>

<p>The list below summarises the classes defined in the C++ interface.

<dl class="latex">
<dt><a id="class:PlTerm"><strong>PlTerm</strong></a></dt>
<dd class="defbody">
Generic Prolog term that wraps <code>term_t</code> (for more details on <code>term_t</code>, 
see
<a class="url" href="https://www.swi-prolog.org/pldoc/man?section=foreigntypes">Interface 
Data Types</a>).

<p>This is a &ldquo;base class&rdquo; whose constructor is protected; 
subclasses specify the actual contents. Additional methods allow 
checking the Prolog type, unification, comparison, conversion to native 
C++-data types, etc. See <a class="sec" href="#sec:1.11.1">section 
1.11.1</a>.

<p>For more details about <code>PlTerm</code>, see <a class="sec" href="#sec:1.6.6">section 
1.6.6</a></dd>
<dt><a id="class:PlCompound"><strong>PlCompound</strong></a></dt>
<dd class="defbody">
Subclass of <code>PlTerm</code> with constructors for building compound 
terms. If there is a single string argument, then <b>PL_chars_to_term()</b> 
or <b>PL_wchars_to_term()</b> is used to parse the string and create the 
term. If the constructor has two arguments, the first is name of a 
functor and the second is a <code>PlTermv</code> with the arguments.
</dd>
<dt><a id="class:PlTermv"><strong>PlTermv</strong></a></dt>
<dd class="defbody">
Vector of Prolog terms. See <b>PL_new_term_refs()</b>. The <code><code>[]</code></code> 
operator is overloaded to access elements in this vector. <code>PlTermv</code> 
is used to build complex terms and provide argument-lists to Prolog 
goals.</dd>
<dt><a id="class:PlAtom"><strong>PlAtom</strong></a></dt>
<dd class="defbody">
Wraps <code>atom_t</code> in their internal Prolog representation for 
fast comparison. (For more details on
<code>atom_t</code>, see
<a class="url" href="https://www.swi-prolog.org/pldoc/man?section=foreigntypes">Interface 
Data Types</a>). For more details of <code>PlAtom</code>, see <a class="sec" href="#sec:1.11.12.4">section 
1.11.12.4</a>.
</dd>
<dt><a id="class:PlFunctor"><strong>PlFunctor</strong></a></dt>
<dd class="defbody">
A wrapper for <code>functor_t</code>, which maps to the internal 
representation of a name/arity pair.
</dd>
<dt><a id="class:PlPredicate"><strong>PlPredicate</strong></a></dt>
<dd class="defbody">
A wrapper for <code>predicate_t</code>, which maps to the internal 
representation of a Prolog predicate.
</dd>
<dt><a id="class:PlModule"><strong>PlModule</strong></a></dt>
<dd class="defbody">
A wrapper for <code>module_t</code>, which maps to the internal 
representation of a Prolog module.
</dd>
<dt><a id="class:PlQuery"><strong>PlQuery</strong></a></dt>
<dd class="defbody">
Represents opening and enumerating the solutions to a Prolog query.
</dd>
<dt><a id="class:PlException"><strong>PlException</strong></a></dt>
<dd class="defbody">
If a call to Prolog results in an error, the C++ interface converts the 
error into a <code>PlException</code> object and throws it. If the 
enclosing code doesn't intercept the exception, the <code>PlException</code> 
object is turned back into a Prolog error when control returns to Prolog 
from the <a class="func" href="#PREDICATE()">PREDICATE()</a> macros. 
This is a subclass of <code>PlExceptionBase</code>, which is a subclass 
of <code>std::exception</code>.
</dd>
<dt><a id="class:PlFrame"><strong>PlFrame</strong></a></dt>
<dd class="defbody">
This utility-class can be used to discard unused term-references as well 
as to do <em>data-backtracking</em>.
</dd>
<dt><a id="class:PlEngine"><strong>PlEngine</strong></a></dt>
<dd class="defbody">
This class is used in <em>embedded</em> applications (applications where 
the main control is held in C++). It provides creation and destruction 
of the Prolog environment.
</dd>
<dt><a id="class:PlRegister"><strong>PlRegister</strong></a></dt>
<dd class="defbody">
Encapsulates <b>PL_register_foreign()</b> to allow using C++ global 
constructors for registering foreign predicates.</dd>
<dt><a id="class:PlFail"><strong>PlFail</strong></a></dt>
<dd class="defbody">
Can be thrown to short-circuit processing and return failure to Prolog. 
Performance-critical code should use <code>return false</code> instead 
if failure is expected. An error can be signaled by calling
<b>Plx_raise_exception()</b> or one of the PL_*<b>_error()</b> functions 
and then throwing <code>PlFail</code>; but it's better style to create 
the error throwing one of the subclasses of <code>PlException</code> 
e.g.,
<code>throw <b>PlTypeError("int", t)</b></code>. Subclass of <code>PlExceptionFailBase</code>.</dd>
<dt><a id="class:PlExceptionFail"><strong>PlExceptionFail</strong></a></dt>
<dd class="defbody">
In some situations, a Prolog error cannot be turned into a
<code>PlException</code> object, so a <code>PlExceptionFail</code> 
object is thrown. This is turned into failure by the <a class="func" href="#PREDICATE()">PREDICATE()</a> 
macro, resulting in normal Prolog error handling. Subclass of <code>PlExceptionFailBase</code>.</dd>
<dt><a id="class:PlExceptionBase"><strong>PlExceptionBase</strong></a></dt>
<dd class="defbody">
A &ldquo;do nothing&rdquo; subclass of <code>std::exception</code>, to 
allow catching
<code>PlException</code>, <code>PlExceptionFail</code> or <code>PlFail</code> 
in a single &ldquo;catch&rdquo; clause.</dd>
<dt><a id="class:PlExceptionFailBase"><strong>PlExceptionFailBase</strong></a></dt>
<dd class="defbody">
A &ldquo;do nothing&rdquo; subclass of <code>PlExceptionBase</code>, to 
allow catching
<code>PlExceptionFail</code> or <code>PlFail</code> in a single &ldquo;catch&rdquo; clause, 
excluding <code>PlException</code>.

<p></dd>
</dl>

<p><h3 id="sec:cpp2-wrapper-functions"><a id="sec:1.6.4"><span class="sec-nr">1.6.4</span> <span class="sec-title">Wrapper 
functions</span></a></h3>

<a id="sec:cpp2-wrapper-functions"></a>

<p>The various PL_*() functions in <code>SWI-Prolog.h</code> have 
corresponding Plx_*() functions, defined in <code>SWI-cpp2-plx.h</code>, 
which is always included by <code>SWI-cpp2.h</code>. There are three 
kinds of wrappers, with the appropriate one being chosen according to 
the semantics of the wrapped function:
<ul class="latex">
<li> &ldquo;as-is&rdquo; - the PL_*() function cannot cause an error. If 
it has a return value, the caller will want to use it.

<p>
<li> &ldquo;exception wrapper&rdquo; - the PL_*() function can return <code>false</code>, 
indicating an error. The Plx_*() function checks for this and throws a <code>PlException</code> 
object containing the error. The wrapper uses <code>template&lt;typename 
C_t&gt; C_t <a class="func" href="#PlEx()">PlEx(C_t rc)</a></code>, 
where <code>C_t</code> is the return type of the PL_*() function.

<p>
<li> &ldquo;success, failure, or error&rdquo; - the PL_*() function can 
return
<code>true</code> if it succeeds and <code>false</code> if it fails or 
has a runtime error. If it fails, the wrapper checks for a Prolog error 
and throws a <code>PlException</code> object containing the error. The 
wrapper uses <code>template&lt;typename C_t&gt; C_t <a class="func" href="#PlWrap()">PlWrap(C_t 
rc)</a></code>, where <code>C_t</code> is the return type of the PL_*() 
function.

<p>
</ul>

<p>A few PL_*() functions do not have a corresponding Plx*() function 
because they do not fit into one of these categories. For example,
<b>PL_next_solution()</b> has multiple return values (<code>PL_S_EXCEPTION</code>,
<code>PL_S_LAST</code>, etc.) if the query was opened with the
<code>PL_Q_EXT_STATUS</code> flag.

<p>Most of the PL_*() functions whose first argument is of type
<code>term_t</code>, <code>atom_t</code>, etc. have corresponding 
methods in classes <code>PlTerm</code>, <code>PlAtom</code>, etc.

<p><em>Important</em>: You should use the Plx_*() wrappers only in the 
context of a <a class="func" href="#PREDICATE()">PREDICATE()</a> call, 
which will handle any C++ exceptions. Some blob callbacks can also 
handle an exception (see
<a class="sec" href="#sec:1.6.8">section 1.6.8</a>). Everywhere else, 
the result of calling a Plx_*() function is unpredicatable - probably a 
crash.

<p><h3 id="sec:cpp2-naming"><a id="sec:1.6.5"><span class="sec-nr">1.6.5</span> <span class="sec-title">Naming 
conventions, utility functions and methods</span></a></h3>

<a id="sec:cpp2-naming"></a>

<p>See also the discussion on design philosophy in <a class="sec" href="#sec:1.6.1">section 
1.6.1</a>.

<p>The classes all have names starting with &ldquo;Pl&rdquo; , using 
CamelCase; this contrasts with the C functions that start with &ldquo;PL_&rdquo; and 
use underscores.

<p>The wrapper classes (<code>PlFunctor</code>, <code>PlAtom</code>,
<code>PlTerm</code>), etc. all contain a field <code>C_</code> that 
contains the wrapped value (<code>functor_t</code>, <code>atom_t</code>, <code>term_t</code> 
respectively). If this wrapped value is needed, it should be accessed 
using the <b>unwrap()</b> or <b>unwrap_as_ptr()</b> methods.

<p>In some cases, it's natural to use a pointer to a wrapper class. For 
those, the function <b>PlUnwrapAsPtr()</b> returns <code>nullptr</code> 
if the pointer is null; otherwise it returns the wrapped value (which 
itself might be some kind of &ldquo;null&rdquo; ).

<p>The wrapper classes, which subclass <code>WrappedC<var>&lt;</var>...<var>&gt;</var></code>, 
all define the following methods and constants:
<ul class="latex">
<li>Default constructor (sets the wrapped value to <code>null</code>). 
Some classes do not have a default constructor because it can lead to 
subtle bugs - instead, they either have a different way of creating the 
object or can use the &ldquo;null&rdquo; value for the class.
<li>Constructor that takes the wrapped value (e.g., for <code>PlAtom</code>, 
the constructor takes an <code>atom_t</code> value).
<li><code>C_</code> - the wrapped value. This can be used directly when 
calling C functions, for example, if <code>t</code> and <code>a</code> 
are of type <code>PlTerm</code> and <code>PlAtom</code>: <code>PlEx(PL_put_atom(t.unwrap(),a.unwrap()))</code> 
(although it's better to do <code>Plx_put_atom(t.unwrap(),a.unwrap())</code>, 
which does the check).
<li><code>null</code> - the null value (typically <code>0</code>, but 
code should not rely on this).
<li><code><a class="func" href="#is_null()">is_null()</a></code>, <code><a class="func" href="#not_null()">not_null()</a></code> 
- test for the wrapped value being <code>null</code>.
<li><code><a class="func" href="#reset()">reset()</a></code> - set the 
wrapped value to <code>null</code>
<li><code>reset(new_value)</code> - set the wrapped value from the 
wrapped type (e.g., <b>PlTerm::reset(term_t new_value)</b>)
<li><code>reset_wrapped(new_value)</code> - set the wrapped value from 
the same type (e.g., <b>PlTerm::reset_wrapped(PlTerm new_value)</b>)
<li>The <code>bool</code> operator is disabled - you should use <a class="func" href="#not_null()">not_null()</a> 
instead.<sup class="fn">8<span class="fn-text">The reason: a <code>bool</code> 
conversion causes ambiguity with <code><a class="func" href="#PlAtom()">PlAtom(PlTterm)</a></code> 
and <code><a class="func" href="#PlAtom()">PlAtom(atom_t)</a></code>.</span></sup>
</ul>

<p>The method <b>unwrap()</b> can be used to access the <code>C_</code> 
field, and can be used wherever a <code>atom_t</code> or <code>term_t</code> 
is used. For example, the <b>PL_scan_options()</b> example code can be 
written as follows. Note the use of <code>&amp;callback.<b>unwrap()</b></code> 
to pass a pointer to the wrapped <code>term_t</code> value.

<pre class="code">
PREDICATE(mypred, 2)
{ auto options = A2;
  int        quoted = false;
  size_t     length = 10;
  PlTerm_var callback;

  PlCheckFail(PL_scan_options(options, 0, "mypred_options", mypred_options,
                              &amp;quoted, &amp;length, &amp;callback.unwrap()));
  callback.record(); // Needed if callback is put in a blob that Prolog doesn't know about.
                     // If it were an atom (OPT_ATOM): register_ref().

  &lt;implement mypred&gt;
}
</pre>

<p>For functions in <code>SWI-Prolog.h</code> that don't have a C++ 
equivalent in <code>SWI-cpp2.h</code>, <a class="func" href="#PlCheckFail()">PlCheckFail()</a> 
is a convenience function that checks the return code and throws a <code>PlFail</code> 
exception on failure or <code>PlException</code> if there was an 
exception. The enclosing <a class="func" href="#PREDICATE()">PREDICATE()</a> 
code catches <code>PlFail</code> exceptions and converts them to the <code>foreign_t</code> 
return code for failure. If the failure from the C function was due to 
an exception (e.g., unification failed because of an out-of-memory 
condition), the foreign function caller will detect that situation and 
convert the failure to an exception.

<p>The &ldquo;getter&rdquo; methods for <code>PlTerm</code> all throw an 
exception if the term isn't of the expected Prolog type. The &ldquo;getter&rdquo; methods 
typically start with &ldquo;as&rdquo; , e.g. <a class="func" href="#PlTerm::as_string()">PlTerm::as_string()</a>. 
There are also other &ldquo;getter&rdquo; methods, such as <a class="func" href="#PlTerm::get_float_ex()">PlTerm::get_float_ex()</a> 
that wrap PL_*() functions.

<p> &ldquo;getters&rdquo; for integers have an additional problem, in 
that C++ doesn't define the sizes of <code>int</code>, <code>long</code>, 
or
<code>size_t</code>. It seems to be impossible to make an overloaded 
method that works for all the various combinations of integer types on 
all compilers, so there are specific methods for <code>int64_t</code>,
<code>uint64_t</code>, <code>size_t</code>.

<p>In some cases,it is possible to overload methods; for example, this 
allows the following code without knowing the exact definition of
<code>size_t</code>:

<pre class="code">
PREDICATE(p, 1)
{ size_t sz;
  A1.integer(&amp;sz);
     ...
}
</pre>

<p><em>It is strongly recommended that you enable conversion checking.</em> 
For example, with GNU C++, use these options (possibly with <code>-Werror</code>):
<code>-Wconversion -Warith-conversion -Wsign-conversion 
-Wfloat-conversion</code>.

<p>There is an additional problem with characters - C promotes them to <code>int</code> 
but C++ doesn't. In general, this shouldn't cause any problems, but care 
must be used with the various getters for integers.

<p><h3 id="sec:cpp2-plterm"><a id="sec:1.6.6"><span class="sec-nr">1.6.6</span> <span class="sec-title">PlTerm 
class</span></a></h3>

<a id="sec:cpp2-plterm"></a>

<p>As we have seen from the examples, the <code>PlTerm</code> class 
plays a central role in conversion and operating on Prolog data. This 
section provides complete documentation of this class.

<p>There are a number of subclasses that exist only to provide a safe 
way of constructing at term. There is also a subclass (<code>PlTermScoped</code>) 
that helps reclaim terms.

<p>Most of the <code>PlTerm</code> constructors are defined as 
subclasses of
<code>PlTerm</code>, with a name that reflects the Prolog type of what 
is being created (e.g., <code>PlTerm_atom</code> creates a term from an 
atom;
<code>PlTerm_string</code> creates a term from a Prolog string). This is 
done to ensure that the there is no ambiguity in the constructors - for 
example, there is no way to distinguish between <code>term_t</code>,
<code>atom_t</code>, and ordinary integers, so there are constructors
<b>PlTerm()</b>, <b>PlTerm_atom()</b>, and PlTerm_integer. All of the 
constructors are &ldquo;explicit&rdquo; because implicit creation of <code>PlTerm</code> 
objects can lead to subtle and difficult to debug errors.

<p>If a constructor fails (e.g., out of memory), a <code>PlException</code> 
is thrown. The class and subclass constructors are as follows.

<dl class="latex">
<dt><strong>PlTerm :: PlTerm</strong>(<var>PlAtom a</var>)</dt>
<dd class="defbody">
Creates a term reference containing an atom, using <b>PL_put_atom()</b>. 
It is the same as <b>PlTerm_atom()</b>.
</dd>
<dt><strong>PlTerm :: PlTerm</strong>(<var>term_t t</var>)</dt>
<dd class="defbody">
Creates a term reference from a C term (by wrapping it). As this is a 
lightweight class, this is a no-op in the generated code.
</dd>
<dt><strong>PlTerm :: PlTerm</strong>(<var>PlRecord r</var>)</dt>
<dd class="defbody">
Creates a term reference from a record, using <b>PL_recorded()</b>.
</dd>
<dt><strong>PlTerm_atom :: PlTerm_atom</strong>(<var>atom_t a</var>)</dt>
<dd class="defbody">
Creates a term reference containing an atom.
</dd>
<dt><strong>PlTerm_atom :: PlTerm_atom</strong>(<var>PlAtom a</var>)</dt>
<dd class="defbody">
Creates a term reference containing an atom.
</dd>
<dt><strong>PlTerm_atom :: PlTerm_atom</strong>(<var>const char *text</var>)</dt>
<dd class="defbody">
Creates a term reference containing an atom, after creating the atom 
from the <var>text</var>.
</dd>
<dt><strong>PlTerm_atom :: PlTerm_atom</strong>(<var>const wchar_t *text</var>)</dt>
<dd class="defbody">
Creates a term reference containing an atom, after creating the atom 
from the <var>text</var>.
</dd>
<dt><strong>PlTerm_atom :: PlTerm_atom</strong>(<var>const std::string&amp; 
text</var>)</dt>
<dd class="defbody">
Creates a term reference containing an atom, after creating the atom 
from the <var>text</var>.
</dd>
<dt><strong>PlTerm_atom :: PlTerm_atom</strong>(<var>const std::wstring&amp; 
text</var>)</dt>
<dd class="defbody">
Creates a term reference containing an atom, after creating the atom 
from the <var>text</var>.
</dd>
<dt><strong>PlTerm_var :: PlTerm_var</strong>(<var></var>)</dt>
<dd class="defbody">
Creates a term reference for an uninstantiated variable. Typically this 
term is then unified with another object.
</dd>
<dt><strong>PlTerm_term_t :: PlTerm_term_t</strong>(<var></var>)</dt>
<dd class="defbody">
Creates a term reference from a C <code>term_t</code>. This is a 
lightweight class, so no code is generated.
</dd>
<dt><strong>PlTerm_integer :: PlTerm_integer</strong>(<var></var>)</dt>
<dd class="defbody">
Subclass of <code>PlTerm</code> with constructors for building a term 
that contains a Prolog integer from a
<code>long</code>.<sup class="fn">9<span class="fn-text"><b>PL_put_integer()</b> 
takes a <code>long</code> argument.</span></sup>
</dd>
<dt><strong>PlTerm_int64 :: PlTerm_int64</strong>(<var></var>)</dt>
<dd class="defbody">
Subclass of <code>PlTerm</code> with constructors for building a term 
that contains a Prolog integer from a <code>int64_t</code>.
</dd>
<dt><strong>PlTerm_uint64 :: PlTerm_uint64</strong>(<var></var>)</dt>
<dd class="defbody">
Subclass of <code>PlTerm</code> with constructors for building a term 
that contains a Prolog integer from a <code>uint64_t</code>.
</dd>
<dt><strong>PlTerm_size_t :: PlTerm_size_t</strong>(<var></var>)</dt>
<dd class="defbody">
Subclass of <code>PlTerm</code> with constructors for building a term 
that contains a Prolog integer from a <code>size_t</code>.
</dd>
<dt><strong>PlTerm_float :: PlTerm_float</strong>(<var></var>)</dt>
<dd class="defbody">
Subclass of <code>PlTerm</code> with constructors for building a term 
that contains a Prolog float.
</dd>
<dt><strong>PlTerm_pointer :: PlTerm_pointer</strong>(<var></var>)</dt>
<dd class="defbody">
Subclass of <code>PlTerm</code> with constructors for building a term 
that contains a raw pointer. This is mainly for backwards compatibility; 
new code should use <em>blobs</em>. A pointer is represented in Prolog 
as a mangled integer. The mangling is designed to make most pointers fit 
into a <em>tagged-integer</em>. Any valid pointer can be represented. 
This mechanism can be used to represent pointers to C++ objects in 
Prolog. Please note that <code>MyClass</code> should define conversion 
to and from <code>void *</code>.

<pre class="code">
PREDICATE(make_my_object, 1)
{ auto myobj = new MyClass();
  return A1.unify_pointer(myobj);
}

PREDICATE(my_object_contents, 2)
{ auto myobj = static_cast&lt;MyClass*&gt;(A1.as_pointer());
  return A2.unify_string(myobj-&gt;contents);
}

PREDICATE(free_my_object, 1)
{ auto myobj = static_cast&lt;MyClass*&gt;(A1.as_pointer());
  delete myobj;
  return true;
}
</pre>

</dd>
<dt><strong>PlTerm_string :: PlTerm_string</strong>(<var></var>)</dt>
<dd class="defbody">
Subclass of <code>PlTerm</code> with constructors for building a term 
that contains a Prolog string object. For constructing a term from the 
text form, see
<code>PlCompound</code>.
</dd>
<dt><strong>PlTerm_list_codes :: PlTerm_list_codes</strong>(<var></var>)</dt>
<dd class="defbody">
Subclass of <code>PlTerm</code> with constructors for building Prolog 
lists of character integer values.
</dd>
<dt><strong>PlTerm_chars :: PlTerm_chars</strong>(<var></var>)</dt>
<dd class="defbody">
Subclass of <code>PlTerm</code> with constructors for building Prolog 
lists of one-character atoms (as <a id="idx:atomchars2:22"></a><span class="pred-ext">atom_chars/2</span>).
</dd>
<dt><strong>PlTerm_tail :: PlTerm_tail</strong>(<var></var>)</dt>
<dd class="defbody">
SubClass of <code>PlTerm</code> for building and analysing Prolog lists.
</dd>
</dl>

<p>The methods are:

<dl class="latex">
<dt class="pubdef"><a id="PlTerm::get_atom()"><var>bool</var> <strong>PlTerm::get_atom</strong>(<var>PlAtom* 
a</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_get_atom()</b>, throwing an exception on Prolog error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_bool()"><var>bool</var> <strong>PlTerm::get_bool</strong>(<var>int* 
value</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_get_bool()</b>, throwing an exception on Prolog error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_chars()"><var>chars</var> <strong>PlTerm::get_chars</strong>(<var>char**s, 
unsigned int flags</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_get_chars()</b>, throwing an exception on Prolog error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_list_chars()"><var>chars</var> <strong>PlTerm::get_list_chars</strong>(<var>char**s, 
unsigned int flags</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_get_list_chars()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_list_chars()"><var>bool</var> <strong>PlTerm::get_list_chars</strong>(<var>char 
**s, unsigned int flags</var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_get_list_chars()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_atom_nchars()"><var>bool</var> <strong>PlTerm::get_atom_nchars</strong>(<var>size_t 
*len, char **a</var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_get_atom_nchars()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_list_nchars()"><var>bool</var> <strong>PlTerm::get_list_nchars</strong>(<var>size_t 
*len, char **s, unsigned int flags</var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_get_list_nchars()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_nchars()"><var>bool</var> <strong>PlTerm::get_nchars</strong>(<var>size_t 
*len, char **s, unsigned int flags</var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_get_nchars()</b>, throwing an exception on Prolog 
error. Deprecated: see <a class="func" href="#PlTerm::get_nchars()">PlTerm::get_nchars(flags)</a> 
that returns a <code>std::string</code>. If you use this, be sure to 
wrap it with <code>PlStringBuffers</code>, and if you use the <code>BUF_MALLOC</code> 
flag, you can use <code>std::unique_ptr&lt;char, decltype(&amp;PL_free)&gt;</code> 
to manage the pointer.
</dd>
<dt class="pubdef"><a id="PlTerm::get_wchars()"><var>bool</var> <strong>PlTerm::get_wchars</strong>(<var>size_t 
*length, pl_wchar_t **s, unsigned flags</var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_get_wchars()</b>, throwing an exception on Prolog 
error. Deprecated: see <b>PlTerm::getwchars(flags)</b> that returns a <code>std::wstring</code>. 
If you use this, be sure to wrap it with <code>PlStringBuffers</code>, 
and if you use the <code>BUF_MALLOC</code> flag, you can use <code>std::unique_ptr&lt;char, 
decltype(&amp;PL_close)&gt;</code> to manage the pointer.
</dd>
<dt class="pubdef"><a id="PlTerm::get_integer()"><var>bool</var> <strong>PlTerm::get_integer</strong>(<var>int 
*i</var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_get_integer()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_long()"><var>bool</var> <strong>PlTerm::get_long</strong>(<var>long 
*i</var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_get_long()</b>, throwing an exception on Prolog error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_intptr()"><var>bool</var> <strong>PlTerm::get_intptr</strong>(<var>intptr_t 
*i</var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_get_intptr()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_pointer()"><var>bool</var> <strong>PlTerm::get_pointer</strong>(<var>void 
**ptr</var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_get_pointer()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_float()"><var>bool</var> <strong>PlTerm::get_float</strong>(<var>double 
*f</var>)</a></dt>
<dd class="defbody">
Wrapper <b>Plx_get_float()</b>, throwing an exception on Prolog error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_functor()"><var>bool</var> <strong>PlTerm::get_functor</strong>(<var>PlFunctor 
*f</var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_get_functor()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_name_arity()"><var>bool</var> <strong>PlTerm::get_name_arity</strong>(<var>PlAtom 
*name, size_t *arity</var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_get_name_arity()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_compound_name_arity()"><var>bool</var> <strong>PlTerm::get_compound_name_arity</strong>(<var>PlAtom 
*name, size_t *arity</var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_get_compound_name_arity()</b>, throwing an exception 
on Prolog error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_module()"><var>bool</var> <strong>PlTerm::get_module</strong>(<var>PlModule 
*module</var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_get_module()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_arg()"><var>bool</var> <strong>PlTerm::get_arg</strong>(<var>size_t 
index, PlTerm a</var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_get_arg(index,)</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_dict_key()"><var>bool</var> <strong>PlTerm::get_dict_key</strong>(<var>PlAtom 
key, PlTerm dict, PlTerm value</var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_get_dict_key(key.)</b>, throwing an exception on 
Prolog error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_list()"><var>bool</var> <strong>PlTerm::get_list</strong>(<var>PlTerm 
h, PlTerm t</var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_get_list()</b>, throwing an exception on Prolog error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_head()"><var>bool</var> <strong>PlTerm::get_head</strong>(<var>PlTerm 
h</var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_get_head()</b>, throwing an exception on Prolog error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_tail()"><var>bool</var> <strong>PlTerm::get_tail</strong>(<var>PlTerm 
t</var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_get_tail()</b>, throwing an exception on Prolog error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_nil()"><var>bool</var> <strong>PlTerm::get_nil</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_get_nil()</b>, throwing an exception on Prolog error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_blob()"><var>bool</var> <strong>PlTerm::get_blob</strong>(<var>void 
**blob, size_t *len, PL_blob_t **type</var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_get_blob()</b>, throwing an exception on Prolog error.</dd>
<dt class="pubdef"><a id="PlTerm::get_file_name()"><var>bool</var> <strong>PlTerm::get_file_name</strong>(<var>char 
**name, int flags</var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_get_file_name()</b> (does not throw a C++ exception).
</dd>
<dt class="pubdef"><a id="PlTerm::get_file_nameW()"><var>bool</var> <strong>PlTerm::get_file_nameW</strong>(<var>wchar_t 
**name, int flags</var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_get_file_nameW()</b>, (does not throw a C++ 
exception).
</dd>
<dt class="pubdef"><a id="PlTerm::get_file_name()"><var>std::string</var> <strong>PlTerm::get_file_name</strong>(<var>char 
**name, int flags</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_get_file_name()</b>, ignoring <code>PL_FILE_NOERRORS</code> 
- throws <code>PlFail</code> on failure, which is interpreted by the 
enclosing <code>PREDICATE</code> as either failure or an error, 
depending on the flag bit <code>PL_FILE_NOERRORS</code>.
</dd>
<dt class="pubdef"><a id="PlTerm::get_file_nameW()"><var>std::wstring</var> <strong>PlTerm::get_file_nameW</strong>(<var>int 
flags</var>)</a></dt>
<dd class="defbody">
Same as <a class="func" href="#PlTerm::get_file_name()">PlTerm::get_file_name()</a>, 
but returns a wide-character string.</dd>
<dt class="pubdef"><a id="PlTerm::get_attr()"><var>bool</var> <strong>PlTerm::get_attr</strong>(<var>term_t 
a</var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_get_attr()</b>, throwing an exception on Prolog error.</dd>
<dt class="pubdef"><a id="PlTerm::get_atom_ex()"><var>void</var> <strong>PlTerm::get_atom_ex</strong>(<var>PlAtom 
*a</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_get_atom_ex()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_integer_ex()"><var>void</var> <strong>PlTerm::get_integer_ex</strong>(<var>int 
*i</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_get_integer_ex()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_long_ex()"><var>void</var> <strong>PlTerm::get_long_ex</strong>(<var>long 
*i</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_get_long_ex()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_int64_ex()"><var>void</var> <strong>PlTerm::get_int64_ex</strong>(<var>int64_t 
*i</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_get_int64_ex()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_uint64_ex()"><var>void</var> <strong>PlTerm::get_uint64_ex</strong>(<var>uint64_t 
*i</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_get_uint64_ex()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_intptr_ex()"><var>void</var> <strong>PlTerm::get_intptr_ex</strong>(<var>intptr_t 
*i</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_get_intptr_ex()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_size_ex()"><var>void</var> <strong>PlTerm::get_size_ex</strong>(<var>size_t 
*i</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_get_size_ex()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_bool_ex()"><var>void</var> <strong>PlTerm::get_bool_ex</strong>(<var>int 
*i</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_get_bool_ex()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_float_ex()"><var>void</var> <strong>PlTerm::get_float_ex</strong>(<var>double 
*f</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_get_float_ex()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_char_ex()"><var>void</var> <strong>PlTerm::get_char_ex</strong>(<var>int 
*p, int eof</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_get_char_ex()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_bool_ex()"><var>void</var> <strong>PlTerm::unify_bool_ex</strong>(<var>int 
val</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_bool_ex()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_pointer_ex()"><var>void</var> <strong>PlTerm::get_pointer_ex</strong>(<var>void 
**addrp</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_get_pointer_ex()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_list_ex()"><var>bool</var> <strong>PlTerm::unify_list_ex</strong>(<var>PlTerm 
h, PlTerm t</var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_unify_list_ex()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_nil_ex()"><var>void</var> <strong>PlTerm::unify_nil_ex</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_nil_ex()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_list_ex()"><var>bool</var> <strong>PlTerm::get_list_ex</strong>(<var>PlTerm 
h, PlTerm t</var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_get_list_ex()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::get_nil_ex()"><var>void</var> <strong>PlTerm::get_nil_ex</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_get_nil_ex()</b>, throwing an exception on Prolog 
error.</dd>
<dt class="pubdef"><a id="PlTerm::type()"><var>int</var> <strong>PlTerm::type</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_term_type(unwrap())</b>, returning <code>PL_VARIABLE</code>, <code>PL_ATOM</code>, 
etc, throwing an exception on Prolog error. bo</dd>
<dt class="pubdef"><a id="PlTerm::is_attvar()"><var>ol</var> <strong>PlTerm::is_attvar</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_is_attvar()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::is_variable()"><var>bool</var> <strong>PlTerm::is_variable</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_is_variable()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::is_ground()"><var>bool</var> <strong>PlTerm::is_ground</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_is_ground()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::is_atom()"><var>bool</var> <strong>PlTerm::is_atom</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_is_atom()</b>, throwing an exception on Prolog error.
</dd>
<dt class="pubdef"><a id="PlTerm::is_integer()"><var>bool</var> <strong>PlTerm::is_integer</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_is_integer()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::is_string()"><var>bool</var> <strong>PlTerm::is_string</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_is_string()</b>, throwing an exception on Prolog 
error.</dd>
<dt class="pubdef"><a id="PlTerm::is_atom_or_string()"><var>bool</var> <strong>PlTerm::is_atom_or_string</strong>(<var></var>)</a></dt>
<dd class="defbody">
<code><b>is_atom()</b></code> or <code><b>is_string()</b></code>.</dd>
<dt class="pubdef"><a id="PlTerm::is_float()"><var>bool</var> <strong>PlTerm::is_float</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_is_float()</b>, throwing an exception on Prolog error.
</dd>
<dt class="pubdef"><a id="PlTerm::is_rational()"><var>bool</var> <strong>PlTerm::is_rational</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_is_rational()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::is_compound()"><var>bool</var> <strong>PlTerm::is_compound</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_is_compound()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::is_callable()"><var>bool</var> <strong>PlTerm::is_callable</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_is_callable()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::is_list()"><var>bool</var> <strong>PlTerm::is_list</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_is_list()</b>, throwing an exception on Prolog error.
</dd>
<dt class="pubdef"><a id="PlTerm::is_dict()"><var>bool</var> <strong>PlTerm::is_dict</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_is_dict()</b>, throwing an exception on Prolog error.
</dd>
<dt class="pubdef"><a id="PlTerm::is_pair()"><var>bool</var> <strong>PlTerm::is_pair</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_is_pair()</b>, throwing an exception on Prolog error.
</dd>
<dt class="pubdef"><a id="PlTerm::is_atomic()"><var>bool</var> <strong>PlTerm::is_atomic</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_is_atomic()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::is_number()"><var>bool</var> <strong>PlTerm::is_number</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_is_number()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::is_acyclic()"><var>bool</var> <strong>PlTerm::is_acyclic</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_is_acyclic()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::is_functor()"><var>bool</var> <strong>PlTerm::is_functor</strong>(<var>PlFunctor 
f</var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_is_functor()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::is_blob()"><var>bool</var> <strong>PlTerm::is_blob</strong>(<var>PL_blob_t 
**type</var>)</a></dt>
<dd class="defbody">
Wrappper of <b>PL_is_blob()</b>, throwing an exception on Prolog error.</dd>
<dt class="pubdef"><a id="PlTerm::must_be_attvar()"><var>void</var> <strong>PlTerm::must_be_attvar</strong>(<var></var>)</a></dt>
<dd class="defbody">
Throw <code>PlTypeError</code> if <a class="func" href="#PlTerm::is_attvar()">PlTerm::is_attvar()</a> 
fails.
</dd>
<dt class="pubdef"><a id="PlTerm::must_be_variable()"><var>void</var> <strong>PlTerm::must_be_variable</strong>(<var></var>)</a></dt>
<dd class="defbody">
Throw <code>PlTypeError</code> if <a class="func" href="#PlTerm::is_variable()">PlTerm::is_variable()</a> 
fails.
</dd>
<dt class="pubdef"><a id="PlTerm::must_be_ground()"><var>void</var> <strong>PlTerm::must_be_ground</strong>(<var></var>)</a></dt>
<dd class="defbody">
Throw <code>PlTypeError</code> if <a class="func" href="#PlTerm::is_ground()">PlTerm::is_ground()</a> 
fails.
</dd>
<dt class="pubdef"><a id="PlTerm::must_be_atom()"><var>void</var> <strong>PlTerm::must_be_atom</strong>(<var></var>)</a></dt>
<dd class="defbody">
Throw <code>PlTypeError</code> if <a class="func" href="#PlTerm::is_atom()">PlTerm::is_atom()</a> 
fails.
</dd>
<dt class="pubdef"><a id="PlTerm::must_be_integer()"><var>void</var> <strong>PlTerm::must_be_integer</strong>(<var></var>)</a></dt>
<dd class="defbody">
Throw <code>PlTypeError</code> if <a class="func" href="#PlTerm::is_integer()">PlTerm::is_integer()</a> 
fails.
</dd>
<dt class="pubdef"><a id="PlTerm::must_be_string()"><var>void</var> <strong>PlTerm::must_be_string</strong>(<var></var>)</a></dt>
<dd class="defbody">
Throw <code>PlTypeError</code> if <a class="func" href="#PlTerm::is_string()">PlTerm::is_string()</a> 
fails.
</dd>
<dt class="pubdef"><a id="PlTerm::must_be_atom_or_string()"><var>void</var> <strong>PlTerm::must_be_atom_or_string</strong>(<var></var>)</a></dt>
<dd class="defbody">
Throw <code>PlTypeError</code> if <a class="func" href="#PlTerm::is_atom_or_string()">PlTerm::is_atom_or_string()</a> 
fails.
</dd>
<dt class="pubdef"><a id="PlTerm::must_be_float()"><var>void</var> <strong>PlTerm::must_be_float</strong>(<var></var>)</a></dt>
<dd class="defbody">
Throw <code>PlTypeError</code> if <a class="func" href="#PlTerm::is_float()">PlTerm::is_float()</a> 
fails.
</dd>
<dt class="pubdef"><a id="PlTerm::must_be_rational()"><var>void</var> <strong>PlTerm::must_be_rational</strong>(<var></var>)</a></dt>
<dd class="defbody">
Throw <code>PlTypeError</code> if <a class="func" href="#PlTerm::is_rational()">PlTerm::is_rational()</a> 
fails.
</dd>
<dt class="pubdef"><a id="PlTerm::must_be_compound()"><var>void</var> <strong>PlTerm::must_be_compound</strong>(<var></var>)</a></dt>
<dd class="defbody">
Throw <code>PlTypeError</code> if <a class="func" href="#PlTerm::is_compound()">PlTerm::is_compound()</a> 
fails.
</dd>
<dt class="pubdef"><a id="PlTerm::must_be_callable()"><var>void</var> <strong>PlTerm::must_be_callable</strong>(<var></var>)</a></dt>
<dd class="defbody">
Throw <code>PlTypeError</code> if <a class="func" href="#PlTerm::is_callable()">PlTerm::is_callable()</a> 
fails.
</dd>
<dt class="pubdef"><a id="PlTerm::must_be_list()"><var>void</var> <strong>PlTerm::must_be_list</strong>(<var></var>)</a></dt>
<dd class="defbody">
Throw <code>PlTypeError</code> if <a class="func" href="#PlTerm::is_list()">PlTerm::is_list()</a> 
fails.
</dd>
<dt class="pubdef"><a id="PlTerm::must_be_dict()"><var>void</var> <strong>PlTerm::must_be_dict</strong>(<var></var>)</a></dt>
<dd class="defbody">
Throw <code>PlTypeError</code> if <a class="func" href="#PlTerm::is_dict()">PlTerm::is_dict()</a> 
fails.
</dd>
<dt class="pubdef"><a id="PlTerm::must_be_pair()"><var>void</var> <strong>PlTerm::must_be_pair</strong>(<var></var>)</a></dt>
<dd class="defbody">
Throw <code>PlTypeError</code> if <a class="func" href="#PlTerm::is_pair()">PlTerm::is_pair()</a> 
fails.
</dd>
<dt class="pubdef"><a id="PlTerm::must_be_atomic()"><var>void</var> <strong>PlTerm::must_be_atomic</strong>(<var></var>)</a></dt>
<dd class="defbody">
Throw <code>PlTypeError</code> if <a class="func" href="#PlTerm::is_atomic()">PlTerm::is_atomic()</a> 
fails.
</dd>
<dt class="pubdef"><a id="PlTerm::must_be_number()"><var>void</var> <strong>PlTerm::must_be_number</strong>(<var></var>)</a></dt>
<dd class="defbody">
Throw <code>PlTypeError</code> if <a class="func" href="#PlTerm::is_number()">PlTerm::is_number()</a> 
fails.
</dd>
<dt class="pubdef"><a id="PlTerm::must_be_acyclic()"><var>void</var> <strong>PlTerm::must_be_acyclic</strong>(<var></var>)</a></dt>
<dd class="defbody">
Throw <code>PlTypeError</code> if <a class="func" href="#PlTerm::is_acyclic()">PlTerm::is_acyclic()</a> 
fails.</dd>
<dt class="pubdef"><a id="PlTerm::put_variable()"><var>void</var> <strong>PlTerm::put_variable</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_put_variable()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::put_atom()"><var>void</var> <strong>PlTerm::put_atom</strong>(<var>PlAtom 
a</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_put_atom()</b>, throwing an exception on Prolog error.
</dd>
<dt class="pubdef"><a id="PlTerm::put_bool()"><var>void</var> <strong>PlTerm::put_bool</strong>(<var>int 
val</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_put_bool()</b>, throwing an exception on Prolog error.
</dd>
<dt class="pubdef"><a id="PlTerm::put_atom_chars()"><var>void</var> <strong>PlTerm::put_atom_chars</strong>(<var>const 
char *chars</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_put_atom_chars()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::put_string_chars()"><var>void</var> <strong>PlTerm::put_string_chars</strong>(<var>const 
char *chars</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_put_string_chars()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::put_chars()"><var>void</var> <strong>PlTerm::put_chars</strong>(<var>int 
flags, size_t len, const char *chars</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_put_chars()</b>, throwing an exception on Prolog error.
</dd>
<dt class="pubdef"><a id="PlTerm::put_list_chars()"><var>void</var> <strong>PlTerm::put_list_chars</strong>(<var>const 
char *chars</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_put_list_chars()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::put_list_codes()"><var>void</var> <strong>PlTerm::put_list_codes</strong>(<var>const 
char *chars</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_put_list_codes()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::put_atom_nchars()"><var>void</var> <strong>PlTerm::put_atom_nchars</strong>(<var>size_t 
l, const char *chars</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_put_atom_nchars()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::put_string_nchars()"><var>void</var> <strong>PlTerm::put_string_nchars</strong>(<var>size_t 
len, const char *chars</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_put_string_nchars()</b>, throwing an exception on 
Prolog error.
</dd>
<dt class="pubdef"><a id="PlTerm::put_list_nchars()"><var>void</var> <strong>PlTerm::put_list_nchars</strong>(<var>size_t 
l, const char *chars</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_put_list_nchars()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::put_list_ncodes()"><var>void</var> <strong>PlTerm::put_list_ncodes</strong>(<var>size_t 
l, const char *chars</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_put_list_ncodes()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::put_integer()"><var>void</var> <strong>PlTerm::put_integer</strong>(<var>long 
i</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_put_integer()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::put_pointer()"><var>void</var> <strong>PlTerm::put_pointer</strong>(<var>void 
*ptr</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_put_pointer()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::put_float()"><var>void</var> <strong>PlTerm::put_float</strong>(<var>double 
f</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_put_float()</b>, throwing an exception on Prolog error.
</dd>
<dt class="pubdef"><a id="PlTerm::put_functor()"><var>void</var> <strong>PlTerm::put_functor</strong>(<var>PlFunctor 
functor</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_put_functor()</b>, throwing an exception on Prolog 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::put_list()"><var>void</var> <strong>PlTerm::put_list</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_put_list()</b>, throwing an exception on Prolog error.
</dd>
<dt class="pubdef"><a id="PlTerm::put_nil()"><var>void</var> <strong>PlTerm::put_nil</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_put_nil()</b>, throwing an exception on Prolog error.
</dd>
<dt class="pubdef"><a id="PlTerm::put_term()"><var>void</var> <strong>PlTerm::put_term</strong>(<var>PlTerm 
t2</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_put_term()</b>, throwing an exception on Prolog error.
</dd>
<dt class="pubdef"><a id="PlTerm::put_blob()"><var>void</var> <strong>PlTerm::put_blob</strong>(<var>void 
*blob, size_t len, PL_blob_t *type</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_put_blob()</b>, throwing an exception on Prolog error.</dd>
<dt class="pubdef"><a id="PlTerm::record()"><var>PlRecord</var> <strong>PlTerm::record</strong>(<var></var>)</a></dt>
<dd class="defbody">
Returns a <code>PlRecord</code> constructed from the term. Same as <a class="func" href="#PlRecord()">PlRecord(*this)</a>.</dd>
<dt class="pubdef"><a id="PlTerm::integer()"><var>void</var> <strong>PlTerm::integer</strong>(<var>bool 
*v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_cvt_i_bool()</b>.
</dd>
<dt class="pubdef"><a id="PlTerm::integer()"><var>void</var> <strong>PlTerm::integer</strong>(<var>char 
*v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_cvt_i_char()</b>.
</dd>
<dt class="pubdef"><a id="PlTerm::integer()"><var>void</var> <strong>PlTerm::integer</strong>(<var>int 
*v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_cvt_i_int()</b>.
</dd>
<dt class="pubdef"><a id="PlTerm::integer()"><var>void</var> <strong>PlTerm::integer</strong>(<var>long 
*v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_cvt_i_long()</b>.
</dd>
<dt class="pubdef"><a id="PlTerm::integer()"><var>void</var> <strong>PlTerm::integer</strong>(<var>long 
long *v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_cvt_i_llong()</b>.
</dd>
<dt class="pubdef"><a id="PlTerm::integer()"><var>void</var> <strong>PlTerm::integer</strong>(<var>short 
*v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_cvt_i_short()</b>.
</dd>
<dt class="pubdef"><a id="PlTerm::integer()"><var>void</var> <strong>PlTerm::integer</strong>(<var>signed 
char *v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_cvt_i_schar()</b>.
</dd>
<dt class="pubdef"><a id="PlTerm::integer()"><var>void</var> <strong>PlTerm::integer</strong>(<var>unsigned 
char *v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_cvt_i_uchar()</b>.
</dd>
<dt class="pubdef"><a id="PlTerm::integer()"><var>void</var> <strong>PlTerm::integer</strong>(<var>unsigned 
int *v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_cvt_i_uint()</b>.
</dd>
<dt class="pubdef"><a id="PlTerm::integer()"><var>void</var> <strong>PlTerm::integer</strong>(<var>unsigned 
long *v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_cvt_i_ulong()</b>.
</dd>
<dt class="pubdef"><a id="PlTerm::integer()"><var>void</var> <strong>PlTerm::integer</strong>(<var>unsigned 
long long *v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_cvt_i_ullong()</b>.
</dd>
<dt class="pubdef"><a id="PlTerm::integer()"><var>void</var> <strong>PlTerm::integer</strong>(<var>unsigned 
short *v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_cvt_i_ushort()</b>.</dd>
<dt class="pubdef"><a id="PlTerm::as_string()"><var>const std::string</var> <strong>PlTerm::as_string</strong>(<var>PlEncoding 
enc=ENC_OUTPUT</var>)</a></dt>
<dd class="defbody">
Calls <a class="func" href="#PlTerm::get_nchars()">PlTerm::get_nchars(CVT_ALL|CVT_WRITEQ|CVT_EXCEPTION)</a>. 
This method is provided mainly for debugging.
<em>The definition is subject to change in future</em> - if you want 
precise control, use <a class="func" href="#PlTerm::get_nchars()">PlTerm::get_nchars()</a>.
</dd>
<dt class="pubdef"><a id="PlTerm::as_wstring()"><var>const std::wstring</var> <strong>PlTerm::as_wstring</strong>(<var></var>)</a></dt>
<dd class="defbody">
Calls <a class="func" href="#PlTerm::get_wchars()">PlTerm::get_wchars(CVT_ALL|CVT_WRITEQ|CVT_EXCEPTION)</a>. 
This method is provided mainly for debugging.
<em>The definition is subject to change in future</em> - if you want 
precise control, use <a class="func" href="#PlTerm::get_nchars()">PlTerm::get_nchars()</a>.</dd>
<dt class="pubdef"><a id="PlTerm::as_long()"><var>long</var> <strong>PlTerm::as_long</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrapper of PL_cvt_i_*().
</dd>
<dt class="pubdef"><a id="PlTerm::as_int32_t()"><var>int32_t</var> <strong>PlTerm::as_int32_t</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrapper of PL_cvt_i_*().
</dd>
<dt class="pubdef"><a id="PlTerm::as_uint32_t()"><var>uint32_t</var> <strong>PlTerm::as_uint32_t</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrapper of PL_cvt_i_*().
</dd>
<dt class="pubdef"><a id="PlTerm::as_uint64_t()"><var>uint64_t</var> <strong>PlTerm::as_uint64_t</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrapper of PL_cvt_i_*().
</dd>
<dt class="pubdef"><a id="PlTerm::as_int64_t()"><var>int64_t</var> <strong>PlTerm::as_int64_t</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrapper of PL_cvt_i_*().
</dd>
<dt class="pubdef"><a id="PlTerm::as_size_t()"><var>size_t</var> <strong>PlTerm::as_size_t</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrapper of PL_cvt_i_*().
</dd>
<dt class="pubdef"><a id="PlTerm::as_int()"><var>int</var> <strong>PlTerm::as_int</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrapper of PL_cvt_i_*().
</dd>
<dt class="pubdef"><a id="PlTerm::as_uint()"><var>unsigned</var> <strong>PlTerm::as_uint</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrapper of PL_cvt_i_*().
</dd>
<dt class="pubdef"><a id="PlTerm::as_ulong()"><var>unsigned long</var> <strong>PlTerm::as_ulong</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrapper of PL_cvt_i_*().
</dd>
<dt class="pubdef"><a id="PlTerm::as_bool()"><var>bool</var> <strong>PlTerm::as_bool</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrapper of PL_cvt_i_*().</dd>
<dt class="pubdef"><a id="PlTerm::as_nil()"><var>void</var> <strong>PlTerm::as_nil</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_get_nil_ex()</b>, throwing an exception if the term 
isn't &ldquo;nil&rdquo; .
</dd>
<dt class="pubdef"><a id="PlTerm::as_float()"><var>double</var> <strong>PlTerm::as_float</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_get_float_ex()</b>, throwing an exception if the term 
isn't a float.
</dd>
<dt class="pubdef"><a id="PlTerm::as_double()"><var>double</var> <strong>PlTerm::as_double</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_get_float_ex()</b>, throwing an exception if the term 
isn't a float.
</dd>
<dt class="pubdef"><a id="PlTerm::as_pointer()"><var>void *</var> <strong>PlTerm::as_pointer</strong>(<var></var>)</a></dt>
<dd class="defbody">
(Deprecated: should use blob API). Wrapper of <b>PL_get_pointer_ex()</b>, 
throwing an exception if the term isn't a blob.</dd>
<dt class="pubdef"><a id="PlTerm::get_nchars()"><var>const std::string</var> <strong>PlTerm::get_nchars</strong>(<var>unsigned 
int flags</var>)</a></dt>
<dd class="defbody">
Calls <b>PL_get_nchars(..., flags)</b> and converts the result to a <code>std::string</code>. 
The flags <code>BUF_MALLOC</code>, <code>BUF_STACK</code>, and <code>BUF_ALLOW_STACK</code> 
are ignored and replaced by <code>BUF_DISCARDABLE</code>.</dd>
<dt class="pubdef"><a id="PlTerm::get_wchars()"><var>const std::wstring</var> <strong>PlTerm::get_wchars</strong>(<var>unsigned 
int flags</var>)</a></dt>
<dd class="defbody">
Calls <b>PL_get_wchars(..., flags)</b> and converts the result to a <code>std::wstring</code>. 
The flags <code>BUF_MALLOC</code>, <code>BUF_STACK</code>, and <code>BUF_ALLOW_STACK</code> 
are ignored and replaced by <code>BUF_DISCARDABLE</code>.</dd>
<dt class="pubdef"><a id="PlTerm::as_atom()"><var>PlAtom</var> <strong>PlTerm::as_atom</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_get_atom_ex()</b>, throwing an exception if the term is 
not an atom.
</dd>
<dt class="pubdef"><a id="PlTerm::eq_if_atom()"><var>bool</var> <strong>PlTerm::eq_if_atom</strong>(<var>PlAtom 
a</var>)</a></dt>
<dd class="defbody">
Returns true if the term is an atom and equal to <var>a</var>.</dd>
<dt class="pubdef"><a id="size_tindex()"><var>PlTerm::operator[]</var> <strong>size_t 
index</strong>(<var>W</var>)</a></dt>
<dd class="defbody">
rapper for <b>PL_get_arg()</b>, throwing an exception if the term isn't 
a compound or the index is out of range.
</dd>
<dt class="pubdef"><a id="PlTerm::arity()"><var>size_t</var> <strong>PlTerm::arity</strong>(<var></var>)</a></dt>
<dd class="defbody">
Gets the arity of the term; throws <code>PlTypeError</code> if not a 
"compound" or atom.
</dd>
<dt class="pubdef"><a id="PlTerm::name()"><var>PlAtom</var> <strong>PlTerm::name</strong>(<var></var>)</a></dt>
<dd class="defbody">
Gets the name of the term; <code>PlTypeError</code> if not a "compound" 
or atom.
</dd>
<dt class="pubdef"><a id="name_arity()"><var>bool</var> <strong>name_arity</strong>(<var>PlAtom 
*name, size_t *arity</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_get_name_arity()</b>; <var>name</var> and/or <var>arity</var> 
can be <code>nullptr</code>. Returns <code>false</code> if the term 
isn't a compound or atom.
</dd>
<dt class="pubdef"><a id="PlTerm::copy_term_ref()"><var>PlTerm</var> <strong>PlTerm::copy_term_ref</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_copy_term_ref()</b>. Throws an exception error (e.g., <code>PlResourceError</code>).
</dd>
<dt class="pubdef"><a id="PlTerm::free_term_ref()"><var>void</var> <strong>PlTerm::free_term_ref</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_free_term_ref()</b>. Is safe to use if the object wraps <code>PlTerm::null</code>. 
Does <em>not</em> reset the wrapped term. This is used implicitly in
<code>PlTermScoped</code>&rsquo;s destructor, which does reset the 
wrapped term.
</dd>
<dt class="pubdef"><a id="PlTerm::free_term_ref_reset()"><var>void</var> <strong>PlTerm::free_term_ref_reset</strong>(<var></var>)</a></dt>
<dd class="defbody">
Same as
<a class="func" href="#PlTerm::free_term_ref()">PlTerm::free_term_ref()</a> 
plus <b>PlTerm::reset()</b>.
<code>PlTermScoped</code>&rsquo;s destructor, which does reset the 
wrapped term.
</dd>
<dt class="pubdef"><a id="nify_term()"><var>bool</var> <strong>nify_term</strong>(<var>PlTerm 
t2</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify()</b>. Throws an exception on error and returns <code>false</code> 
if unification fails. If on failure, there isn't an immediate return to 
Prolog (e.g., by wrapping the call with
<a class="func" href="#PlCheckFail()">PlCheckFail()</a>), this method 
should be called within the context of <code>PlFrame</code>, and <a class="func" href="#PlFrame::rewind()">PlFrame::rewind()</a> 
should be called.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_atom()"><var>bool</var> <strong>PlTerm::unify_atom</strong>(<var>PlAtom 
a</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_atom()</b>, throwing an exception on error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_chars()"><var>bool</var> <strong>PlTerm::unify_chars</strong>(<var>int 
flags, size_t len, const char *s</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_chars()</b>, throwing an exception on error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_chars()"><var>bool</var> <strong>PlTerm::unify_chars</strong>(<var>int 
flags, const std::string&amp; s</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_chars()</b>, throwing an exception on error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_atom()"><var>bool</var> <strong>PlTerm::unify_atom</strong>(<var>const 
char* v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_atom_chars()</b>, throwing an exception on error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_atom()"><var>bool</var> <strong>PlTerm::unify_atom</strong>(<var>const 
wchar_t* v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_wchars()</b>, throwing an exception on error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_atom()"><var>bool</var> <strong>PlTerm::unify_atom</strong>(<var>const 
std::string&amp; v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_atom_nchars()</b>, throwing an exception on 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_atom()"><var>bool</var> <strong>PlTerm::unify_atom</strong>(<var>const 
std::wstring&amp; v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_wchars()</b>, throwing an exception on error. 
cfunctionboolPlTerm::unify_integerbool v Wrapper of <b>PL_unify_int64()</b>, 
throwing an exception on error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_integer()"><var>bool</var> <strong>PlTerm::unify_integer</strong>(<var>char 
v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_int64()</b>, throwing an exception on error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_integer()"><var>bool</var> <strong>PlTerm::unify_integer</strong>(<var>int 
v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_int64()</b>, throwing an exception on error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_integer()"><var>bool</var> <strong>PlTerm::unify_integer</strong>(<var>long 
v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_int64()</b>, throwing an exception on error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_integer()"><var>bool</var> <strong>PlTerm::unify_integer</strong>(<var>long 
long v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_int64()</b>, throwing an exception on error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_integer()"><var>bool</var> <strong>PlTerm::unify_integer</strong>(<var>short 
v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_int64()</b>, throwing an exception on error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_integer()"><var>bool</var> <strong>PlTerm::unify_integer</strong>(<var>signed 
char v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_int64()</b>, throwing an exception on error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_integer()"><var>bool</var> <strong>PlTerm::unify_integer</strong>(<var>unsigned 
char v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_uint64()</b>, throwing an exception on error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_integer()"><var>bool</var> <strong>PlTerm::unify_integer</strong>(<var>unsigned 
int v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_uint64()</b>, throwing an exception on error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_integer()"><var>bool</var> <strong>PlTerm::unify_integer</strong>(<var>unsigned 
long v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_uint64()</b>, throwing an exception on error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_integer()"><var>bool</var> <strong>PlTerm::unify_integer</strong>(<var>unsigned 
long long v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_uint64()</b>, throwing an exception on error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_integer()"><var>bool</var> <strong>PlTerm::unify_integer</strong>(<var>unsigned 
short v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_uint64()</b>, throwing an exception on error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_float()"><var>bool</var> <strong>PlTerm::unify_float</strong>(<var>double 
v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_float()</b>, throwing an exception on error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_string()"><var>bool</var> <strong>PlTerm::unify_string</strong>(<var>const 
std::string&amp; v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_string_nchars()</b>, throwing an exception on 
error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_string()"><var>bool</var> <strong>PlTerm::unify_string</strong>(<var>const 
std::wstring&amp; v</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_wchars()</b>, throwing an exception on error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_functor()"><var>bool</var> <strong>PlTerm::unify_functor</strong>(<var>PlFunctor 
f</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_functor()</b>, throwing an exception on error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_pointer()"><var>bool</var> <strong>PlTerm::unify_pointer</strong>(<var>void 
*ptr</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_pointer()</b>, throwing an exception on error. An 
alternative to this is to use a blob that wraps a pointer - see <a class="sec" href="#sec:1.6.8.7">section 
1.6.8.7</a>.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_nil()"><var>bool</var> <strong>PlTerm::unify_nil</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_nil()</b>, throwing an exception on error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_list()"><var>bool</var> <strong>PlTerm::unify_list</strong>(<var>PlTerm 
h, PlTerm t</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_list()</b>, throwing an exception on error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_bool()"><var>bool</var> <strong>PlTerm::unify_bool</strong>(<var>bool 
val</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_bool()</b>, throwing an exception on error.</dd>
<dt class="pubdef"><a id="PlTerm::unify_blob()"><var>bool</var> <strong>PlTerm::unify_blob</strong>(<var>const 
PlBlob* blob</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_blob()</b>, throwing an exception on error.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_blob()"><var>bool</var> <strong>PlTerm::unify_blob</strong>(<var>const 
void *blob, size_t len, const PL_blob_t *type</var>)</a></dt>
<dd class="defbody">
Wrapper of <b>PL_unify_blob()</b>, throwing an exception on error.</dd>
<dt class="pubdef"><a id="PlTerm::compare()"><var>int</var> <strong>PlTerm::compare</strong>(<var>PlTerm 
t2</var>)</a></dt>
<dd class="defbody">
Wrapper for <b>PL_compare()</b>, returning -1, 0, 1 for the result of 
standard order comparison of the term with <var>a2</var>.</dd>
<dt class="pubdef"><a id="operator==()"><var>bool</var> <strong>operator 
==</strong>(<var>PlTerm t2</var>)</a></dt>
<dd class="defbody">
<code>compare(t2) == 0</code>.
</dd>
<dt class="pubdef"><a id="operator!=()"><var>bool</var> <strong>operator 
!=</strong>(<var>PlTerm t2</var>)</a></dt>
<dd class="defbody">
<code>compare(t2) != 0</code>.
</dd>
<dt class="pubdef"><a id="operator<()"><var>bool</var> <strong>operator 
&lt;</strong>(<var>PlTerm t2</var>)</a></dt>
<dd class="defbody">
<code>compare(t2) &lt; 0</code>.
</dd>
<dt class="pubdef"><a id="operator>()"><var>bool</var> <strong>operator 
&gt;</strong>(<var>PlTerm t2</var>)</a></dt>
<dd class="defbody">
<code>compare(t2) &gt; 0</code>.
</dd>
<dt class="pubdef"><a id="operator<=()"><var>bool</var> <strong>operator 
&lt;=</strong>(<var>PlTerm t2</var>)</a></dt>
<dd class="defbody">
<code>compare(t2) &lt;= 0</code>.
</dd>
<dt class="pubdef"><a id="operator>=()"><var>bool</var> <strong>operator 
&gt;=</strong>(<var>PlTerm t2</var>)</a></dt>
<dd class="defbody">
<code>compare(t2) &gt;= 0</code>.</dd>
<dt class="pubdef"><a id="write()"><var>int</var> <strong>write</strong>(<var>IOSTREAM 
*s, int precedence, int flags</var>)</a></dt>
<dd class="defbody">
Wrapper for <b>PL_write_term()</b>.</dd>
<dt class="pubdef"><a id="reset_term_refs()"><var>void</var> <strong>reset_term_refs</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrapper for <b>PL_reset_term_refs()</b>.</dd>
<dt class="pubdef"><a id="call()"><var>bool</var> <strong>call</strong>(<var>PlModule 
module</var>)</a></dt>
<dd class="defbody">
Wrapper for <b>PL_call(unwrap())</b>; <var>module</var> defaults to &ldquo;null&rdquo; . 
Throws a C++ exception if there's a Prolog error, otherwise returns the 
success or failure of the call.

<p></dd>
</dl>

<p><h3 id="sec:cpp-plterm-scoped"><a id="sec:1.6.7"><span class="sec-nr">1.6.7</span> <span class="sec-title">PlTermScoped 
class (experimental)</span></a></h3>

<a id="sec:cpp-plterm-scoped"></a>

<p><em>This class is experimental and subject to change.</em>

<p>Normally all term references in a <em>scope</em> are discarded 
together or all term references created after a specific one are 
reclaimed using <b>PlTerm::reset_term_refs()</b>. A <code>PlTermScoped</code> 
object is the same as a <code>PlTerm</code> object except that
<b>PL_free_term_ref()</b> is called on its wrapped term when the object 
goes out of scope. This shrinks the current foreign frame if the term is 
the last one in the frame and otherwise it marks it for reuse.

<p>Here is an example, where <code>PlTermScoped</code> is inside a 
for-loop. If <code>PlTerm</code> were used instead, the stack would grow 
by the number of items in the array; <code>PlTermScoped</code> ensures 
that stack doesn't grow.<sup class="fn">10<span class="fn-text">Assuming 
that <b>unify_atom_list()</b> is called from a predicate implementation, 
if <code>PlTerm</code> were used instead of <code>PlTermCopy</code>, all 
the created terms would be discarded when the Prolog stack frame is 
unwound; the use of <code>PlTermScoped</code> reuses the terms in that 
stack frame.</span></sup> A slightly more effiicient way of preventing 
the Prolog stack from growing is to use <a class="func" href="#PlTerm::put_term()">PlTerm::put_term()</a> 
to reuse a term reference; but that is more difficult to understand and 
also more error-prone.

<pre class="code">
bool
unify_atom_list(const std::vector&lt;std::string&gt;&amp; array, PlTerm list)
{ PlTermScoped tail(list); // calls PL_copy_term_ref() to copy `list`
  for( auto item : array )
  { PlTermScoped head; // var term
    PlCheckFail(tail.unify_list(head, tail));
    PlCheckFail(head.unify_chars(PL_ATOM, item));
  }
  return tail.unify_nil();
}
</pre>

<p>The design of <code>PlTermScoped</code> is modeled on
<code>std::unique_ptr</code><sup class="fn">11<span class="fn-text"><code>unique_ptr</code> 
was originally called <code>scoped_ptr</code> in the Boost libraries, 
but the name was changed to contrast with <code>std::shared_ptr</code>, 
which is reference-counted.</span></sup> and uses <em>move semantics</em> 
to ensure safety.<sup class="fn">12<span class="fn-text"><em>Move 
semantics</em> are a relatively new feature in C++ and can be a bit 
difficult to understand. Roughly speaking, a <em>move</em> is a copies 
the object and then calls its destructor, so that any further use of the 
object is an error. If an object defines move methods or constructors, 
it can optimize this operation, and also can catch certain kinds of 
errors at compile time.</span></sup>

<p>A <code>PlTermScoped</code> object can be created either with or 
without a wrapped term - the <a class="func" href="#PlTermScoped::reset()">PlTermScoped::reset()</a> 
method sets (or nulls) the wrapped term. A <code>PlTermScoped</code> 
object cannot be copied or passed as a value to a function; the <a class="func" href="#PlTermScoped::release()">PlTermScoped::release()</a> 
method returns the wrapped term and resets the <code>PlTermScoped</code> 
object so that any further use of the <code>PlTermScoped</code> object 
is an error.

<p>As shown in the example above, <code>PlTermScoped</code> can be used 
instead of <code>PlTerm</code>, in places where a loop would otherwise 
cause the stack to grow. There are limitations on the operations that 
are allowed on a <code>PlTermScoped</code> object; in particular, a
<code>PlTermScoped</code> object cannot be copied and cannot be 
implicitly converted to a <code>Plterm</code>.

<p>The <code>PlTermScoped</code> constructors always create a new term 
ref, by calling either <b>PL_new_term_ref()</b> or <b>PL_copy_term_ref()</b>. 
If you try to copy or create a <code>PlTermScoped</code> object from 
another
<code>PlTermScoped</code> object, you will get a compile-time error; you 
can set the value from a <code>PlTerm</code> object, which can be 
obtained by calling <a class="func" href="#PlTermScoped::release()">PlTermScoped::release()</a>.

<p>The methods derived from the PL_put_*() and PL_cons_*() functions 
should not be used with a <code>PlTermScoped</code> object. If you need 
to use these, you can use <a class="func" href="#PlTermScoped::get()">PlTermScoped::get()</a> 
to get a <code>PlTerm</code>, for which a put_*() method can be used.

<p>To copy a <code>PlTermScoped</code> object or to pass it as a value 
in a function call, use the <a class="func" href="#PlTermScoped::release()">PlTermScoped::release()</a> 
method or <b>std::move()</b>:

<pre class="code">
  PlTermScoped ts(...);
  PlTerm t;

  // Copy to a PlTerm:
  t = ts.release(); // or: t = std::move(ts);

  // Pass as a value to a function:
  foo(ts.release()); // or: foo(std::move(ts);

  // Copy to a PlTermScoped:
  PlTermScoped ts2;
  ts2.reset(ts.release()); // or: ts2.reset(std::move(ts));
</pre>

<p>The methods are (in addition to, or overriding the methods in <code>PlTerm</code>):

<dl class="latex">
<dt><strong>PlTermScoped :: PlTermScoped</strong>(<var></var>)</dt>
<dd class="defbody">
- same as <b>PlTermScoped(PlTerm::null)</b>.
</dd>
<dt><strong>PlTermScoped :: PlTermScoped</strong>(<var>PlTerm t</var>)</dt>
<dd class="defbody">
- set the value from t.<b>copy_term_ref()</b>
</dd>
<dt><strong>PlTermScoped :: PlTermScoped</strong>(<var>term_t t</var>)</dt>
<dd class="defbody">
- same as <b>PlTermScoped(PlTerm(t))</b>.
</dd>
<dt><strong>PlTermScoped :: PlTermScoped</strong>(<var>PlTermScoped&amp;&amp; 
m</var>)</dt>
<dd class="defbody">
- create a new wrapped object from <var>m</var> and reset <var>m</var>. 
This is typically used with <b>std::move()</b>.
</dd>
<dt class="pubdef"><a id="PlTermScoped=()"><var>PlTermScoped&amp;</var> <strong>PlTermScoped::operator=</strong>(<var>PlTermScoped&amp;&amp; 
m</var>)</a></dt>
<dd class="defbody">
- copy
<var>m</var> and reset it. This is typically used with <b>std::move()</b>.
</dd>
<dt><strong>~ PlTermScoped</strong>(<var></var>)</dt>
<dd class="defbody">
- if the wrapped term not null, call <b>PL_free_term_ref()</b> on it.
</dd>
<dt><strong>PlTermScoped :: PlTermScoped</strong>(<var>PlTermScoped&amp; 
m</var>)</dt>
<dd class="defbody">
- deleted method.
</dd>
<dt class="pubdef"><a id="operator=()"><var>PlTermScoped&amp;</var> <strong>operator=</strong>(<var>PlTermScoped&amp; 
m</var>)</a></dt>
<dd class="defbody">
- deleted method.
</dd>
<dt class="pubdef"><a id="PlTermScoped::reset()"><var>void</var> <strong>PlTermScoped::reset</strong>(<var></var>)</a></dt>
<dd class="defbody">
- same as
<a class="func" href="#PlTermScoped::reset()">PlTermScoped::reset(PlTerm::null)</a>.
</dd>
<dt class="pubdef"><a id="PlTermScoped::reset()"><var>void</var> <strong>PlTermScoped::reset</strong>(<var>PlTerm 
src</var>)</a></dt>
<dd class="defbody">
- sets the wrapped term from <var>src</var>. To set the wrapped term 
from a <code>PlTermScoped</code>, use <a class="func" href="#PlTermScoped::release()">PlTermScoped::release()</a> 
to convert it to a <code>PlTerm</code>.
</dd>
<dt class="pubdef"><a id="PlTermScoped::get()"><var>PlTerm</var> <strong>PlTermScoped::get</strong>(<var></var>)</a></dt>
<dd class="defbody">
- convert the object to a <code>PlTerm</code>. This is typically used 
when calling a function that expects a <code>PlTerm</code> object and 
which will not call
<a class="func" href="#PlTerm::free_term_ref()">PlTerm::free_term_ref()</a> 
on it.
</dd>
<dt class="pubdef"><a id="PlTermScoped::release()"><var>PlTerm</var> <strong>PlTermScoped::release</strong>(<var></var>)</a></dt>
<dd class="defbody">
- typically used in the context <code>t2.reset(t.<b>release()</b>)</code> 
to copy a
<code>PlTermScoped</code>; this can also be written
<code>t2=<b>std::move(t)</b></code>.
</dd>
<dt class="pubdef"><a id="PlTermScoped::swap()"><var>void</var> <strong>PlTermScoped::swap</strong>(<var>PlTermScoped&amp; 
src</var>)</a></dt>
<dd class="defbody">
- swap two <code>PlTermScoped</code> objects&rsquo;wrapped terms.
</dd>
</dl>

<p><h3 id="sec:cpp2-blobs"><a id="sec:1.6.8"><span class="sec-nr">1.6.8</span> <span class="sec-title">Blobs</span></a></h3>

<a id="sec:cpp2-blobs"></a>

<p><em>Nomenclature warning:</em>

<p>There are two different <code><b>release()</b></code> functions: 
<ul class="latex">
<li>The <b>release()</b> callback for a blob (see the definition of <code>PL_blob_t</code>).
<li><b>std::unique_ptr::release()</b>, which passes ownership of a <code>unique_ptr</code>.
</ul>

<p><em>Disclaimer:</em>

<p>The blob API for C++ is not completely general, but is designed to 
make common use cases easy to write. For other use cases, the underlying 
C API can still be used. The use case is:

<p>
<ul class="latex">
<li>The blob is defined as a subclass of <code>PlBlob</code>, which 
provides a number of fields and methods, of which a few can be 
overridden in the blob (notably: <b>write_fields()</b>,
<b>compare_fields()</b>, <b>save()</b>, <b>load()</b>, and the 
destructor).
<li>The blob will not be subclassed.
<li>The blob contains the foreign object or a pointer to it (e.g., a 
database connection or a pointer to a database connection), plus 
optionally some other data.
<li>The blob is created by a predicate that makes the foreign object and 
stores it (or a pointer to it) within the blob - for example, making a 
connection to a database or compiling a regular expression into an 
internal form. This &ldquo;create&rdquo; predicate uses <code>std::unique_ptr</code> 
to manage the blob (that is, the blob is created using the <strong>new</strong> 
operator and is not created on the stack).
<li>Optionally, there can be a predicate that deletes the foreign 
object, such as a file or database connection close.
<li>The blob can be garbage collected, althought this might require 
calling the predicate that deletes the foreign object first. There is no 
provision for handling &ldquo;weak references&rdquo; (e.g., a separate 
lookup table or cache for the foreign objects).
<li>The blob must have a default constructor that sets all the fields to 
appropriate initial values.<sup class="fn">13<span class="fn-text">This 
is used by the <b>load()</b> callback; the default implementation for a 
C++ blob is to throw an error.</span></sup>
<li>The blob's constructor throws an exception and cleans up any 
resources if it cannot create the blob.<sup class="fn">14<span class="fn-text">This 
is not a strong requirement, but the code is simpler if this style is 
used.</span></sup>
<li>The foreign object can be deleted when the blob is deleted. That is, 
the foreign object is created using the <code>new</code> operator and 
passes ownership to the blob. More complex behavior is possible, using <b>PlAtom::register_ref()</b> 
and <b>PlAtom::unregister_ref()</b>.
<li>The blob's lifetime is controlled by Prolog and its destructor is 
invoked when the blob is garbage collected. Optionally, the predicate 
that deletes the foreign object deletes the foreign object and the 
Prolog garbage collector only frees the blob.
</ul>

<p>A Prolog blob consists of five parts:
<ul class="latex">
<li>A <code>PL_blob_t</code> structure that defines the callbacks. The <b>PL_BLOB_DEFINITION()</b> 
macro is typically used to create this, with the callbacks pointing to 
methods in the C++ blob.
<li>A structure that contains the blob data. This must have a 
constructor that references the <code>PL_blob_t</code> structure, and 
optionally a virtual destructor. The <code>PL_BLOB_SIZE</code> macro is 
used to define some required methods.
<li>A &ldquo;create&rdquo; or &ldquo;open&rdquo; predicate that unifies 
one of its arguments with a newly created blob that contains the foreign 
object. The blob is created using the <strong>new</strong> operator (not 
on the stack) and managed with <code>std::unique_ptr</code>.
<li>(Optionally) a &ldquo;close&rdquo; predicate that does the opposite 
of the &ldquo;create&rdquo; or &ldquo;open&rdquo; predicate.
<li>Predicates that manipulate the foreign object (e.g., for a file-like 
object, these could be read, write, seek, etc.).
</ul>

<p>For the <code>PL_blob_t</code> structure, the C++ API provides the
<b>PL_BLOB_DEFINITION(blob_class,blob_name)</b> macro, which references 
a set of template functions that allow easily setting up the callbacks. 
The C interface allows more flexibility by allowing some of the 
callbacks to default; however, the C++ API for blobs provides suitable 
callbacks for all of them, using the <b>PL_BLOB_DEFINITION()</b> macro.

<p>For the data, which is subclassed from <code>PlBlob</code>, the 
programmer defines the various fields, a constructor that initializes 
them, and a destructor. Optionally, override methods can be defined for 
one of more of the methods <a class="func" href="#PlBlob::compare_fields()">PlBlob::compare_fields()</a>, <a class="func" href="#PlBlob::write_fields()">PlBlob::write_fields()</a>,
<b>PlBlob::save()</b>, <b>PlBlob::load()</b>, <b>PlBlob::pre_delete()</b>. 
More details on these are given later.

<p>There is a mismatch between how Prolog does memory management (and 
garbage collection) and how C++ does it. In particular, Prolog assumes 
that cleanup will be done in the <b>release()</b> callback function 
associated with the blob whereas C++ typically does cleanup in a 
destructor. The blob interface gets around this mismatch by providing a 
default <b>release()</b> callback that assumes that the blob was created 
using <code>PL_BLOB_NOCOPY</code> and manages memory using a
<code>std::unique_ptr</code>.<sup class="fn">15<span class="fn-text">This <b>release()</b> 
function has nothing to do with <b>std::unique_ptr::release()</b>.</span></sup> 
More details on this are in
<a class="sec" href="#sec:1.6.8.1">section 1.6.8.1</a>.

<p>The C blob interface has a flag that determines how memory is 
managed:
<code>PL_BLOB_NOCOPY</code>. The <b>PL_BLOB_DEFINITION()</b> macro sets 
this, so Prolog will call the C++ destructor when the blob is garbage 
collected. (This call is done indirectly, using a callback that is 
registeered with Prolog.)

<p>The C++ API for blobs only supports blobs with
<code>PL_BLOB_NOCOPY</code>.<sup class="fn">16<span class="fn-text">The 
API can probably also support blobs with <code>PL_BLOB_UNIQUE</code>, 
but there seems to be little point in setting this flag for non-text 
blobs.</span></sup>

<p><h4 id="sec:cpp2-c++-features"><a id="sec:1.6.8.1"><span class="sec-nr">1.6.8.1</span> <span class="sec-title">A 
review of C++ features used by the API</span></a></h4>

<a id="sec:cpp2-c++-features"></a>

<p>Some slightly obscure features of C++ are used with <code>PlBlob</code> 
and
<code>ContextType</code>, and can easily cause subtle bugs or memory 
leaks if not used carefully.

<p>When a C++ object is created, its memory is allocated (either on the 
stack or on the heap using <strong>new</strong>), and the constructors 
are called in this order:
<ul class="latex">
<li>the base class's constructor (possibly specified in the 
intialization list)
<li>the constructors for all the fields (possibly specified by an 
initial value and/or being in the initialization list)
<li>the object's constructor.
</ul>
When the object is deleted (either by stack pop or the <strong>delete</strong> 
operator), the destructors are called in the reverse order.

<p>There are special forms of the constructor for copying, moving, and 
assigning. The &ldquo;copy constructor&rdquo; has a signature <code>Type(const 
Type&amp;</code> and is used when an object is created by copying, for 
example by assignment or passing the object on the stack in a function 
call. The &ldquo;move constructor&rdquo; has the signature <code>Type(Type&amp;&amp;</code> 
and is equivalent to the copy constructor for the new object followed by 
the destructor for the old object. (Assignment is usually allowed to 
default but can also be specified).

<p>Currently, the copy and move constructors are not used, so it is best 
to explicitly mark them as not existing:

<pre class="code">
Type(const Type&amp;) = delete;
Type(Type&amp;&amp;) = delete;
Type&amp; operator =(const Type&amp;) = delete;
Type&amp; operator =(Type&amp;&amp;) = delete;
</pre>

<p>A constructor may throw an exception - good programming style is to 
not leave a &ldquo;half constructed&rdquo; object but to throw an 
exception. Destructors are not allowed to throw exceptions,<sup class="fn">17<span class="fn-text">because 
the destructor might be invoked by another exception, and C++ has no 
mechanism for dealing with a second exception.</span></sup> which 
complicates the API somewhat.

<p>More details about constructors and destructors can be found in the 
FAQs for <a class="url" href="https://isocpp.org/wiki/faq/ctors">constructors</a> 
and <a class="url" href="https://isocpp.org/wiki/faq/dtors">destructors</a>.

<p>Many classes or types have a constructor that simply assigns a 
default value (e.g., 0 for <code>int</code>) and the destructor does 
nothing. In particular, the destructor for a pointer does nothing, which 
can lead to memory leaks. To avoid memory leaks, the smart pointer
<code>std::unique_ptr</code><sup class="fn">18<span class="fn-text">The 
name &ldquo;unique&rdquo; is to distinguish this from a &ldquo;shared&rdquo; pointer. 
A shared pointer can share ownership with multiple pointers and the 
pointed-to object is deleted only when all pointers to the object have 
been deleted. A unique pointer allows only a single pointer, so the 
pointed-to object is deleted when the unique pointer is deleted.</span></sup> 
can be used, whose destructor deletes its managed object. Note that <code>std::unique_ptr</code> 
does not enforce single ownership; it merely makes single ownership easy 
to manage and it detects most common mistakes, for example by not having 
copy constructor or assignment operator.

<p>For example, in the following, the implicit destructor for <code>p</code> 
does nothing, so there will be a memory leak when a <code>Ex1</code> 
object is deleted:

<pre class="code">
class Ex1 {
public:
  Ex1() : p(new int) { }
  int *p;
};
</pre>

<p>To avoid a memory leak, the code could be changed to this:

<pre class="code">
class Ex1 {
public:
  Ex1() p(new int) { }
  ~Ex1() { delete p; }
  int *p;
};
</pre>

<p>but it is easier to do the following, where the destructor for
<code>std::unique_ptr</code> will free the memory:

<pre class="code">
class Ex1 {
public:
  Ex1() p(new int) { }
  std::unique_ptr&lt;int&gt; p;
};
</pre>

<p>The same concept applies to objects that are created in code - if a 
C++ object is created using <strong>new</strong>, the programmer must 
manage when its destructor is called. In the following, if the call to
<code>data-&gt;<b>validate()</b></code> fails, there will be a memory 
leak:

<pre class="code">
MyData *foo(int some_value) {
  MyData *data = new MyData(...);
  data-&gt;some_field = some_value;
  if (! data-&gt;validate() )
    throw std::runtime_error("Failed to validate data");
  return data;
}
</pre>

<p>Ths could fixed by adding <code>delete data</code> before throwing 
the <code>runtime_error</code>; but this doesn't handle the situation of <code>data-&gt;<b>validate()</b></code> 
throwing an exception (which would require a catch/throw). Instead, it's 
easiser to use <code>std::unique_ptr</code>, which takes care of every 
return or exception path:

<pre class="code">
MyData *foo(int some_value) {
  std::unique_ptr&lt;MyData&gt; data(new MyData(...));
  data-&gt;some_field = some_value;
  if (! data-&gt;validate() )
    throw std::runtime_error("Failed to validate data");
  return data.release(); // don't delete the new MyData
}
</pre>

<p>The destructor for <code>std::unique_ptr</code> will delete the data 
when it goes out of scope (in this case, by return or throw) unless the
<b>std::unique_ptr::release()</b> method is called.<sup class="fn">19<span class="fn-text">The 
call to <code>unique_ptr&lt;<var>MYData</var>&gt;::release</code> 
doesn't call the destructor; it can be called using <b>std::unique_ptr::get_deleter()</b>.</span></sup>

<p>In the code above, the <code>throw</code> will cause the
<code>unique_ptr</code>&rsquo;s destructor to be called, which will free 
the data; but the data will not be freed in the <code>return</code> 
statement because of the <b>unique_ptr::release()</b>. Using this style, 
a pointer to data on the heap can be managed as easily as data on the 
stack. The current C++ API for blobs takes advantage of this - in 
particular, there are two methods for unifying a blob:
<ul class="latex">
<li><a class="func" href="#PlTerm::unify_blob()">PlTerm::unify_blob(const 
PlBlob* blob)</a> - does no memory management
<li><a class="func" href="#PlTerm::unify_blob()">PlTerm::unify_blob(std::unique_std&lt;<var>PlBlob</var>&gt;* 
blob)</a> - if unification fails or raises an error, the memory is 
automatically freed; otherwise the memory's ownership is transferred to 
Prolog, which may garbage collect the blob by calling the blob's 
destructor. Note that this uses a pointer to the pointer, so that
<a class="func" href="#PlTerm::unify_blob()">PlTerm::unify_blob()</a> 
can modify it.
</ul>

<p><code>unique_ptr</code> allows specifying the delete function. For 
example, the following can be used to manage memory created with <b>PL_malloc()</b>:

<pre class="code">
  std::unique_ptr&lt;void, decltype(&amp;PL_free)&gt; ptr(PL_malloc(...), &amp;PL_free);
</pre>

<p>or, when memory is allocated within a PL_*() function (in this case, 
using the Plx_*() wrapper for <b>PL_get_nchars()</b>):

<pre class="code">
  size_t len;
  char *str = nullptr;
  Plx_get_nchars(t, &amp;len, &amp;str.get(), BUF_MALLOC|CVT_ALL|CVT_WRITEQ|CVT_VARIABLE|REP_UTF8|CVT_EXCEPTION);
  std::unique_ptr&lt;char, decltype(&amp;PL_free)&gt; _str(str, &amp;PL_free);
</pre>

<p>The current C++ API assumes that the C++ blob is allocated on the 
heap. If the programmer wishes to use the stack, they can use <code>std::unique_ptr</code> 
to automatically delete the object if an error is thrown -
<a class="func" href="#PlTerm::unify_blob()">PlTerm::unify_blob(std::unique_ptr&lt;<var>PlBlob</var>&gt;*)</a> 
prevents the automatic deletion if unification succeeds.

<p>A <code>unique_ptr</code> needs a bit of care when it is passed as an 
argument. The <b>unique_ptr::get()</b> method can be used to get the &ldquo;raw&rdquo; pointer; 
the <strong>delete</strong> must not be used with this pointer. Or, the <b>unique_ptr::release()</b> 
method can be used to transfer ownership without calling the object's 
destructor.

<p>Using <b>unique_ptr::release()</b> is a bit incovenient, so instead 
the
<code>unique_ptr</code> can be passed as a pointer (or a reference). 
This does not create a new scope, so the pointer must be assigned to a 
local variable. For example, the code for <b>unify_blob()</b> is 
something like:

<pre class="code">
bool PlTerm::unify_blob(std::unique_ptr&lt;PlBlob&gt;* b) const
{ std::unique_ptr&lt;PlBlob&gt; blob(std::move(*b));
  if ( !unify_blob(blob.get()) )
    return false;
  (void)blob.release();
  return true;
}
</pre>

<p>The line declaration for <code>blob</code> uses the &ldquo;move 
constructor&rdquo; to set the value of a newly scoped variable (<code><b>std::move(*b)</b></code> 
is a cast, so <code>unique_ptr</code>&rsquo;s move constructor is used). 
This has the same effect as calling <code>b-&gt;<a class="func" href="#reset()">reset()</a></code>, 
so from this point on,
<code>b</code> has the value <code>nullptr</code>.

<p>Alternatively, the local <code>unique_ptr</code> could be set by

<pre class="code">
std::unique_ptr&lt;PlBlob&gt; blob(b-&gt;release());
</pre>

<p>or

<pre class="code">
std::unique_ptr&lt;PlBlob&gt; blob;
blob.swap(*b);
</pre>

<p>If the call to <a class="func" href="#PlTerm::unify_blob()">PlTerm::unify_blob()</a> 
fails or throws an exception, the virtual destructor for <code>blob</code> 
is called. Otherwise, the call to <code>blob.<b>release()</b></code> 
prevents the destructor from being called - Prolog now owns the blob 
object and can call its destructor when the garbage collector reclaims 
it.

<p><h4 id="sec:cpp2-blobs-howto"><a id="sec:1.6.8.2"><span class="sec-nr">1.6.8.2</span> <span class="sec-title">How 
to define a blob using C++</span></a></h4>

<a id="sec:cpp2-blobs-howto"></a>

<p>TL;DR: Use <b>PL_BLOB_DEFINITION()</b> to define the blob with the 
flag
<code>PL_BLOB_NOCOPY</code> and the default <code>PlBlob</code> 
wrappers; define your struct as a subclass of <code>PlBlob</code> with 
no copy constructor, move constructor, or assignment operator; create a 
blob using
<code>std::unique_ptr&lt;<var>PlBlob</var>&gt;(new ...)</code>, call <a class="func" href="#PlTerm::unify_blob()">PlTerm::unify_blob()</a>. 
Optionally, define one or more of: <b>compare_fields()</b>, <b>write_fields()</b>,
<b>save()</b>, <b>load()</b> methods (these are described after the 
sample code).

<p><h4 id="sec:cpp2-blobs-life"><a id="sec:1.6.8.3"><span class="sec-nr">1.6.8.3</span> <span class="sec-title">The 
life of a PlBlob</span></a></h4>

<a id="sec:cpp2-blobs-life"></a>

<p>In this section, the blob is of type <code>MyBlob</code>, a subclass 
of <code>PlBlob</code>. (Example code is given in <a class="sec" href="#sec:1.6.8.5">section 
1.6.8.5</a>) and <a class="sec" href="#sec:1.6.8.7">section 1.6.8.7</a>.

<p>A blob is typically created by calling a predicate that does the 
following:
<ul class="latex">
<li>Creates the blob using

<pre class="code">
auto ref = std::unique_ptr&lt;PlBlob&gt;(new MyBlob&gt;(...))}
      </pre>

<p>or

<pre class="code">
auto ref = std::make_unique&lt;MyBlob&gt;(...);
      </pre>

<p>
<li>After the fields of the blob are filled in:

<pre class="code">
return PlTerm::unify_blob(&amp;ref);
      </pre>

<p>If unification fails or throws an exception, the object is 
automatically freed and its destructor is called.

<p>If <b>make_unique()</b> was used to create the pointer, you need to 
call
<a class="func" href="#PlTerm::unify_blob()">PlTerm::unify_blob()</a> as 
follows, because C++'s type inferencing can't figure out that this is a 
covariant type:

<pre class="code">
std::unique_ptr&lt;PlBlob&gt; refb(ref.release());
// refb now "owns" the ptr - from here on, ref == nullptr
return A2.unify_blob(&amp;refb);
      </pre>

<p>If unification succeeds, Prolog calls:
<ul class="latex">
<li>PlBlobV&lt;<var>MyBlob</var>&gt;<b>acquire()</b>, which calls
<li><b>MyBlob::acquire()</b>, which sets the field <var>MyBlob::symbol_</var>, 
which is usually accessed using the method <b>MyBlob::symbol_term()</b>. 
If this all succeeds, <a class="func" href="#PlTerm::unify_blob()">PlTerm::unify_blob(ref)</a> 
calls
<code>ref-&gt;<b>release()</b></code> to pass ownership of the blob to 
Prolog (when the blob is eventually garbage collected, the blob's 
destructor will be called).
</ul>

<p>
</ul>

<p>At this point, the blob is owned by Prolog and may be freed by its 
atom garbage collector, which will call the blob's destructor (if the 
blob shouldn't be deleted, it can override the the <b>PlBlob::pre_delete()</b> 
method to return <code>false</code>).

<p>Whenever a predicate is called with the blob as an argument (e.g., as <var>A1</var>), 
the blob can be accessed by
<code>PlBlobv&lt;<var>MyBlob</var>&gt;::cast_check(A1.<b>as_atom()</b>)</code>.

<p>Within a method, the Prolog blob can be accessed as a term (e.g., for 
constructing an error term) using the method <b>MyBlob::symbol_term()</b>. 
This field is initialized by the call to <a class="func" href="#PlTerm::unify_blob()">PlTerm::unify_blob()</a>; 
if
<b>MyBlob::symbol_term()</b> is called before a successful call to
<a class="func" href="#PlTerm::unify_blob()">PlTerm::unify_blob()</a>, <b>MyBlob::symbol_term()</b> 
returns a
<code>PlTerm_var</code>.

<p>When the atom garbage collector runs, it frees the blob by first 
calling the <b>release()</b> callback, which does <strong>delete</strong>, 
which calls the destructor <b>MyBlob::~MyBlob()</b>. Note that C++ 
destructors are not supposed to raise exception; they also should not 
cause a Prolog error, which could cause deadlock unless the real work is 
done in another thread.

<p>Often it is desired to release the resources before the garbage 
collector runs. To do this, the programmer can provide a &ldquo;close&rdquo; predicate 
that is the inverse of the &ldquo;open&rdquo; predicate that created the 
blob. This typically has the same logic as the destructor, except that 
it can raise a Prolog error.

<p><h4 id="sec:cpp2-blobs-exceptions"><a id="sec:1.6.8.4"><span class="sec-nr">1.6.8.4</span> <span class="sec-title">C++ 
exceptions and blobs</span></a></h4>

<a id="sec:cpp2-blobs-exceptions"></a>

<p>When a blob is used in the context of a <a class="func" href="#PREDICATE()">PREDICATE()</a> 
macro, it can raise a C++ exception (<code>PlFail</code> or <code>PlException</code>) 
and the
<a class="func" href="#PREDICATE()">PREDICATE()</a> code will convert 
the exception to the appropriate Prolog failure or error; memory 
allocation exceptions are also handled.

<p>Blobs have callbacks, which can run outside the context of a
<a class="func" href="#PREDICATE()">PREDICATE()</a>. Their exception 
handling is as follows:

<dl class="latex">
<dt class="pubdef"><a id="PlBlob::acquire()"><var>void</var> <strong>PlBlob::acquire</strong>(<var></var>)</a></dt>
<dd class="defbody">
, which is called from PlBlobV&lt;<var>MyBlob</var>&gt;::<b>acquire()</b>, 
can throw a C++ exception. The programmer cannot override this.
</dd>
<dt class="pubdef"><a id="PlBlob::compare_fields()"><var>int</var> <strong>PlBlob::compare_fields</strong>(<var>const 
PlBlob *_b</var>)</a></dt>
<dd class="defbody">
, which is called from PlBlobV&lt;<var>MyBlob</var>&gt;::<b>compare()</b>, 
should not throw an exception. A Prolog error won't work as it uses &ldquo;raw 
pointers&rdquo; and thus a GC or stack shift triggered by creating the 
exception will upset the system.
</dd>
<dt class="pubdef"><a id="PlBlob::write_fields()"><var>bool</var> <strong>PlBlob::write_fields</strong>(<var>IOStream 
*s, int flags</var>)</a></dt>
<dd class="defbody">
, which is called from PlBlobV&lt;<var>MyBlob</var>&gt;::<a class="func" href="#write()">write()</a>, 
can throw an exception, just like code inside a <a class="func" href="#PREDICATE()">PREDICATE()</a>. 
In particular, you can wrap calls to <b>Sfprintf()</b> in <a class="func" href="#PlCheckFail()">PlCheckFail()</a>, 
although the calling context will check for errors on the stream, so 
checking the <b>Sfprintf()</b> result isn't necessary.
</dd>
<dt class="pubdef"><a id="PlBlob::PlBlob::save()"><var>void</var> <strong>PlBlob::PlBlob::save</strong>(<var>IOStream 
*fd</var>)</a></dt>
<dd class="defbody">
can throw a C++ exception, including <b>PlFail()</b>.
</dd>
<dt class="pubdef"><a id="PlBlob::PlBlob::load()"><var>PlAtom</var> <strong>PlBlob::PlBlob::load</strong>(<var>IOSTREAM 
*fd</var>)</a></dt>
<dd class="defbody">
can throw a C++ exception, which is converted to a return value of <code>PlAtom::null</code>, 
which is interpreted by Prolog as failure.
</dd>
<dt class="pubdef"><a id="PlBlob::PlBlob::pre_delete()"><var>bool</var> <strong>PlBlob::PlBlob::pre_delete</strong>(<var></var>)</a></dt>
<dd class="defbody">
, which is called from PlBLobV&lt;<var>MyBLOB</var>&gt;::<b>release()</b>, 
can return <code>false</code> (or throw a <code>PlException</code> or
<code>PlExceptinFailBase</code>, which will be interpreted as a return 
value of <code>false</code>), resulting in the blob not being garbage 
collected, and the destructor not being called. Note that this doesn't 
work well with final clean-up atom garbage collection, which disregards 
the return value and also doesn't respect the ordering of blob 
dependencies (e.g., if an iterator blob refers to a file-like blob, the 
file-like blob might be deleted before the iterator is deleted).

<p>This code runs in the <code>gc</code> thread. The only PL_*() 
function that can safely be called are
<b>PL_unregister_atom()</b> (which is what <b>PlAtom::unregister_ref()</b> 
calls).
</dd>
</dl>

<p><h4 id="sec:cpp2-blobs-sample-code"><a id="sec:1.6.8.5"><span class="sec-nr">1.6.8.5</span> <span class="sec-title">Sample 
PlBlob code (connection to database)</span></a></h4>

<a id="sec:cpp2-blobs-sample-code"></a>

<p>Here is minimal sample code for creating a blob that owns a 
connection to a database. It has a single field (<code>connection</code>) 
and defines <b>compare_fields()</b> and <b>write_fields()</b>.

<p>A second sample code shows how to wrap a system pointer -
<a class="sec" href="#sec:1.6.8.7">section 1.6.8.7</a>

<pre class="code">
struct MyConnection
{ std::string name;

  explicit MyConnection();
  explicit MyConnection(const std::string&amp; _name);
  bool open();
  bool close() noexcept;
  void portray(PlStream&amp; strm) const;
};

struct MyBlob;

static PL_blob_t my_blob = PL_BLOB_DEFINITION(MyBlob, "my_blob");

struct MyBlob : public PlBlob
{ std::unique_ptr&lt;MyConnection&gt; connection;

  explicit MyBlob()
    : PlBlob(&amp;my_blob) { }

  explicit MyBlob(const std::string&amp; connection_name)
    : PlBlob(&amp;my_blob),
      connection(std::make_unique&lt;MyConnection&gt;(connection_name))
  { if ( !connection-&gt;open() )
      throw MyBlobError("my_blob_open_error");
  }

  PL_BLOB_SIZE

  ~MyBlob() noexcept
  { if ( !close() )
      Sdprintf("***ERROR: Close MyBlob failed: %s\n", name().c_str()); // Can't use PL_warning()
  }

  inline std::string
  name() const
  { return connection ? connection-&gt;name : "";
  }

  bool close() noexcept
  { if ( !connection )
      return true;
    bool rc = connection-&gt;close();
    connection.reset(); // Can be omitted, leaving deletion to ~MyBlob()
    return rc;
  }

  PlException MyBlobError(const char* error) const
  { return PlGeneralError(PlCompound(error, PlTermv(symbol_term())));
  }

  int compare_fields(const PlBlob* _b_data) const override
  { auto b_data = static_cast&lt;const MyBlob*&gt;(_b_data); // See note about cast
    return name().compare(b_data-&gt;name());
  }

  bool write_fields(IOSTREAM *s, int flags) const override
  { PlStream strm(s);
    strm.printf(",");
    return write_fields_only(strm);
  }

  bool write_fields_only(PlStream&amp; strm) const
  { if ( connection )
      connection-&gt;portray(strm);
    else
      strm.printf("closed");
    return true;
  }

  bool portray(PlStream&amp; strm) const
  { strm.printf("MyBlob(");
    write_fields_only(strm);
    strm.printf(")");
    return true;
  }
};

// %! create_my_blob(+Name: atom, -MyBlob) is semidet.
PREDICATE(create_my_blob, 2)
{ // Allocating the blob uses std::unique_ptr&lt;MyBlob&gt; so that it'll be
  // deleted if an error happens - the auto-deletion is disabled by
  // ref.release() inside unify_blob() before returning success.

  auto ref = std::unique_ptr&lt;PlBlob&gt;(new MyBlob(A1.as_atom().as_string()));
  return A2.unify_blob(&amp;ref);
}

// %! close_my_blob(+MyBlob) is det.
// % Close the connection, silently succeeding if is already
// % closed; throw an exception if something goes wrong.
PREDICATE(close_my_blob, 1)
{ auto ref = PlBlobV&lt;MyBlob&gt;::cast_ex(A1, my_blob);
  if ( !ref-&gt;close() )
    throw ref-&gt;MyBlobError("my_blob_close_error");
  return true;
}

// %! portray_my_blob(+Stream, +MyBlob) is det.
// % Hook predicate for
// %   user:portray(MyBlob) :-
// %     blob(MyBlob, my_blob), !,
// %     portray_my_blob(current_output, MyBlob).
PREDICATE(portray_my_blob, 2)
{ auto ref = PlBlobV&lt;MyBlob&gt;::cast_ex(A2, my_blob);
  PlStream strm(A1, 0);
  return ref-&gt;portray(strm);
}
</pre>

<p><h4 id="sec:cpp2-blobs-sample-code-discussion"><a id="sec:1.6.8.6"><span class="sec-nr">1.6.8.6</span> <span class="sec-title">Discussion 
of the sample PlBlob code</span></a></h4>

<a id="sec:cpp2-blobs-sample-code-discussion"></a>

<p>
<ul class="latex">
<li><b>PL_BLOB_DEFINITION(MyBlob, "my_blob")</b> creates a
<code>PL_blob_t</code> structure with the wrapper functions and flags 
set to <code>PL_BLOB_NOCOPY</code>. It should be declared outside the <code>PlBlob</code> 
class and should not be marked <code>const</code> - otherwise, a runtime 
error can occur.<sup class="fn">20<span class="fn-text">The cause of the 
runtime error is not clear, but possibly has to do with the order of 
initializing globals, which is unspecified for C++.</span></sup>

<p>
<li>The <code>MyBlob</code> struct is a subclass of <code>PlBlob</code>. 
See below for a discussion of the default behaviors.

<p>
<ul class="latex">
<li><code>MyBlob</code> contains a pointer to a <code>MyConnection</code> 
object and keeps a copy of the connection's name. The <code>MyConnection</code> 
object is handled by a <code>std::unique_ptr</code> smart pointer, so 
that it is automatically freed when the <code>MyBlob</code> object is 
freed.

<p>
<li>A default constructor is defined - this is needed for the
<b>load()</b> and <b>save()</b> methods; it invokes the <code>PlBlob</code> 
constructor.

<p>
<li>The <code>MyBlob</code> class must not provide a copy or move 
constructor, nor an assignment operator (PlBlob has these as
<strong>delete</strong>, so if you try to use one of these, you will get 
a compile-time error).

<p>
<li><code>PlBlob</code>&rsquo;s constructor sets <code>blob_t_</code> to 
a pointer to the <code>my_blob</code> definition. This is used for 
run-time consistency checking by the various callback functions and for 
constructing error terms (see <b>PlBlob::symbol_term()</b>).

<p>
<li><code>PlBlob</code>&rsquo;s <b>acquire()</b> is called by PlBlobV&lt;<var>MyBlob</var>&gt;::<b>acquire()</b> 
and fills in the <code>symbol_</code> field. <code>MyBlob</code> must 
not override this - it is not a virtual method. The <code>symbol_</code> 
field can be accessed by <b>PlBlob::symbol_term()</b>.

<p>
<li><b>PlBlob::symbol_term()</b> Creates a term from the blob, for use 
in error terms. It is always safe to use this; if the symbol hasn't been 
set (because <b>acquire()</b> hasn't been called),
<b>symbol_term()</b> returns a &ldquo;var&rdquo; term - this can be 
checked with <a class="func" href="#PlTerm::is_variable()">PlTerm::is_variable()</a>.

<p>
<li>The MyBlob(connection_name) constructor creates a
<code>MyConnection</code> object. If this fails, an exception is thrown. 
The constructor then calls <b>MyConnection::open()</b> and throws an 
exception if that fails. (The code would be similar if instead the 
constructor for <code>MyConnection</code> also did an open and threw an 
exception on failure.)

<p>
<li>The <code>PL_BLOB_SIZE</code> is boilerplate that defines a
<b>blob_size_()</b> method that is used when the blob is created.

<p>
<li>The destructor&nbsp;<b>MyBlob()</b> is called when the blob is 
released by the garbage collector and in turn calls the <b>MyBlob::close()</b>, 
throwing away the result. If there is an error, a message is printed 
because there is no other way report the error. For this reason, it is 
preferred that the program explicitly calls the
<a id="idx:closemyblob1:23"></a><span class="pred-ext">close_my_blob/1</span> 
predicate, which can raise an error. One way of doing this is by using 
the <a id="idx:athalt1:24"></a><span class="pred-ext">at_halt/1</span> 
hook.

<p>
<li>The <b>MyBlob::close()</b> method is called by either the destructor 
or by the <a id="idx:closemyblob1:25"></a><span class="pred-ext">close_my_blob/1</span> 
predicate. Because it can be called by the garbage collector, which does 
not provide the usual environment and which may also be in a different 
thread, the only Prolog function that can be called is
<b>PlAtom::unregister_ref()</b>; and the <b>MyBlob::close()</b> method 
must not throw an exception.<sup class="fn">21<span class="fn-text">It 
isn't enough to just catch exceptions; for example, if the code throws <code><b>PlUnknownError("...")</b></code>, 
that will try to create a Prolog term, which will crash because the 
environment for creating terms is not available.</span></sup> Because 
there is no mechanism for reporting an error, the destructor prints a 
message on failure (calling
<b>PL_warning()</b> would cause a crash).

<p><b>PlBlob::close()</b> calls <b>MyConnection::close()</b> and then 
frees the object. Error handling is left to the caller because of the 
possibility that this is called in the context of garbage collection. It 
is not necessary to free the <code>MyConnection</code> object here - if 
it is not freed, the
<code>std::unique_ptr&lt;<var>MyConnection</var>&gt;</code>&rsquo;s 
destructor would free it.

<p>
<li><b>PlBlob::MyBlobError()</b> is a convenience method for creating 
errror terms.

<p>
<li><a class="func" href="#PlBlob::compare_fields()">PlBlob::compare_fields()</a> 
makes the blob comparison function more deterministic by comparing the 
name fields; if the names are the same, the comparison will be done by 
comparing the addresses of the blobs (which is the default behavior for 
blobs defined using the C API).
<a class="func" href="#PlBlob::compare_fields()">PlBlob::compare_fields()</a> 
is called by PlBlobV&lt;<var>PlBlob</var>&gt;::<b>compare()</b>, which 
provides the default comparison if <a class="func" href="#PlBlob::compare_fields()">PlBlob::compare_fields()</a> 
returns <code>0</code> (``equal&rdquo; ).

<p>The <var>_b_data</var> argument is of type <code>const PlBlob*</code> 
- this is cast to <code>const MyBlob*</code> using a
<code>static_cast</code>. This is safe because Prolog guarantees that 
PlBlobV&lt;<var>PlBlob</var>&gt;::<b>compare()</b> will only be called 
if both blobs are of the same type.

<p>
<li><a class="func" href="#PlBlob::write_fields()">PlBlob::write_fields()</a> 
outputs the name and the status of the connection, in addition to the 
default of outputting the blob type and its address. This is for 
illustrative purposes only; an alternative is to have a <a id="idx:myblobproperties2:26"></a><span class="pred-ext">my_blob_properties/2</span> 
predicate to provide the information.

<p>The <var>flags</var> argument is the same as given to PlBlobV&lt;<var>PlBlob</var>&gt;::<a class="func" href="#write()">write()</a>, 
which is a bitwise <em>or</em> of zero or more of the <code>PL_WRT_*</code> 
flags that were passed in to the caling <b>PL_write_term()</b> (defined 
in <code>SWI-Prolog.h</code>). The
<var>flags</var> do not have the <code>PL_WRT_NEWLINE</code> bit set, so 
it is safe to call <b>PlTerm::write()</b> and there is no need for 
writing a trailing newline.

<p>If anything in <a class="func" href="#PlBlob::write_fields()">PlBlob::write_fields()</a> 
throws a C++ exception, it will be caught by the calling PlBlobV&lt;<var>PlBlob</var>&gt;::<a class="func" href="#write()">write()</a> 
and handled appropriately.

<p>
<li><b>PlBlob::save()</b> and <b>PlBlob::load()</b> are not defined, so 
the defaults are used - they throw an error on an attempt to save the 
blob (e.g., by using <a id="idx:qsaveprogram12:27"></a><span class="pred-ext">qsave_program/[1,2]</span>).<sup class="fn">22<span class="fn-text">The 
C API defaults would save the internal form of the blob, which is 
probably not what you want, so the C++ API throws an error as its 
default.</span></sup>

<p>
</ul>

<p>
<li><a id="idx:createmyblob2:28"></a><span class="pred-ext">create_my_blob/2</span> 
predicate:

<p>
<ul class="latex">
<li><code>std::unique_ptr&lt;<var>PlBlob</var>&gt;()</code> creates a 
MyBlob that is deleted when it goes out of scope. If an exception occurs 
between the creation of the blob or if the call to <b>unify_blob()</b> 
fails, the pointer will be automatically freed (and the
<code>MyBlob</code> destructor will be called).

<p><a class="func" href="#PlTerm::unify_blob()">PlTerm::unify_blob()</a> 
is called with a pointer to a
<code>std::unique_ptr</code>, which takes ownership of the object by 
calling std::unique_ptr&lt;<var>PlBlob</var>&gt;::<b>release()</b> and 
passes the pointer to Prolog, which then owns it. This also sets <var>ref</var> 
to <code>nullptr</code>, so any attempt to use <var>ref</var> after a 
call to <a class="func" href="#PlTerm::unify_blob()">PlTerm::unify_blob()</a> 
will be an error.

<p>If you wish to create a <code>MyBlob</code> object instead of a
<code>PlBlob</code> object, a slightly different form is used:

<pre class="code">
auto ref = std::make_unique&lt;MyBlob&gt;(...);
  ...
std::unique_ptr&lt;PlBlob&gt; refb(ref.release());
PlCheckFail(A2.unify_blob(&amp;refb));
return true;
      </pre>

<p>
</ul>

<p>
<li><a id="idx:closemyblob1:29"></a><span class="pred-ext">close_my_blob/1</span> 
predicate:

<p>
<ul class="latex">
<li>The argument is turned into a <code>MyBlob</code> pointer using the 
PlBlobV&lt;<var>MyBlob</var>&gt;::<b>cast_ex()</b> function, which will 
throw a
<code>type_error</code> if the argument isn't a blob of the expected 
type.

<p>
<li>The <b>MyBlob::close()</b> method is called - if it fails, a Prolog 
error is thrown.

<p>
</ul>

<p>
</ul>

<p><h4 id="sec:cpp2-blobs-sample-code-pointer"><a id="sec:1.6.8.7"><span class="sec-nr">1.6.8.7</span> <span class="sec-title">Sample 
PlBlob code (wrapping a pointer)</span></a></h4>

<a id="sec:cpp2-blobs-sample-code-pointer"></a>

<pre class="code">
struct MyFileBlob;

static PL_blob_t my_file_blob = PL_BLOB_DEFINITION(MyFileBlob, "my_file_blob");

static const PlOptionsFlag&lt;int&gt;
MyFileBlob_options("MyFileBlob-options",
                   { {"absolute", PL_FILE_ABSOLUTE},
                     {"ospath",   PL_FILE_OSPATH},
                     {"search",   PL_FILE_SEARCH},
                     {"exist",    PL_FILE_EXIST},
                     {"read",     PL_FILE_READ},
                     {"write",    PL_FILE_WRITE},
                     {"execute",  PL_FILE_EXECUTE},
                     {"noerrors", PL_FILE_NOERRORS} });

struct MyFileBlob : public PlBlob
{ std::FILE* file_;

  std::string mode_;
  int flags_;
  std::string filename_;
  std::vector&lt;char&gt; buffer_; // used by read(), to avoid re-allocation

  explicit MyFileBlob()
    : PlBlob(&amp;my_file_blob) { }

  explicit MyFileBlob(PlTerm filename, PlTerm mode, PlTerm flags)
    : PlBlob(&amp;my_file_blob),
      mode_(mode.as_string())
  { flags_ = MyFileBlob_options.lookup_list(flags);
    filename_ = filename.get_file_name(flags_);
    file_ = fopen(filename_.c_str(), mode_.c_str());
    if ( !file_ ) // TODO: get error code (might not be existence error)
      throw PlExistenceError("my_file_blob_open", PlTerm_string(filename_));
    // for debugging:
    //   PlTerm_string(filename.as_string() + "\" =&gt; \"" +
    //                 filename_ + "\", \"" + mode_ +
    //                 ", flags=" + MyFileBlob_options.as_string(flags_) + "\")")
  }

  PL_BLOB_SIZE

  std::string read(size_t count)
  { assert(sizeof buffer_[0] == sizeof (char));
    assert(sizeof (char) == 1);

    buffer_.reserve(count);
    return std::string(buffer_.data(),
                       std::fread(buffer_.data(), sizeof buffer_[0], count, file_));
  }

  bool eof() const
  { return std::feof(file_);
  }

  bool error() const
  { return std::ferror(file_);
  }

  virtual ~MyFileBlob() noexcept
  { if ( !close() )
      // Can't use PL_warning()
      Sdprintf("***ERROR: Close MyFileBlob failed: (%s)\n", filename_.c_str());
  }

  bool close() noexcept
  { if ( !file_ )
      return true;
    int rc = std::fclose(file_);
    file_ = nullptr;
    return rc == 0;
  }

  PlException MyFileBlobError(const std::string error) const
  { return PlGeneralError(PlCompound(error, PlTermv(symbol_term())));
  }

  int compare_fields(const PlBlob* _b_data) const override
  { // dynamic_cast is safer than static_cast, but slower (see documentation)
    // It's used here for testing (the documentation has static_cast)
    auto b_data = dynamic_cast&lt;const MyFileBlob*&gt;(_b_data);
    return filename_.compare(b_data-&gt;filename_);
  }

  bool write_fields(IOSTREAM *s, int flags) const override
  { PlStream strm(s);
    strm.printf(",");
    return write_fields_only(strm);
  }

  bool write_fields_only(PlStream&amp; strm) const
  { // For debugging:
    // strm.printf("%s mode=%s flags=%s", filename_.c_str(), mode_.c_str(),
    //             MyFileBlob_options.as_string(flags_).c_str());
    strm.printf("%s", filename_.c_str());
    if ( !file_ )
      strm.printf("-CLOSED");
    return true;
  }

  bool portray(PlStream&amp; strm) const
  { strm.printf("MyFileBlob(");
    write_fields_only(strm);
    strm.printf(")");
    return true;
  }
};

PREDICATE(my_file_open, 4)
{ auto ref = std::unique_ptr&lt;PlBlob&gt;(new MyFileBlob(A2, A3, A4));
  return A1.unify_blob(&amp;ref);
}

PREDICATE(my_file_close, 1)
{ auto ref = PlBlobV&lt;MyFileBlob&gt;::cast_ex(A1, my_file_blob);
  if ( !ref-&gt;close() ) // TODO: get the error code
    throw ref-&gt;MyFileBlobError("my_file_blob_close_error");
  return true;
}
</pre>

<p><h4 id="sec:cpp2-blobs-sample-code-pointer-discussion"><a id="sec:1.6.8.8"><span class="sec-nr">1.6.8.8</span> <span class="sec-title">Discussion 
of the sample PlBlob code (wrapping a pointer)</span></a></h4>

<a id="sec:cpp2-blobs-sample-code-pointer-discussion"></a>

<p>
<ul class="latex">
<li>This code provides a simple wrapper for some of the C &ldquo;stdio&rdquo; functions 
defined in <code>&lt;<var>cstdio</var>&gt;</code>. The blob wraps the 
file pointer returned from <b>fopen()</b> and also keeps a few other 
values for debugging (the mode, flags, filename from the call to <b>fopen()</b>) 
plus a buffer for read operations.

<p>
<li>A utility class&lsquo;PlOptionsFlag` is defined in fileSWI-cpp2-flags.h, 
for mapping a list of atoms to a bit-field flag. For example, the list <code>[search,read]</code> 
would map to&lsquo;examPL_FILE_SEARCH|PL_FILE_READ&lsquo;.

<p>
<li>The <code>MyFileBlob</code> struct defines the blob that wraps a
<code>FILE*</code>. The constructor (which is called by predicate
<a id="idx:myfileopen4:30"></a><span class="pred-ext">my_file_open/4</span>) 
converts the <var>flags</var> term (a list of atoms or strings) to a 
flag that is passed to <b>PL_get_file_name()</b>, to convert the <var>filename</var> 
to a string containing the abslute file name. This is then passed to <b>fopen()</b>, 
together with the
<var>mode</var>. If the call to <b>fopen()</b> fails, a C++ exception is 
thrown, to be handled by Prolog. Other errors, such as a wrong argument 
type to <b>PL_get_file_name()</b> can also cause an exception.

<p>
<li><b>MyFileBlob::read()</b> ensures that the buffer is big enough and 
then calls&lsquo;<b>fread()</b>&lsquo;to return the buffer's contents.

<p>
<li><b>MyFileBlob::eof()</b> and <b>MyFileBlob::error()</b> call <b>feof()</b> 
and <b>ferror()</b> respectively. They can be used to check the status 
of the call to <b>MyFileBlob::read()</b>.

<p>
<li>The destructor calls <b>MyFileBlob::close()</b> and outputs a 
warning if it fails - a destructor is not allowed to throw a C++ 
exception, so this is the best we can do; it's better if the programmer 
explicitly closes the file rather than depending on the garbage 
collector to free the blob.

<p>
<li><b>MyFileBlob::close()</b> calls <b>fclose()</b>. It then sets the <code>FILE*</code> 
to null, so that close won't be done twice.

<p>
<li><b>MyFileBlob::compare_fields()</b>, <b>MyFileBlob::write_fields()</b>,
<b>MyFileBlob::write_fields_only()</b>, <b>MyFileBlob::portray()</b> are 
similar to the same methods in <code>MyBlob</code> in <a class="sec" href="#sec:1.6.8.5">section 
1.6.8.5</a>.

<p>
<li>Predicate my_file_open(File,Filename,Mode,Flags) calls the
<code>MyFileBlob</code> constructor with <var>Filename</var>, <var>Mode</var>,
<var>flags</var> and unifies the blob with <var>File</var>.

<p>
<li>Predicate <a id="idx:myfileclose1:31"></a><span class="pred-ext">my_file_close/1</span> 
calls <b>MyFileBlob::close()</b>, checks for an error and creates a 
Prolog error if the close failed.

<p>
</ul>

<p><h4 id="sec:cpp2-atom-blob"><a id="sec:1.6.8.9"><span class="sec-nr">1.6.8.9</span> <span class="sec-title">Identifying 
blobs by atoms</span></a></h4>

<a id="sec:cpp2-atom-blob"></a>

<p>Passing a Prolog blob around can be inconvenient; it is easier if a 
blob can be identified an atom. An example of this is with streams, 
which are identified by atoms such as <code>user_input</code>.

<p>A utility class <code>AtomMap</code> is provided for this situation. 
See <a class="sec" href="#sec:1.17.4">section 1.17.4</a>.

<p><h3 id="sec:cpp2-limitations"><a id="sec:1.6.9"><span class="sec-nr">1.6.9</span> <span class="sec-title">Limitations 
of the interface</span></a></h3>

<a id="sec:cpp2-limitations"></a>

<p>The C++ API remains a work in progress.

<p><h4 id="sec:cpp2-strings"><a id="sec:1.6.9.1"><span class="sec-nr">1.6.9.1</span> <span class="sec-title">Strings</span></a></h4>

<a id="sec:cpp2-strings"></a>

<p>SWI-Prolog string handling has evolved over time. The functions that 
create atoms or strings using <code>char*</code> or <code>wchar_t*</code> 
are &ldquo;old school&rdquo; ; similarly with functions that get the 
string as
<code>char*</code> or <code>wchar_t*</code>. The PL_get,unify,put_[nw]<b>chars()</b> 
family is more friendly when it comes to different input, output, 
encoding and exception handling.

<p>Roughly, the modern API is <b>PL_get_nchars()</b>, <b>PL_unify_chars()</b> 
and
<b>PL_put_chars()</b> on terms. There is only half of the API for atoms 
as
<b>PL_new_atom_mbchars()</b> and PL-<b>atom_mbchars()</b>, which take an 
encoding, length and char*.

<p>For return values, <code>char*</code> is dangerous because it can 
point to local or stack memory. For this reason, wherever possible, the 
C++ API returns a <code>std::string</code>, which contains a copy of the 
string. This can be slightly less efficient that returning a
<code>char*</code>, but it avoids some subtle and pervasive bugs that 
even address sanitizers can't detect.<sup class="fn">23<span class="fn-text">If 
we wish to minimize the overhead of passing strings, this can be done by 
passing in a pointer to a string rather than returning a string value; 
but this is more cumbersome and modern compilers can often optimize the 
code to avoid copying the return value.</span></sup>

<p>Some functions require allocating string space using <b>PL_STRINGS_MARK()</b>. 
The <code>PlStringBuffers</code> class provides a <em>RAII</em> wrapper 
that ensures the matching <b>PL_STRINGS_RELEASE()</b> is done. The <code>PlAtom</code> 
or <code>PlTerm</code> member functions that need the string buffer use <code>PlStringBuffers</code>, 
and then copy the resulting string to a <code>std::string</code> value.

<p>The C++ API has functions such as <a class="func" href="#PlTerm::get_nchars()">PlTerm::get_nchars()</a> 
that use
<code>PlStringBuffers</code> and then copy the result to a
<code>std::string</code> result, so the programmer often doesn't need to 
use <code>PlStringBuffers</code>.

<dl class="latex">
<dt><a id="class:PlStringBuffers"><strong>PlStringBuffers</strong></a></dt>
<dd class="defbody">
A <em>RAII</em> wrapper for allocating a string that is created using
<code>BUF_STACK</code>. This isn't needed if you use a method such as
<a class="func" href="#PlTerm::as_string()">PlTerm::as_string()</a>, but 
is needed for calling certain PL_*() or Plx_*() wrapped functions.

<p>The constructor calls <b>PL_STRINGS_MARK()</b> and the destructor 
calls <b>PL_STRINGS_RELEASE()</b>. Here is an example of its use, for 
writing an atom to a stream, using <b>Plx_atom_wchars()</b>, which must 
be called within a strings buffer:

<pre class="code">
PREDICATE(w_atom_cpp, 2)
{ auto stream(A1), term(A2);
  PlStream strm(stream, STIO_OUTPUT);
  PlStringBuffers _string_buffers;
  const pl_wchar_t *sa = Plx_atom_wchars(term.as_atom().unwrap(), nullptr);
  strm.printfX("/%Ws/", sa);
  return true;
}
</pre>

<p></dd>
</dl>

<p><h4 id="sec:cpp2-stream-io"><a id="sec:1.6.9.2"><span class="sec-nr">1.6.9.2</span> <span class="sec-title">Stream 
I/O</span></a></h4>

<a id="sec:cpp2-stream-io"></a>

<p><code>PlStream</code> can be used to get a stream from a Prolog term, 
or to lock the stream so that other threads cannot interleave their 
output. With either usage, <code>PlStream</code> is a <em>RAII</em> 
class that ensure the matchin <b>PL_release_stream()</b> is done, and 
also handles some subtle problems with C++ exceptions.

<p>The methods are:

<dl class="latex">
<dt><strong>PlStream :: PlStream</strong>(<var>term_t t, int flags</var>)</dt>
<dd class="defbody">
- see
<b>PL_get_stream()</b> for documentation of the flags. Throws a C++ 
exception on error.
</dd>
<dt><strong>PlStream :: PlStream</strong>(<var>IOSTREAM *s</var>)</dt>
<dd class="defbody">
- calls
<b>PL_acquire_stream()</b> to lock the stream. Throws a C++ exception on 
error.
</dd>
<dt><strong>~ PlStream</strong>(<var></var>)</dt>
<dd class="defbody">
- calls <a class="func" href="#PlStream::release()">PlStream::release()</a>. 
See below for caveats if there are exceptions.
</dd>
<dt class="pubdef"><a id="PlStream::release()"><var>void</var> <strong>PlStream::release</strong>(<var></var>)</a></dt>
<dd class="defbody">
calls <b>PL_release_stream()</b>, throwing an exception if there has 
been an I/O error on the stream, and sets the <code>PlStream</code> 
object to an invalid stream (see <b>PlStream::check_stream()</b>).
</dd>
<dt><strong>IOSTREAM* ::operator PlStream</strong>(<var>void</var>)</dt>
<dd class="defbody">
- when used in a context that requires an <code>IOSTREAM*</code>, <code>PlStream</code> 
is implicitly converted to <code>IOSTREAM*</code>.
</dd>
<dt class="pubdef"><a id="check_stream()"><var>void</var> <strong>check_stream</strong>(<var></var>)</a></dt>
<dd class="defbody">
checks that the
<code>PlStream</code> object contains a valid stream and throws an 
exception if it doesn't. This is used to ensure that <a class="func" href="#PlStream::release()">PlStream::release()</a> 
hasn't been called.
</dd>
</dl>

<p>Most of the stream I/O functions have corresponding methods in <code>PlStream</code>. 
For example, <b>Sfprintf()</b> corresponds to
<b>PlStream::printf()</b>. <b>PlStream::seek()</b> and <b>PlStream::tell()</b> 
call
<b>Sseek64()</b> and <b>Stell64()</b> instead of <code>long</code> (they 
are also deprecated: <b>PlStream::seek64()</b> and <b>PlStream::tell64()</b> 
are preferred).

<p>The C interface to stream I/O doesn't raise a Prolog error when 
there's a stream error (typically indicated by a -1 return code). 
Instead, the error sets a flag on the stream and
<b>PL_release_stream()</b> creates the error term. The
<code>PlStream</code> destructor calls <b>PL_release_stream()</b>; but 
it's a fatal error in C++ to raise an exception in a destructor if the 
destructor is invoked by stack-unwinding due to another exception, 
including the pseudo-exceptions <code>PlFail</code> and
<code>PlExceptionFail</code>.

<p>To get around this, the various stream I/O functions have wrapper 
methods in the <code>PlStream</code> class that check for an error and 
call <a class="func" href="#PlStream::release()">PlStream::release()</a> 
to create the Prolog error, which is thrown as a C++ error.

<p>The destructor calls <a class="func" href="#PlStream::release()">PlStream::release()</a>, 
which throws a C++ exception if there is a stream error. This is outside 
the destructor, so it is safe - the destructor checks if the stream has 
been released and does nothing in that situation.

<p>The following two code examples do essentially the same thing:

<pre class="code">
PREDICATE(name_arity, 1)
{ PlStream strm(Scurrent_output);
  strm.printf("name = %s, arity = %zd\n", A1.name().as_string().c_str(), A1.arity());
  return true;
}
</pre>

<pre class="code">
PREDICATE(name_arity, 1)
{ PlStream strm(Scurrent_output);
  try
  { strm.printf("name = %s, arity = %zd\n", A1.name().as_string().c_str(), A1.arity());
  } PREDICATE_CATCH({strm.release(); return false;})
  return true;
}
</pre>

<p>If you write the code as follows, using <b>Sfprintf()</b> directly, 
it is possible that a fatal exception will be raised on an I/O error:

<pre class="code">
PREDICATE(name_arity, 1)
{ PlStream strm(Scurrent_output);
  Sfprintf(strm, "name = %s, arity = %zd\n", A1.name().as_string().c_str(), A1.arity());
  return true;
  // WARNING: the PlStream destructor might throw a C++
  //          exception on stack unwinding, giving a fatal
  //          fatal runtime exception.
}
</pre>

<p>If you don't use these, and want to throw an exception if there's an 
error, the following code works because <code>PlStream</code> (and the 
underlying <b>PL_acquire_stream()</b>) can be called recursively:

<pre class="code">
{ PlStream strm(...);
  strm.release();
}
</pre>

<p><h4 id="sec:cpp2-limitations-handles"><a id="sec:1.6.9.3"><span class="sec-nr">1.6.9.3</span> <span class="sec-title">Object 
handles</span></a></h4>

<a id="sec:cpp2-limitations-handles"></a>

<p>Many of the &ldquo;opaque object handles&rdquo; , such as <code>atom_t</code>,
<code>term_t</code>, and <code>functor_t</code> are integers.<sup class="fn">24<span class="fn-text">Typically <code>uintptr_t</code> 
values, which the C standard defines as &ldquo;an unsigned integer type 
with the property that any valid pointer to void can be converted to 
this type, then converted back to pointer to void, and the result will 
compare equal to the original pointer.&rsquo;</span></sup> As such, 
there is no compile-time detection of passing the wrong handle to a 
function.

<p>This leads to a problem with classes such as <code>PlTerm</code> - 
C++ overloading cannot be used to distinguish, for example, creating a 
term from an atom versus creating a term from an integer. There are a 
number of possible solutions, including:
<ul class="latex">
<li>A subclass for each kind of initializer;
<li>A tag for each kind of intializer;
<li>Change the C code to use a <code>struct</code> instead of an 
integer.
</ul>

<p>It is impractical to change the C code, both because of the amount of 
edits that would be required and also because of the possibility that 
the changes would inhibit some optimizations.

<p>There isn't much difference between subclasses versus tags; but as a 
matter of design, it's better to specify things as constants than as 
(theoretically) variables, so the decision was to use subclasses.

<p><h3 id="sec:cpp2-plld"><a id="sec:1.6.10"><span class="sec-nr">1.6.10</span> <span class="sec-title">Linking 
embedded applications using swipl-ld</span></a></h3>

<a id="sec:cpp2-plld"></a>

<p>The utility program <b>swipl-ld</b> (Win32: swipl-ld.exe) works with 
both C and C++ programs. See
<a class="url" href="https://www.swi-prolog.org/pldoc/man?section=plld">Linking 
embedded applications using swipl-ld</a> for more details.

<p>Your C++ compiler should support at least C++-17.

<p>To avoid incompatibilities amongst the various C++ compilers&rsquo;ABIs, 
the object file from compiling <code>SWI-cpp2.cpp</code> is not included 
in the shared object <code>libswipl</code>; instead, it must be compiled 
along with any foreign predicate files. If the macro
<code>_SWI_CPP2_CPP_SEPARATE</code> is defined before the include for
<code>SWI-cpp2.h</code>, then <code>SWI-cpp2.cpp</code> is not 
automatically included and must be compiled separately - either by 
creating a
<code>.a</code> file or by adding a <code>#include &lt;SWI-cpp2.cpp&gt;</code> 
to one of your source files.

<p><h2 id="sec:cpp2-examples"><a id="sec:1.7"><span class="sec-nr">1.7</span> <span class="sec-title">Examples</span></a></h2>

<a id="sec:cpp2-examples"></a>

<p>Before going into a detailed description of the C++ classes we 
present a few examples illustrating the &ldquo;feel&rdquo; of the 
interface.

<p><h3 id="sec:cpp2-hello-world"><a id="sec:1.7.1"><span class="sec-nr">1.7.1</span> <span class="sec-title">Hello(World)</span></a></h3>

<a id="sec:cpp2-hello-world"></a>

<p>This simple example shows the basic definition of the predicate <a id="idx:hello1:32"></a><span class="pred-ext">hello/1</span> 
and how a Prolog argument is converted to C-data:

<pre class="code">
PREDICATE(hello, 1)
{ cout &lt;&lt; "Hello " &lt;&lt; A1.as_string() &lt;&lt; endl;
  return true;
}
</pre>

<p>The arguments to <a class="func" href="#PREDICATE()">PREDICATE()</a> 
are the name and arity of the predicate. The macros A&lt;<var>n</var>&gt; 
provide access to the predicate arguments by position and are of the 
type <code>PlTerm</code>. The C or C++ string for a <code>PlTerm</code> 
can be extracted using <a class="func" href="#as_string()">as_string()</a>, 
or <a class="func" href="#as_wstring()">as_wstring()</a> methods;<sup class="fn">25<span class="fn-text">The 
C-string values can be extracted from <code>std::string</code> by using <b>c_str()</b>, 
but you must be careful to not return a pointer to a local/stack value, 
so this isn't recommende.</span></sup> and similar access methods 
provide an easy type-conversion for most Prolog data-types, using the 
output of <a id="idx:write1:33"></a><span class="pred-ext">write/1</span> 
otherwise:

<pre class="code">
?- hello(world).
Hello world

Yes
?- hello(X)
Hello _G170

X = _G170
</pre>

<p><h3 id="sec:cpp2-ex-adding-numbers"><a id="sec:1.7.2"><span class="sec-nr">1.7.2</span> <span class="sec-title">Adding 
numbers</span></a></h3>

<a id="sec:cpp2-ex-adding-numbers"></a>

<p>This example shows arithmetic using the C++ interface, including 
unification, type-checking, and conversion. The predicate <a id="idx:add3:34"></a><span class="pred-ext">add/3</span> 
adds the two first arguments and unifies the last with the result.

<pre class="code">
PREDICATE(add, 3)
{ return A3.unify_integer(A1.as_long() + A2.as_long());
}
</pre>

<p>You can use your own variable names instead of <code>A1</code>,
<code>A2</code>, etc.:

<pre class="code">
PREDICATE(add, 3)  // add(+X, +Y, +Result)
{ PlTerm x(A1);
  PlTerm y(A2);
  PlTerm result(A3);
  return result.unify_integer(x.as_long() + y.as_long());
}
</pre>

<p>or more compactly:

<pre class="code">
PREDICATE(add, 3)  // add(+X, +Y, +Result)
{ auto x = A1, y = A2, result = A3;
  return result.unify_integer(x.as_long() + y.as_long());
}
</pre>

<p>The <b>as_long()</b> method for a <code>PlTerm</code> performs a <b>PL_get_long_ex()</b> 
and throws a C++ exception if the Prolog argument is not a Prolog 
integer or float that can be converted without loss to a
<code>long</code>. The <b>unify_integer()</b> method of <code>PlTerm</code> 
is defined to perform unification and returns <code>true</code> or <code>false</code> 
depending on the result.

<pre class="code">
?- add(1, 2, X).

X = 3.
?- add(a, 2, X).
[ERROR: Type error: `integer' expected, found `a']
   Exception: (  7) add(a, 2, _G197) ?
</pre>

<p><h3 id="sec:cpp2-ex-average"><a id="sec:1.7.3"><span class="sec-nr">1.7.3</span> <span class="sec-title">Average 
of solutions - calling a Prolog goal</span></a></h3>

<a id="sec:cpp2-ex-average"></a>

<p>This example is a bit harder. The predicate <a id="idx:average3:35"></a><span class="pred-ext">average/3</span> 
is defined to take the template average(+Var, :Goal, -Average) , where <var>Goal</var> 
binds <var>Var</var> and will unify <var>Average</var> with average of 
the (integer) results.

<p><code>PlQuery</code> takes the name of a predicate and the 
goal-argument vector as arguments. From this information it deduces the 
arity and locates the predicate. The method <a class="func" href="#PlQuery::next_solution()">PlQuery::next_solution()</a> 
yields
<code>true</code> if there was a solution and <code>false</code> 
otherwise. If the goal yields a Prolog exception, it is mapped into a 
C++ exception. A return to Prolog does an implicit &ldquo;cut&rdquo; (<b>PL_cut_query()</b>); 
this can also be done explicitly by the <a class="func" href="#PlQuery::cut()">PlQuery::cut()</a> 
method.

<pre class="code">
PREDICATE(average, 3) /* average(+Templ, :Goal, -Average) */
{ long sum = 0;
  long n = 0;

  PlQuery q("call", PlTermv(A2));
  while( q.next_solution() )
  { sum += A1.as_long();
    n++;
  }
  return A3.unify_float(double(sum) / double(n));
}
</pre>

<pre class="code">
?- [user].
|: p(1).
|: p(10).
|: p(20).
|:
% user://1 compiled 0.00 sec, 3 clauses
true.

?- average(X, p(X), Average).
Average = 10.333333333333334.
</pre>

<p><h2 id="sec:cpp2-rationale"><a id="sec:1.8"><span class="sec-nr">1.8</span> <span class="sec-title">Rationale 
for changes from version 1</span></a></h2>

<a id="sec:cpp2-rationale"></a>

<p><h3 id="sec:cpp2-rationale-ctors"><a id="sec:1.8.1"><span class="sec-nr">1.8.1</span> <span class="sec-title">Implicit 
constructors and conversion operators</span></a></h3>

<a id="sec:cpp2-rationale-ctors"></a>

<p>The original version of the C++ interface heavily used implicit 
constructors and conversion operators. This allowed, for example:

<pre class="code">
PREDICATE(hello, 1)
{ cout &lt;&lt; "Hello " &lt;&lt; (char *)A1 &lt;&lt; endl; // Deprecated
  return true;
}

PREDICATE(add, 3)
{ return A3 = (long)A1 + (long)A2; // Deprecated
}
</pre>

<p>Version 2 is a bit more verbose:

<pre class="code">
PREDICATE(hello, 1)
{ cout &lt;&lt; "Hello " &lt;&lt; A1.as_string() &lt;&lt; endl;
  return true;
}

PREDICATE(add, 3)
{ return A3.unify_int(A1.as_long() + A2.as_long());
}
</pre>

<p>There are a few reasons for this:
<ul class="latex">
<li>The implicit constructors and conversion operators, combined with 
the C++ conversion rules for integers and floats, could sometimes lead 
to subtle bugs that were difficult to find -- in one case, a typo 
resulted in terms being unified with floating point values when the code 
intended them to be atoms. This was mainly because the underlying C 
types for terms, atoms, etc. are unsigned integers, leading to confusion 
between numeric values and Prolog terms and atoms.
<li>The overloaded assignment operator for unification changed the usual 
C++ semantics for assignments from returning a reference to the 
left-hand-side to returning a <code>bool</code>. In addition, the result 
of unification should always be checked (e.g., an &ldquo;always succeed&rdquo; unification 
could fail due to an out-of-memory error); the <b>unify_XXX()</b> 
methods return a <code>bool</code> and they can be wrapped inside a <a class="func" href="#PlCheckFail()">PlCheckFail()</a> 
to raise an exception on unification failure.
<li>The C-style of casts is deprecated in C++, so the expression
<code>(char*)A1</code> becomes the more verbose
<code>static_cast&lt;std::string&gt;(A1)</code>, which is longer than
<code>A1.<a class="func" href="#as_string()">as_string()</a></code>. 
Also, the string casts don't allow for specifying encoding.
<li>The implicit constructors and conversion operators were attractive 
because they allowed directly calling the foreign language interface 
functions, for example:

<pre class="code">
PlTerm t;
Pl_put_atom_chars(t, "someName");
</pre>

<p>whereas this is now required:

<pre class="code">
PlTerm t;
Pl_put_atom_chars(t.as_term_t(), "someName");
</pre>

<p>However, this is mostly avoided by methods and constructors that wrap 
the foreign language functions:

<pre class="code">
PlTerm_atom t("someName");
</pre>

<p>or

<pre class="code">
auto t = PlTerm_atom("someName");
</pre>

<p>Additionally, there are now wrappers for most of the PL_*() functions 
that check the error return and throw a C++ exception as appropriate.
</ul>

<p>Over time, it is expected that some of these restrictions will be 
eased, to allow a more compact coding style that was the intent of the 
original API. However, too much use of overloaded methods/constructors, 
implicit conversions and constructors can result in code that's 
difficult to understand, so a balance needs to be struck between 
compactness of code and understandability.

<p>For backwards compatibility, much of the version 1 interface is still 
available (except for the implicit constructors and operators), but 
marked as &ldquo;deprecated&rdquo; ; code that depends on the parts that 
have been removed can be easily changed to use the new interface.

<p><h3 id="sec:cpp2-rationale-strings"><a id="sec:1.8.2"><span class="sec-nr">1.8.2</span> <span class="sec-title">Strings</span></a></h3>

<a id="sec:cpp2-rationale-strings"></a>

<p>The version API often used <code>char*</code> for both setting and 
setting string values. This is not a problem for setting (although 
encodings can be an issue), but can introduce subtle bugs in the 
lifetimes of pointers if the buffer stack isn't used properly. <code>PlStringBuffers</code> 
makes the buffer stack easier to use, but it would be preferable to 
avoid its use altogether. C++, unlike C, has a standard string that 
allows easily keeping a copy rather than dealing with a pointer that 
might become invalid. (Also, C++ strings can contain null characters.)

<p>C++ has default conversion operators from <code>char*</code> to
<code>std::string</code>, so some of the API support only
<code>std::string</code>, even though this can cause a small 
inefficiency. If this proves to be a problem, additional overloaded 
functions and methods can be provided in future (note that some 
compilers have optimizations that reduce the overheads of using
<code>std::string</code>); but for performance-critical code, the C 
functions can still be used.

<p>There still remains the problems of Unicode and encodings.
<code>std::wstring</code> is one way of dealing with this. And for 
interfaces that use <code>std::string</code>, an encoding can be 
specified.<sup class="fn">26<span class="fn-text">As of 2023-04, this 
had only been partially implemented</span></sup>. Some of the details 
for this - such as the default encoding - may change slightly in the 
future.

<p><h2 id="sec:cpp2-porting-1-2"><a id="sec:1.9"><span class="sec-nr">1.9</span> <span class="sec-title">Porting 
from version 1 to version 2</span></a></h2>

<a id="sec:cpp2-porting-1-2"></a>

<p>The easiest way of porting from <code>SWI-cpp.h</code> to <code>SWI-cpp2.h</code> 
is to change the <code>#include "SWI-cpp.h"</code> to <code>#include 
"SWI-cpp2.h"</code> and look at the warning and error messages. Where 
possible, version 2 keeps old interfaces with a &ldquo;deprecated&rdquo; flag 
if there is a better way of doing things with version 2.

<p>For convenience when calling PL_*() functions, the Plx_*() wrapper 
functions add error checking. Also, most of the PL_*() functions that 
work with <code>term_t</code>, <code>atom_t</code>, etc. have 
corresponding methods in <code>PlTerm</code>, <code>PlAtom</code>, etc.

<p>Here is a list of typical changes:
<ul class="latex">
<li>Replace <b>PlTerm()</b> constructor with
<b>PlTerm_var()</b> for uninstantiated variables,
<b>PlTerm_atom(a)</b> for atoms, <b>PlTerm_term_t(t)</b> for the raw <code>term_t</code>, <b>PlTerm_integer(i)</b>,
<b>PlTerm_float(v)</b>, or <b>PlTerm_pointer(p)</b>.

<p>
<li>Examine uses of <code>char*</code> or <code>wchar_t</code> and 
replace them by
<code>std::string</code> or <code>std::wstring</code> if appropriate. 
For example, <code>cout &lt;&lt; "Hello " &lt;&lt; (char*)A1 &lt;&lt; 
endl</code> can be replaced by <code>cout &lt;&lt; "Hello " &lt;&lt; A1.<a class="func" href="#as_string()">as_string()</a> 
&lt;&lt; endl</code>. In general, <code>std::string</code> is safer than <code>char*</code> 
because the latter can potentially point to freed memory.

<p>
<li>Instead of returning <code>false</code> from a predicate for 
failure, you can do <code>throw <b>PlFail()</b></code>. This mechanism 
is also used by
<a class="func" href="#PlCheckFail()">PlCheckFail(rc)</a>. Note that 
throwing an exception is slower than returning <code>false</code>, so 
performance-critical code should avoid <a class="func" href="#PlCheckFail()">PlCheckFail(rc)</a> 
if failure is expected to happen often.

<p>
<li>You can use the <a class="func" href="#PlEx()">PlEx(rc)</a> to check 
the return code from a function in <code>SWI-Prolog</code> and throw a <code>PlFail</code> 
exception to short-circuit execution and return failure (<code>false</code>) 
to Prolog (or throw a <code>PlException</code> if there was a Prolog 
error.

<p>
<li><code>PlAtom::handle</code> has been replaced by <code>PlAtom::C_</code>, 
which should be accessed by <b>PlAtom::unwrap()</b>.

<p>
<li><code>PlTerm::ref</code> has been replaced by <code>PlTerm::C_</code>, 
which should be accessed by <b>PlTerm::unwrap()</b>.

<p>
<li><code>PlFunctor::functor</code> has been replaced by <code>PlFunctor::C_</code>, 
which should be accessed by <b>PlFunctor::unwrap()</b>.

<p>
<li>The operator <code><code>=</code></code> for unification has been 
deprecated, replaced by various unify_*() methods (<a class="func" href="#PlTerm::unify_term()">PlTerm::unify_term(t2)</a>,
<a class="func" href="#PlTerm::unify_atom()">PlTerm::unify_atom(a)</a>, 
etc.).

<p>
<li>The various &ldquo;cast&rdquo; operators have been deprecated or 
deleted; you should use the various &ldquo;getter&rdquo; methods. For 
example,
<code>static_cast&lt;char*&gt;(t)</code> is replaced by <code>t.<a class="func" href="#as_string()">as_string()</a>.<b>c_str()</b></code> 
(and you should prefer <code>t.<b>as_striong()</b></code>;
<code>static_cast&lt;<var>int32_t</var>&gt;(t)</code> is replaced by <code>t.<b>as_int32_t()</b></code>, 
etc.

<p>
<li>It is recommended that you do not use <code>int</code> or
<code>long</code> because of problems porting between Unix and Windows 
platforms; instead, use <code>int32_t</code>, <code>int64_t</code>,
<code>uint32_t</code>, <code>uint64_t</code>, etc.

<p>
</ul>

<p><h2 id="sec:cpp2-plfail"><a id="sec:1.10"><span class="sec-nr">1.10</span> <span class="sec-title">The 
class PlFail</span></a></h2>

<a id="sec:cpp2-plfail"></a>

<p>The <code>PlFail</code> class is used for short-circuiting a function 
when failure or an exception occurs and any errors will be handled in 
the code generated by the <a class="func" href="#PREDICATE()">PREDICATE()</a> 
macro. See also
<a class="sec" href="#sec:1.17.2">section 1.17.2</a>).

<p>For example, this code, using the C API:

<pre class="code">
PREDICATE(unify_zero, 1)
{ if ( !PL_unify_integer(A1.unwrap(), 0) )
    return false; // could be an error or failure
  Sprintf("It's zero!\n");
  return true;
}
</pre>

<p>can instead be written this way, using the C++ API:

<pre class="code">
PREDICATE(unify_zero, 1)
{ PlCheckFail(A1.unify_integer(0));
  Sprintf("It's zero!\n");
  return true;
}
</pre>

<p>Using <code>throw <b>PlFail()</b></code> in performance-critical code 
can cause a signficant slowdown. A simple benchmark showed a 15x to 20x 
slowdown using <code>throw <b>PlFail()</b></code> compared to <code>return 
false</code> (comparing the first code sample above with the second and 
third samples; the speed difference seems to have been because in the 
second sample, the compiler did a better job of inlining). However, for 
most code, this difference will be barely noticeable. And if the code 
usually succeeds, there is no significant difference.

<p>There was no significant performance difference between the C++ 
version and this C version:

<pre class="code">
static foreign_t
unify_zero(term_t a1)
{ return PL_unify_integer(a1, 0);
}
</pre>

<p><h3 id="sec:cpp2-plcheck"><a id="sec:1.10.1"><span class="sec-nr">1.10.1</span> <span class="sec-title">PlCheckFail(), 
and PlEx() convenience functions</span></a></h3>

<a id="sec:cpp2-plcheck"></a>

<p>If one of the C PL_*() functions in <code>SWI-Prolog.h</code> returns 
failure, this can be either a Prolog-style failure (e.g. from
<b>PL_unify()</b> or <b>PL_next_solution()</b>) or an error. If the 
failure is due to an error, it's usually best to immediately return to 
Prolog - and this can be done with the <a class="func" href="#PlEx()">PlEx()</a> 
function, which turns a Prolog error into a C++ <code>PlException</code>. <a class="func" href="#PlCheckFail()">PlCheckFail()</a> 
calls <a class="func" href="#PlEx()">PlEx()</a> and additionally throws <b>PlFail()</b> 
if the failure is for Prolog failure.

<p><a class="func" href="#PlEx()">PlEx()</a> calls <b>PL_exception()</b> 
to see if there is a Prolog exception; if so, the Prolog exception is 
converted to a
<code>PlException</code> object, which is then thrown. For more details 
on the C++ exceptions, see <a class="sec" href="#sec:1.15">section 1.15</a>.

<dl class="latex">
<dt class="pubdef"><a id="PlCheckFail()"><var>void</var> <strong>PlCheckFail</strong>(<var>bool 
rc</var>)</a></dt>
<dd class="defbody">
If <var>rc</var> is <code>false</code>, throw <code>PlFail</code> to 
return control to Prolog with failure.
</dd>
<dt class="pubdef"><a id="PlWrap()"><var>C_t</var> <strong>PlWrap</strong>(<var>C_t 
rc, qid_t qid = 0</var>)</a></dt>
<dd class="defbody">
If <var>rc</var> indicates failure or an error, check for an error and 
throw a <code>PlException</code> if there was one; otherwise, return the <var>rc</var>.
</dd>
<dt class="pubdef"><a id="PlEx()"><var>void</var> <strong>PlEx</strong>(<var>C_t 
rc, qid_t qid = 0</var>)</a></dt>
<dd class="defbody">
If <var>rc</var> is &ldquo;false&rdquo; (non-zero), throw <code>PlFail</code> 
to return control to Prolog with failure. This is the same as <a class="func" href="#PlCheckFail()">PlCheckFail()</a> 
except it can also specify a
<code>qid_t</code> query ID.
</dd>
</dl>

<p><h2 id="sec:cpp2-plterm-get-put-unify"><a id="sec:1.11"><span class="sec-nr">1.11</span> <span class="sec-title">Overview 
of accessing and changing values</span></a></h2>

<a id="sec:cpp2-plterm-get-put-unify"></a>

<p>The <code>SWI-Prolog.h</code> header provides various functions for 
accessing, setting, and unifying terms, atoms and other types. 
Typically, these functions return a <code>0</code> (<code>false</code>) 
or
<code>1</code> (<code>true</code>) value for whether they succeeded or 
not. For failure, there might also be an exception created - this can be 
tested by calling <b>PL_excpetion(0)</b>.

<p>There are three major groups of methods:
<ul class="latex">
<li>Put (set) a value, corresponding to the PL_put_*() functions.
<li>Get a value, corresponding to the PL_get_*() and PL_get_*<b>_ex()</b> 
functions.
<li>Unify a value, corresponding to the PL_unify_*() and PL_unify_*<b>_ex()</b> 
functions.
</ul>

<p>The &ldquo;put&rdquo; operations are typically done on an 
uninstantiated term (see the <b>PlTerm_var()</b> constructor). These are 
expected to succeed, and typically raise an exception failure (e.g., 
resource exception) - for details, see the corresponding PL_put_*() 
functions in
<a class="url" href="https://www.swi-prolog.org/pldoc/man?section=foreign-term-construct">Constructing 
Terms</a>.

<p>For the &ldquo;get&rdquo; and &ldquo;unify&rdquo; operations, there 
are three possible failures:
<ul class="latex">
<li><code>false</code> return code
<li>unification failure
<li>exception (value of unexpected type or out of resources)
</ul>

<p>Each of these is communicated to Prolog by returning <code>false</code> 
from the top level; exceptions also set a &ldquo;global&rdquo; exception 
term (using <b>PL_raise_exception()</b>). The C++ programmer usually 
doesn't have to worry about this; instead they can <code>throw <b>PlFail()</b></code> 
for failure or <code>throw <b>PlException()</b></code> (or one of <code>PlException</code>&rsquo;s 
subclasses) and the C++ API will take care of everything.

<p><h3 id="sec:cpp2-plterm-casting"><a id="sec:1.11.1"><span class="sec-nr">1.11.1</span> <span class="sec-title">Converting 
PlTerm to native C and C++ types</span></a></h3>

<a id="sec:cpp2-plterm-casting"></a>

<p>These are <em>deprecated</em> and replaced by the various <code>as_*()</code> 
methods.

<p><code>PlTerm</code> can be converted to the following types:

<dl class="latex">
<dt><strong>PlTerm ::operator term_t</strong>(<var>void</var>)</dt>
<dd class="defbody">
This cast is used for integration with the C-interface primitives.
</dd>
<dt><strong>PlTerm ::operator long</strong>(<var>void</var>)</dt>
<dd class="defbody">
Yields a <code>long</code> if the <code>PlTerm</code> is a Prolog 
integer or float that can be converted without loss to a long. Throws a
<code>type_error</code> exception otherwise.
</dd>
<dt><strong>PlTerm ::operator int</strong>(<var>void</var>)</dt>
<dd class="defbody">
Same as for <code>long</code>, but might represent fewer bits.
</dd>
<dt><strong>PlTerm ::operator double</strong>(<var>void</var>)</dt>
<dd class="defbody">
Yields the value as a C double if <code>PlTerm</code> represents a 
Prolog integer or float.
</dd>
<dt><strong>PlTerm ::operator wchar_t *</strong>(<var>void</var>)</dt>
<dt><strong>PlTerm ::operator char *</strong>(<var>void</var>)</dt>
<dd class="defbody">
Converts the Prolog argument using <b>PL_get_chars()</b> using the flags
<code>CVT_ALL|CVT_WRITE|BUF_RING</code>, which implies Prolog atoms and 
strings are converted to the represented text. All other data is handed 
to <a id="idx:write1:36"></a><span class="pred-ext">write/1</span>. If 
the text is static in Prolog, a direct pointer to the string is 
returned. Otherwise the text is saved in a ring of 16 buffers and must 
be copied to avoid overwriting.
</dd>
<dt><strong>PlTerm ::operator void *</strong>(<var>void</var>)</dt>
<dd class="defbody">
Extracts pointer value from a term. The term should have been created by <b>PlTerm::PlTerm(void*)</b>.
</dd>
</dl>

<p>In addition, the Prolog type (<code>PL_VARIABLE</code>,
<code>PL_ATOM</code>, ... <code>PL_DICT</code>) can be determined using 
the <b>type()</b> method. There are also boolean methods that check the 
type:

<dl class="latex">
<dt class="pubdef"><a id="PlTerm::type()"><var>int</var> <strong>PlTerm::type</strong>(<var></var>)</a></dt>
<dd class="defbody">
See <b>PL_term_type()</b>
</dd>
<dt class="pubdef"><a id="PlTerm::is_variable()"><var>bool</var> <strong>PlTerm::is_variable</strong>(<var></var>)</a></dt>
<dd class="defbody">
See <b>PL_is_variable()</b>
</dd>
<dt class="pubdef"><a id="PlTerm::is_ground()"><var>bool</var> <strong>PlTerm::is_ground</strong>(<var></var>)</a></dt>
<dd class="defbody">
See <b>PL_is_ground()</b>
</dd>
<dt class="pubdef"><a id="PlTerm::is_atom()"><var>bool</var> <strong>PlTerm::is_atom</strong>(<var>S</var>)</a></dt>
<dd class="defbody">
ee <b>PL_is_atom()</b>
</dd>
<dt class="pubdef"><a id="PlTerm::is_integer()"><var>bool</var> <strong>PlTerm::is_integer</strong>(<var>S</var>)</a></dt>
<dd class="defbody">
ee <b>PL_is_integer()</b>
</dd>
<dt class="pubdef"><a id="PlTerm::is_string()"><var>bool</var> <strong>PlTerm::is_string</strong>(<var>S</var>)</a></dt>
<dd class="defbody">
ee <b>PL_is_string()</b>
</dd>
<dt class="pubdef"><a id="PlTerm::is_atom_or_string()"><var>bool</var> <strong>PlTerm::is_atom_or_string</strong>(<var>I</var>)</a></dt>
<dd class="defbody">
s true if either <a class="func" href="#PlTerm::is_atom()">PlTerm::is_atom()</a> 
or <a class="func" href="#PlTerm::is_string()">PlTerm::is_string()</a> 
is true.
</dd>
<dt class="pubdef"><a id="PlTerm::is_float()"><var>bool</var> <strong>PlTerm::is_float</strong>(<var>S</var>)</a></dt>
<dd class="defbody">
ee <b>PL_is_float()</b>
</dd>
<dt class="pubdef"><a id="PlTerm::is_rational()"><var>bool</var> <strong>PlTerm::is_rational</strong>(<var>S</var>)</a></dt>
<dd class="defbody">
ee <b>PL_is_rational()</b>
</dd>
<dt class="pubdef"><a id="PlTerm::is_compound()"><var>bool</var> <strong>PlTerm::is_compound</strong>(<var>S</var>)</a></dt>
<dd class="defbody">
ee <b>PL_is_compound()</b>
</dd>
<dt class="pubdef"><a id="PlTerm::is_callable()"><var>bool</var> <strong>PlTerm::is_callable</strong>(<var>S</var>)</a></dt>
<dd class="defbody">
ee <b>PL_is_callable()</b>
</dd>
<dt class="pubdef"><a id="PlTerm::is_list()"><var>bool</var> <strong>PlTerm::is_list</strong>(<var>S</var>)</a></dt>
<dd class="defbody">
ee <b>PL_is_list()</b>
</dd>
<dt class="pubdef"><a id="PlTerm::is_dict()"><var>bool</var> <strong>PlTerm::is_dict</strong>(<var>S</var>)</a></dt>
<dd class="defbody">
ee <b>PL_is_dict()</b>
</dd>
<dt class="pubdef"><a id="PlTerm::is_pair()"><var>bool</var> <strong>PlTerm::is_pair</strong>(<var>S</var>)</a></dt>
<dd class="defbody">
ee <b>PL_is_pair()</b>
</dd>
<dt class="pubdef"><a id="PlTerm::is_atomic()"><var>bool</var> <strong>PlTerm::is_atomic</strong>(<var>S</var>)</a></dt>
<dd class="defbody">
ee <b>PL_is_atomic()</b>
</dd>
<dt class="pubdef"><a id="PlTerm::is_number()"><var>bool</var> <strong>PlTerm::is_number</strong>(<var>S</var>)</a></dt>
<dd class="defbody">
ee <b>PL_is_number()</b>
</dd>
<dt class="pubdef"><a id="PlTerm::is_acyclic()"><var>bool</var> <strong>PlTerm::is_acyclic</strong>(<var>S</var>)</a></dt>
<dd class="defbody">
ee <b>PL_is_acyclic()</b>
</dd>
<dt class="pubdef"><a id="PlTerm::is_functor()"><var>bool</var> <strong>PlTerm::is_functor</strong>(<var>PlFunctor</var>)</a></dt>
<dd class="defbody">
See <b>PL_is_functor()</b>
</dd>
</dl>

<p><h3 id="sec:cpp2-plterm-unification"><a id="sec:1.11.2"><span class="sec-nr">1.11.2</span> <span class="sec-title">Unification</span></a></h3>

<a id="sec:cpp2-plterm-unification"></a>

<p>See also <a class="sec" href="#sec:1.13.1">section 1.13.1</a>.

<dl class="latex">
<dt class="pubdef"><a id="PlTerm::unify_term()"><var>bool</var> <strong>PlTerm::unify_term</strong>(<var>PlTerm</var>)</a></dt>
<dt class="pubdef"><a id="PlTerm::unify_atom()"><var>bool</var> <strong>PlTerm::unify_atom</strong>(<var>PlAtom</var>)</a></dt>
<dt class="pubdef"><a id="PlTerm::unify_atom()"><var>bool</var> <strong>PlTerm::unify_atom</strong>(<var>string</var>)</a></dt>
<dt class="pubdef"><a id="PlTerm::unify_list_codes()"><var>bool</var> <strong>PlTerm::unify_list_codes</strong>(<var>string</var>)</a></dt>
<dt class="pubdef"><a id="PlTerm::unify_list_chars()"><var>bool</var> <strong>PlTerm::unify_list_chars</strong>(<var>string</var>)</a></dt>
<dt class="pubdef"><a id="PlTerm::unify_integer()"><var>bool</var> <strong>PlTerm::unify_integer</strong>(<var>int</var>)</a></dt>
<dt class="pubdef"><a id="PlTerm::unify_float()"><var>bool</var> <strong>PlTerm::unify_float</strong>(<var>double</var>)</a></dt>
<dt class="pubdef"><a id="PlTerm::unify_string()"><var>bool</var> <strong>PlTerm::unify_string</strong>(<var>string</var>)</a></dt>
<dt class="pubdef"><a id="PlTerm::unify_functor()"><var>bool</var> <strong>PlTerm::unify_functor</strong>(<var>PlFunctor</var>)</a></dt>
<dt class="pubdef"><a id="PlTerm::unify_pointer()"><var>bool</var> <strong>PlTerm::unify_pointer</strong>(<var>void 
*</var>)</a></dt>
<dt class="pubdef"><a id="PlTerm::unify_nil()"><var>bool</var> <strong>PlTerm::unify_nil</strong>(<var></var>)</a></dt>
<dt class="pubdef"><a id="PlTerm::unify_blob()"><var>bool</var> <strong>PlTerm::unify_blob</strong>(<var>PlBlob* 
blob</var>)</a></dt>
<dt class="pubdef"><a id="PlTerm::unify_blob()"><var>bool</var> <strong>PlTerm::unify_blob</strong>(<var>std::unique_ptr&lt;<var>PlBlob</var>&gt;* 
blob</var>)</a></dt>
<dd class="defbody">
Does a call to <b>PL_unify_blob()</b> and, if successful, calls 
std::unique_ptr&lt;<var>PlBlob</var>&gt;::<b>release()</b> to pass 
ownership to the Prolog blob; on failure or error, deletes the pointer 
(ad calls its destructor). After either success and failure, <code>*blob==nullptr</code>.
</dd>
<dt class="pubdef"><a id="PlTerm::unify_blob()"><var>bool</var> <strong>PlTerm::unify_blob</strong>(<var>void 
*blob, size_t len, PL_blob_t *type</var>)</a></dt>
<dt class="pubdef"><a id="PlTerm::unify_chars()"><var>bool</var> <strong>PlTerm::unify_chars</strong>(<var>int 
flags, size_t len, const char *s</var>)</a></dt>
<dd class="defbody">

<p>A family of unification methods are defined for the various Prolog 
types and C++ types. Wherever <code>string</code> is shown, you can use:
<ul class="latex">
<li><code>char*</code>
<li><code>whar_t*</code>
<li><code>std::string</code>
<li><code>std::wstring</code>
</ul>

<p></dd>
</dl>

<p>Here is an example:

<pre class="code">
PREDICATE(hostname, 1)
{ char buf[256];
  if ( gethostname(buf, sizeof buf) == 0 )
    return A1.unify_atom(buf);
  return false;
}
</pre>

<p>An alternative way of writing this would use the <a class="func" href="#PlCheckFail()">PlCheckFail()</a> 
to raise an exception if the unification fails.

<pre class="code">
PREDICATE(hostname2, 1)
{ char buf[256];
  PlCheckFail(gethostname(buf, sizeof buf) == 0);
  PlCheckFail(A1.unify_atom(buf));
  return true;
}
</pre>

<p>Of course, in a real program, the failure of
<b>gethostname(buf)</b>sizeof buf should create an error term than 
contains information from <code>errno</code>.

<p><h3 id="sec:cpp2-plterm-comparison"><a id="sec:1.11.3"><span class="sec-nr">1.11.3</span> <span class="sec-title">Comparison</span></a></h3>

<a id="sec:cpp2-plterm-comparison"></a>

<dl class="latex">
<dt class="pubdef"><a id="PlTerm::compare()"><var>int</var> <strong>PlTerm::compare</strong>(<var>const 
PlTerm &amp;t2</var>)</a></dt>
<dt class="pubdef"><a id="PlTerm==()"><var>bool</var> <strong>PlTerm::operator 
==</strong>(<var>const PlTerm &amp;</var>)</a></dt>
<dt class="pubdef"><a id="PlTerm!=()"><var>bool</var> <strong>PlTerm::operator 
!=</strong>(<var>const PlTerm &amp;</var>)</a></dt>
<dt class="pubdef"><a id="PlTerm<()"><var>bool</var> <strong>PlTerm::operator <var>&lt;</var></strong>(<var>const 
PlTerm &amp;</var>)</a></dt>
<dt class="pubdef"><a id="PlTerm>()"><var>bool</var> <strong>PlTerm::operator <var>&gt;</var></strong>(<var>const 
PlTerm &amp;</var>)</a></dt>
<dt class="pubdef"><a id="PlTerm<=()"><var>bool</var> <strong>PlTerm::operator <var>&lt;=</var></strong>(<var>const 
PlTerm &amp;</var>)</a></dt>
<dt class="pubdef"><a id="PlTerm>=()"><var>bool</var> <strong>PlTerm::operator <var>&gt;=</var></strong>(<var>const 
PlTerm &amp;</var>)</a></dt>
<dd class="defbody">
Compare the instance with <var>t</var> and return the result according 
to the Prolog defined <em>standard order of terms</em>.
</dd>
<dt class="pubdef"><a id="PlTerm==()"><var>bool</var> <strong>PlTerm::operator 
==</strong>(<var>long num</var>)</a></dt>
<dt class="pubdef"><a id="PlTerm!=()"><var>bool</var> <strong>PlTerm::operator 
!=</strong>(<var>long num</var>)</a></dt>
<dt class="pubdef"><a id="PlTerm<()"><var>bool</var> <strong>PlTerm::operator <var>&lt;</var></strong>(<var>long 
num</var>)</a></dt>
<dt class="pubdef"><a id="PlTerm>()"><var>bool</var> <strong>PlTerm::operator <var>&gt;</var></strong>(<var>long 
num</var>)</a></dt>
<dt class="pubdef"><a id="PlTerm<=()"><var>bool</var> <strong>PlTerm::operator <var>&lt;=</var></strong>(<var>long 
num</var>)</a></dt>
<dt class="pubdef"><a id="PlTerm>=()"><var>bool</var> <strong>PlTerm::operator <var>&gt;=</var></strong>(<var>long 
num</var>)</a></dt>
<dd class="defbody">
Convert <code>PlTerm</code> to a <code>long</code> and perform standard 
C-comparison between the two long integers. If <code>PlTerm</code> 
cannot be converted a <code>type_error</code> is raised.</dd>
<dt class="pubdef"><a id="PlTerm==()"><var>bool</var> <strong>PlTerm::operator 
==</strong>(<var>const wchar_t *</var>)</a></dt>
<dt class="pubdef"><a id="PlTerm==()"><var>bool</var> <strong>PlTerm::operator 
==</strong>(<var>const char *</var>)</a></dt>
<dt class="pubdef"><a id="PlTerm==()"><var>bool</var> <strong>PlTerm::operator 
==</strong>(<var>std::wstring</var>)</a></dt>
<dt class="pubdef"><a id="PlTerm==()"><var>bool</var> <strong>PlTerm::operator 
==</strong>(<var>std::string</var>)</a></dt>
<dd class="defbody">
Yields <code>true</code> if the <code>PlTerm</code> is an atom or string 
representing the same text as the argument, <code>false</code> if the 
conversion was successful, but the strings are not equal and an
<code>type_error</code> exception if the conversion failed.
</dd>
</dl>

<p>Below are some typical examples. See <a class="sec" href="#sec:1.11.12.2">section 
1.11.12.2</a> for direct manipulation of atoms in their internal 
representation.

<p><table class="latex frame-hsides center">
<tr><td><code>A1 <var>&lt;</var> 0</code></td><td>Test <var>A1</var> to 
hold a Prolog integer or float that can be transformed lossless to an 
integer less than zero. </td></tr>
<tr><td><code>A1 <var>&lt;</var> <b>PlTerm(0)</b> </code></td><td><var>A1</var> 
is before the term&lsquo;0&rsquo;in the&lsquo;standard order of terms&rsquo;. 
This means that if <var>A1</var> represents an atom, this test yields <code>true</code>. </td></tr>
<tr><td><code>A1 == <b>PlCompound("a(1)")</b> </code></td><td>Test <var>A1</var> 
to represent the term
<code>a(1)</code>. </td></tr>
<tr><td><code>A1 == "now"</code></td><td>Test <var>A1</var> to be an 
atom or string holding the text &ldquo;now&rdquo; . </td></tr>
</table>

<p><h3 id="sec:cpp2-plterm-compound"><a id="sec:1.11.4"><span class="sec-nr">1.11.4</span> <span class="sec-title">Analysing 
compound terms</span></a></h3>

<a id="sec:cpp2-plterm-compound"></a>

<p>Compound terms can be viewed as an array of terms with a name and 
arity (length). This view is expressed by overloading the <code><code>[]</code></code> 
operator.

<p>A <code>type_error</code> is raised if the argument is not compound 
and a
<code>domain_error</code> if the index is out of range.

<p>In addition, the following functions are defined:

<dl class="latex">
<dt class="pubdef"><a id="PlTerm\[]()"><var>PlTerm</var> <strong>PlTerm::operator[]</strong>(<var>int 
arg</var>)</a></dt>
<dd class="defbody">
If the <code>PlTerm</code> is a compound term and <var>arg</var> is 
between 1 and the arity of the term, return a new <code>PlTerm</code> 
representing the arg-th argument of the term. If <code>PlTerm</code> is 
not compound, a
<code>type_error</code> is raised. Id <var>arg</var> is out of range, a
<code>domain_error</code> is raised. Please note the counting from 1 
which is consistent to Prolog's <a id="idx:arg3:37"></a><span class="pred-ext">arg/3</span> 
predicate, but inconsistent to C's normal view on an array. See also 
class <code>PlCompound</code>. The following example tests <var>x</var> 
to represent a term with first-argument an atom or string equal to <code>gnat</code>.

<pre class="code">
   ...,
   if ( x[1] == "gnat" )
     ...
</pre>

</dd>
<dt class="pubdef"><a id="PlTerm::name()"><var>const char *</var> <strong>PlTerm::name</strong>(<var></var>)</a></dt>
<dd class="defbody">
Return a <code>const char *</code> holding the name of the functor of 
the compound term. Raises a <code>type_error</code> if the argument is 
not compound.
</dd>
<dt class="pubdef"><a id="PlTerm::arity()"><var>size_t</var> <strong>PlTerm::arity</strong>(<var></var>)</a></dt>
<dd class="defbody">
Returns the arity of the compound term. Raises a <code>type_error</code> 
if the argument is not compound.
</dd>
</dl>

<p><h3 id="sec:cpp2-plterm-misc"><a id="sec:1.11.5"><span class="sec-nr">1.11.5</span> <span class="sec-title">Miscellaneous</span></a></h3>

<a id="sec:cpp2-plterm-misc"></a>

<dl class="latex">
<dt class="pubdef"><a id="is_null()"><var>bool</var> <strong>is_null</strong>(<var></var>)</a></dt>
<dd class="defbody">
<code>t.<a class="func" href="#is_null()">is_null()</a></code> is the 
same as <code>t.<b>unwrap()</b> == PlTerm::null</code>
</dd>
<dt class="pubdef"><a id="not_null()"><var>bool</var> <strong>not_null</strong>(<var></var>)</a></dt>
<dd class="defbody">
<code>t.<a class="func" href="#not_null()">not_null()</a></code> is the 
same as <code>t.<b>unwrap()</b> != PlTerm::null</code>
</dd>
<dt class="pubdef"><a id="reset()"><var>bool</var> <strong>reset</strong>(<var></var>)</a></dt>
<dd class="defbody">
<code>t.<a class="func" href="#reset()">reset()</a></code> is the same 
as <code>t.<b>unwrap()</b> = PlTerm::null</code>
</dd>
<dt class="pubdef"><a id="reset()"><var>bool</var> <strong>reset</strong>(<var>term_t</var>)</a></dt>
<dd class="defbody">
<code>t.reset(x)</code> is the same as <code>t.<b>unwrap()</b> = x</code>
</dd>
<dt class="pubdef"><a id="PlTerm::type()"><var>int</var> <strong>PlTerm::type</strong>(<var></var>)</a></dt>
<dd class="defbody">
Yields the actual type of the term as <b>PL_term_type()</b>. Return 
values are
<code>PL_VARIABLE</code>, <code>PL_FLOAT</code>, <code>PL_INTEGER</code>,
<code>PL_ATOM</code>, <code>PL_STRING</code> or <code>PL_TERM</code>
</dd>
<dt class="pubdef"><a id="as_string()"><var>std::string</var> <strong>as_string</strong>(<var>PlEncoding 
enc=EncLocale</var>)</a></dt>
<dd class="defbody">
Returns the string representation of the atom. See <b>PlAtom::as_string()</b> 
for an explanation of the encodings and caveats about <b>std::string::c_str()</b>.
</dd>
<dt class="pubdef"><a id="atomic_as_string()"><var>std::string</var> <strong>atomic_as_string</strong>(<var>PlEncoding 
enc=EncLocale</var>)</a></dt>
<dd class="defbody">
As <a class="func" href="#PlTerm::as_string()">PlTerm::as_string()</a>, 
but throws an exception if the term isn't atomic (see <a id="idx:atomic1:38"></a><span class="pred-ext">atomic/1</span>).
</dd>
<dt class="pubdef"><a id="atom_or_string_as_string()"><var>std::string</var> <strong>atom_or_string_as_string</strong>(<var>PlEncoding 
enc=EncLocale</var>)</a></dt>
<dd class="defbody">
As <a class="func" href="#PlTerm::as_string()">PlTerm::as_string()</a>, 
but throws an exception if the term isn't an atom or a string.

<p></dd>
</dl>

<p>To avoid very confusing combinations of constructors and therefore 
possible undesirable effects a number of subclasses of <code>PlTerm</code> 
have been defined that provide constructors for creating special Prolog 
terms. These subclasses are defined below.

<p><h3 id="sec:cpp2-plstring"><a id="sec:1.11.6"><span class="sec-nr">1.11.6</span> <span class="sec-title">The 
class PlTerm_string</span></a></h3>

<a id="sec:cpp2-plstring"></a>

<p>A SWI-Prolog string represents a byte-string on the global stack. Its 
lifetime is the same as for compound terms and other data living on the 
global stack. Strings are not only a compound representation of text 
that is garbage-collected, but as they can contain 0-bytes, they can be 
used to contain arbitrary C-data structures. However, it is generally 
preferred to use blobs for storing arbitrary C-data structures (see also <code><b>PlTerm_pointer(void 
*ptr)</b></code>).

<dl class="latex">
<dt><strong>PlTerm_string :: PlTerm_string</strong>(<var>const wchar_t 
*text</var>)</dt>
<dt><strong>PlTerm_string :: PlTerm_string</strong>(<var>const char 
*text</var>)</dt>
<dd class="defbody">
Create a SWI-Prolog string object from a 0-terminated C-string. The
<var>text</var> is copied.</dd>
<dt><strong>PlTerm_string :: PlTerm_string</strong>(<var>const wchar_t 
*text, size_t len</var>)</dt>
<dt><strong>PlTerm_string :: PlTerm_string</strong>(<var>const char 
*text, size_t len</var>)</dt>
<dd class="defbody">
Create a SWI-Prolog string object from a C-string with specified length. 
The <var>text</var> may contain 0-characters and is copied.
</dd>
</dl>

<p><h3 id="sec:cpp2-codelist"><a id="sec:1.11.7"><span class="sec-nr">1.11.7</span> <span class="sec-title">The 
class PlCodeList</span></a></h3>

<a id="sec:cpp2-codelist"></a>

<dl class="latex">
<dt><strong>PlCodeList :: PlCodeList</strong>(<var>const wchar_t *text</var>)</dt>
<dt><strong>PlCodeList :: PlCodeList</strong>(<var>const char *text</var>)</dt>
<dd class="defbody">
Create a Prolog list of ASCII codes from a 0-terminated C-string.
</dd>
</dl>

<p><h3 id="sec:cpp2-plcharlist"><a id="sec:1.11.8"><span class="sec-nr">1.11.8</span> <span class="sec-title">The 
class PlCharList</span></a></h3>

<a id="sec:cpp2-plcharlist"></a>

<p>Character lists are compliant to Prolog's <a id="idx:atomchars2:39"></a><span class="pred-ext">atom_chars/2</span> 
predicate.

<dl class="latex">
<dt><strong>PlCharList :: PlCharList</strong>(<var>const wchar_t *text</var>)</dt>
<dt><strong>PlCharList :: PlCharList</strong>(<var>const char *text</var>)</dt>
<dd class="defbody">
Create a Prolog list of one-character atoms from a 0-terminated 
C-string.
</dd>
</dl>

<p><h3 id="sec:cpp2-plcompound"><a id="sec:1.11.9"><span class="sec-nr">1.11.9</span> <span class="sec-title">The 
class PlCompound</span></a></h3>

<a id="sec:cpp2-plcompound"></a>

<p>The <code>PlCompound</code> class is a convenience class for creating 
a term from a string; it is similar to (=..)/2

<dl class="latex">
<dt><strong>PlCompound :: PlCompound</strong>(<var>const wchar_t *text</var>)</dt>
<dt><strong>PlCompound :: PlCompound</strong>(<var>const char *text</var>)</dt>
<dt><strong>PlCompound :: PlCompound</strong>(<var>const std::wstring&amp; 
text</var>)</dt>
<dt><strong>PlCompound :: PlCompound</strong>(<var>const std::string&amp; 
text</var>)</dt>
<dd class="defbody">
PlEncoding enc=ENC_INPUT Create a term by parsing (as <a id="idx:read1:40"></a><span class="pred-ext">read/1</span>) 
the <var>text</var>. If the <var>text</var> is not valid Prolog syntax, 
a <code>syntax_error</code> exception is raised. Otherwise a new 
term-reference holding the parsed text is created.</dd>
<dt><strong>PlCompound :: PlCompound</strong>(<var>const wchar_t 
*functor, PlTermv args</var>)</dt>
<dt><strong>PlCompound :: PlCompound</strong>(<var>const char *functor, 
PlTermv args</var>)</dt>
<dd class="defbody">
Create a compound term with the given name from the given vector of 
arguments. See <code>PlTermv</code> for details. The example below 
creates the Prolog term <code>hello(world)</code>.

<pre class="code">
PlCompound("hello", PlTermv(PlAtom("world")))
</pre>

<p></dd>
</dl>

<p><h3 id="sec:cpp2-pltail"><a id="sec:1.11.10"><span class="sec-nr">1.11.10</span> <span class="sec-title">The 
class PlTerm_tail</span></a></h3>

<a id="sec:cpp2-pltail"></a>

<p>The class <code>PlTerm_tail</code><sup class="fn">27<span class="fn-text">This 
was named <code>PlTail</code> in version 1 of the API.</span></sup> is 
both for analysing and constructing lists. It is called <code>PlTerm_tail</code> 
as enumeration-steps make the term-reference follow the &ldquo;tail&rdquo; of 
the list.

<dl class="latex">
<dt><strong>PlTerm_tail :: PlTerm_tail</strong>(<var>PlTerm list</var>)</dt>
<dd class="defbody">
A <code>PlTerm_tail</code> is created by making a new term-reference 
pointing to the same object. As <code>PlTerm_tail</code> is used to 
enumerate or build a Prolog list, the initial <var>list</var> 
term-reference keeps pointing to the head of the list.
</dd>
<dt class="pubdef"><a id="PlTerm_tail::append()"><var>int</var> <strong>PlTerm_tail::append</strong>(<var>const 
PlTerm &amp;element</var>)</a></dt>
<dd class="defbody">
Appends <var>element</var> to the list and make the <code>PlTerm_tail</code> 
reference point to the new variable tail. If <var>A</var> is a variable, 
and this function is called on it using the argument <code>"gnat"</code>, 
a list of the form <code>[gnat|B]</code> is created and the <code>PlTerm_tail</code> 
object now points to the new variable <var>B</var>.

<p>This function returns <code>true</code> if the unification succeeded 
and
<code>false</code> otherwise. No exceptions are generated.

<p>The example below translates the <b>main()</b> argument vector to 
Prolog and calls the prolog predicate <a id="idx:entry1:41"></a><span class="pred-ext">entry/1</span> 
with it.

<pre class="code">
int
main(int argc, char **argv)
{ PlEngine e(argv[0]);
  PlTermv av(1);
  PlTerm_tail l(av[0]);

  for(int i=0; i&lt;argc; i++)
    PlCheckFail(l.append(argv[i]));
  PlCheckFail(l.close());

  PlQuery q("entry", av);
  return q.next_solution() ? 0 : 1;
}
</pre>

</dd>
<dt class="pubdef"><a id="PlTerm_tail::close()"><var>int</var> <strong>PlTerm_tail::close</strong>(<var></var>)</a></dt>
<dd class="defbody">
Unifies the term with <code><code>[]</code></code> and returns the 
result of the unification.
</dd>
<dt class="pubdef"><a id="PlTerm_tail::next()"><var>int</var> <strong>PlTerm_tail::next</strong>(<var>PlTerm &amp;</var>)</a></dt>
<dd class="defbody">
Bind <var>t</var> to the next element of the list <code>PlTerm_tail</code> 
and advance
<code>PlTerm_tail</code>. Returns <code>true</code> on success and <code>false</code> 
if
<code>PlTerm_tail</code> represents the empty list. If <code>PlTerm_tail</code> 
is neither a list nor the empty list, a <code>type_error</code> is 
thrown. The example below prints the elements of a list.

<pre class="code">
PREDICATE(write_list, 1)
{ PlTerm_tail tail(A1);
  PlTerm_var e;

  while(tail.next(e))
    cout &lt;&lt; e.as_string() &lt;&lt; endl;

  return tail.close();
}
</pre>

<p></dd>
</dl>

<p><h3 id="sec:cpp2-pltermv"><a id="sec:1.11.11"><span class="sec-nr">1.11.11</span> <span class="sec-title">The 
class PlTermv</span></a></h3>

<a id="sec:cpp2-pltermv"></a>

<p>The class <code>PlTermv</code> represents an array of 
term-references. This type is used to pass the arguments to a foreign 
defined predicate, construct compound terms (see
<b>PlTerm::PlTerm(const char *name)</b>PlTermv arguments ), and to 
create queries (see <code>PlQuery</code>).

<p>The only useful member function is the overloading of <code><code>[]</code></code>, 
providing (0-based) access to the elements. Range checking is performed 
and raises a <code>domain_error</code> exception.

<p>The constructors for this class are below. Note that these can be 
error-prone because there's no distinction between <code>term_t</code> 
and
<code>size_t</code>; the form of the constructor is determined by 
whether the first argument is an integer (<code>term_t</code> or <code>size_t</code>) 
or
<code>PlTerm</code>.

<dl class="latex">
<dt><strong>PlTermv :: PlTermv</strong>(<var>size_t size</var>)</dt>
<dd class="defbody">
Create a new array of term-references, all holding variables.
</dd>
<dt><strong>PlTermv :: PlTermv</strong>(<var>size_t size, term_t t0</var>)</dt>
<dd class="defbody">
Convert a C-interface defined term-array into an instance. Typyically, <var>t0</var> 
was created using <b>Pl_new_term_refs(size)</b>.
</dd>
<dt><strong>PlTermv :: PlTermv</strong>(<var>PlTerm ...</var>)</dt>
<dd class="defbody">
Create a vector from 1 to 5 initialising arguments. For example:

<pre class="code">
load_file(const char *file)
{ return PlCall("compile", PlTermv(PlAtom(file)));
}
</pre>

<p>If the vector has to contain more than 5 elements, the following 
construction should be used:

<pre class="code">
{ PlTermv av(10);

  av[0].put_term(PlTerm_atom("hello"));
  av[1].put_term(PlTerm_integer(666));
  ...
}
</pre>

<p><em>Important</em>: be sure that all the arguments are of type
<code>PlTerm</code> - <code><b>PlTermv(i)</b></code> is not the same as
<code><b>PlTermv(PlTerm_integer(i))</b></code>, and will result in a 
runtime error.
</dd>
</dl>

<p><h3 id="sec:cpp2-prolog-constants"><a id="sec:1.11.12"><span class="sec-nr">1.11.12</span> <span class="sec-title">The 
class PlAtom - Supporting Prolog constants</span></a></h3>

<a id="sec:cpp2-prolog-constants"></a>

<p>Both for quick comparison as for quick building of lists of atoms, it 
is desirable to provide access to Prolog's atom-table, mapping handles 
to unique string-constants. If the handles of two atoms are different it 
is guaranteed they represent different text strings.

<p>Suppose we want to test whether a term represents a certain atom, 
this interface presents a large number of alternatives:

<p><h4 id="sec:cpp2-direct-commparison-to-char-star"><a id="sec:1.11.12.1"><span class="sec-nr">1.11.12.1</span> <span class="sec-title">Direct 
comparision to char *</span></a></h4>

<a id="sec:cpp2-direct-commparison-to-char-star"></a>

<p>Example:

<pre class="code">
PREDICATE(test, 1)
{ if ( A1 == "read" )
    ...;
}
</pre>

<p>This writes easily and is the preferred method is performance is not 
critical and only a few comparisons have to be made. It validates
<var>A1</var> to be a term-reference representing text (atom, string, 
integer or float) extracts the represented text and uses <b>strcmp()</b> 
to match the strings.

<p><h4 id="sec:cpp2-dirplatom"><a id="sec:1.11.12.2"><span class="sec-nr">1.11.12.2</span> <span class="sec-title">Direct 
comparision to PlAtom</span></a></h4>

<a id="sec:cpp2-dirplatom"></a>

<p>Example:

<pre class="code">
static PlAtom ATOM_read("read");

PREDICATE(test, 1)
{ if ( A1 == ATOM_read )
    ...;
}
</pre>

<p>This case raises a <code>type_error</code> if <var>A1</var> is not an 
atom. Otherwise it extacts the atom-handle and compares it to the 
atom-handle of the global <code>PlAtom</code> object. This approach is 
faster and provides more strict type-checking.

<p><h4 id="sec:cpp2-extraction-comparison-atoms"><a id="sec:1.11.12.3"><span class="sec-nr">1.11.12.3</span> <span class="sec-title">Extraction 
of the atom and comparison to PlAtom</span></a></h4>

<a id="sec:cpp2-extraction-comparison-atoms"></a>

<p>Example:

<pre class="code">
static PlAtom ATOM_read("read");

PREDICATE(test, 1)
{ PlAtom a1(A1);

  if ( a1 == ATOM_read )
    ...;
}
</pre>

<p>This approach is basically the same as <a class="sec" href="#sec:1.11.12.2">section 
1.11.12.2</a>, but in nested if-then-else the extraction of the atom 
from the term is done only once.

<p><h4 id="sec:cpp2-extraction-comparison-char-star"><a id="sec:1.11.12.4"><span class="sec-nr">1.11.12.4</span> <span class="sec-title">Extraction 
of the atom and comparison to char *</span></a></h4>

<a id="sec:cpp2-extraction-comparison-char-star"></a>

<p>Example:

<pre class="code">
PREDICATE(test, 1)
{ PlAtom a1(A1);

  if ( a1 == "read" )
    ...;
}
</pre>

<p>This approach extracts the atom once and for each test extracts the 
represented string from the atom and compares it. It avoids the need for 
global atom constructors.

<dl class="latex">
<dt><strong>PlAtom :: PlAtom</strong>(<var>atom_t handle</var>)</dt>
<dd class="defbody">
Create from C-interface atom handle (<code>atom_t</code>). Used 
internally and for integration with the C-interface.
</dd>
<dt><strong>PlAtom :: PlAtom</strong>(<var>const char_t *text</var>)</dt>
<dt><strong>PlAtom :: PlAtom</strong>(<var>const wchar *text</var>)</dt>
<dt><strong>PlAtom :: PlAtom</strong>(<var>const std::string&amp; text</var>)</dt>
<dt><strong>PlAtom :: PlAtom</strong>(<var>const std::wstring&amp; text</var>)</dt>
<dd class="defbody">
Create an atom from a string. The <var>text</var> is copied if a new 
atom is created. See <b>PL_new_atom()</b>, <b>PL_new_atom_wchars()</b>,
<b>PL_new_atom_nchars()</b>, <b>PL_new_atom_wchars()</b>.
</dd>
<dt><strong>PlAtom :: PlAtom</strong>(<var>const PlTerm &amp;</var>)</dt>
<dd class="defbody">
If <var>t</var> represents an atom, the new instance represents this 
atom. Otherwise a <code>type_error</code> is thrown.
</dd>
<dt class="pubdef"><a id="PlAtom==()"><var>int</var> <strong>PlAtom::operator 
==</strong>(<var>const wchar_t *text</var>)</a></dt>
<dt class="pubdef"><a id="PlAtom==()"><var>int</var> <strong>PlAtom::operator 
==</strong>(<var>const char *text</var>)</a></dt>
<dt class="pubdef"><a id="PlAtom==()"><var>int</var> <strong>PlAtom::operator 
==</strong>(<var>const std::string&amp; text</var>)</a></dt>
<dt class="pubdef"><a id="PlAtom==()"><var>int</var> <strong>PlAtom::operator 
==</strong>(<var>const std::wstring&amp; text</var>)</a></dt>
<dd class="defbody">
Yields <code>true</code> if the atom represents <var>text</var>, <code>false</code> 
otherwise. Performs a <b>strcmp()</b> or similar for this.
</dd>
<dt class="pubdef"><a id="PlAtom==()"><var>int</var> <strong>PlAtom::operator 
==</strong>(<var>const PlAtom &amp;</var>)</a></dt>
<dd class="defbody">
Compares the two atom-handles, returning <code>true</code> or
<code>false</code>. Because atoms are unique, there is no need to use <b>strcmp()</b> 
for this.
</dd>
<dt class="pubdef"><a id="PlAtom!=()"><var>int</var> <strong>PlAtom::operator 
!=</strong>(<var>const wchar_t *text</var>)</a></dt>
<dt class="pubdef"><a id="PlAtom!=()"><var>int</var> <strong>PlAtom::operator 
!=</strong>(<var>const char *text</var>)</a></dt>
<dt class="pubdef"><a id="PlAtom!=()"><var>int</var> <strong>PlAtom::operator 
!=</strong>(<var>const std::string&amp; text</var>)</a></dt>
<dt class="pubdef"><a id="PlAtom!=()"><var>int</var> <strong>PlAtom::operator 
!=</strong>(<var>const std::wstring&amp; text</var>)</a></dt>
<dt class="pubdef"><a id="PlAtom!=()"><var>int</var> <strong>PlAtom::operator 
!=</strong>(<var>const PlAtom &amp;</var>)</a></dt>
<dd class="defbody">
The inverse of the <code><code>==</code></code> operator.
</dd>
<dt class="pubdef"><a id="is_valid()"><var>bool</var> <strong>is_valid</strong>(<var></var>)</a></dt>
<dd class="defbody">
Verifies that the handle is valid. This can be used after calling a 
function that returns an atom handle, to check that a new atom was 
created.
</dd>
<dt class="pubdef"><a id="reset()"><var>void</var> <strong>reset</strong>(<var></var>)</a></dt>
<dd class="defbody">
Sets the handle to an invalid valid - a subsequent call to <a class="func" href="#is_null()">is_null()</a> 
will return <code>true</code>.
</dd>
<dt class="pubdef"><a id="as_string()"><var>const std::string</var> <strong>as_string</strong>(<var>PlEncoding 
enc=EncLocale</var>)</a></dt>
<dd class="defbody">
Returns the string representation of the atom.<sup class="fn">28<span class="fn-text">If 
you wish to return a <code>char*</code> from a function, you should not 
do <code>return t.<a class="func" href="#as_string()">as_string()</a>.<b>c_str()</b></code> 
because that will return a pointer into the stack (Gnu C++ or Clang 
options <code>-Wreturn-stack-address</code> or <code>-Wreturn-local-addr</code>) 
can <em>sometimes</em> catch this, as can the runtime address sanitizer 
when run with <code>detect_stack_use_after_return=1</code>.</span></sup> 
This does not quote or escape any characters that would need to be 
escaped if the atom were to be input to the Prolog parser. The possible 
values for <code>enc</code> are:
<ul class="latex">
<li><code>EncLatin1</code> - throws an exception if cannot be 
represented in ASCII.
<li><code>EncUTF8</code>
<li><code>EncLocale</code> - uses the locale to determine the 
representation.
</ul>
</dd>
<dt class="pubdef"><a id="as_wstring()"><var>const std:wstring</var> <strong>as_wstring</strong>(<var></var>)</a></dt>
<dd class="defbody">
Returns the string representation of the atom. This does not quote or 
escape any characters that would need to be escaped if the atom were to 
be input to the Prolog parser.
</dd>
<dt class="pubdef"><a id="register_atom()"><var>void</var> <strong>register_atom</strong>(<var></var>)</a></dt>
<dd class="defbody">
See <b>PL_register_atom()</b>.
</dd>
<dt class="pubdef"><a id="unregister_atom()"><var>void</var> <strong>unregister_atom</strong>(<var></var>)</a></dt>
<dd class="defbody">
See <b>PL_unregister_atom()</b>.
</dd>
<dt class="pubdef"><a id="blob_data()"><var>void*</var> <strong>blob_data</strong>(<var>size_t 
*len, struct PL_blob_t **type</var>)</a></dt>
<dd class="defbody">
See <b>PL_blob_data()</b>.
</dd>
</dl>

<p><h3 id="sec:cpp2-plrecord"><a id="sec:1.11.13"><span class="sec-nr">1.11.13</span> <span class="sec-title">Classes 
for the recorded database: PlRecord and PlRecordExternalCopy</span></a></h3>

<a id="sec:cpp2-plrecord"></a>

<p>The
<a class="url" href="https://www.swi-prolog.org/pldoc/man?section=foreign-recorded">recorded 
database</a> is has two wrappers, for supporting the <em>internal 
records</em> and <em>external records</em>.

<p>Currently, the interface to <em>internal records</em> requires that 
the programmer explicitly call the <b>dupicate()</b> and <a class="func" href="#erase()">erase()</a> 
methods - in future, it is intended that this will be done automatically 
by a new
<code>PlRecord</code> class, so that the internal records behave like &ldquo;smart 
pointers&rdquo; ; in the meantime, the <code>PlRecord</code> provides a 
trivial wrapper around the various recorded database functions.

<p>The class <code>PlRecord</code> supports the following methods:

<dl class="latex">
<dt class="pubdef"><a id="PlRecord()"><var></var> <strong>PlRecord</strong>(<var>PlTerm</var>)</a></dt>
<dd class="defbody">
Constructor.
</dd>
<dt class="pubdef"><a id="PlRecord()"><var></var> <strong>PlRecord</strong>(<var>PlRecord</var>)</a></dt>
<dd class="defbody">
Copy and move constructors. Currently these do not do any reference 
counting. The assignment operator is currently not supported.
</dd>
<dt class="pubdef"><a id="~PlRecord()"><var></var> <strong>&nbsp;PlRecord</strong>(<var></var>)</a></dt>
<dd class="defbody">
Destructor. Currently this does not call <b>PL_erase()</b>.
</dd>
<dt class="pubdef"><a id="term()"><var>PlTerm</var> <strong>term</strong>(<var></var>)</a></dt>
<dd class="defbody">
creates a term from the record, using <b>PL_recorded()</b>.
</dd>
<dt class="pubdef"><a id="erase()"><var>void</var> <strong>erase</strong>(<var></var>)</a></dt>
<dd class="defbody">
decrements the reference count of the record and deletes it if the count 
goes to zero, using <b>PL_erase()</b>. It is safe to do this multiple 
times on the same
<code>PlRecord</code> object.
</dd>
<dt class="pubdef"><a id="duplicate()"><var>PlRecord</var> <strong>duplicate</strong>(<var></var>)</a></dt>
<dd class="defbody">
increments the reference count of the record, using <b>PL_duplicate_record()</b>.
</dd>
</dl>

<p>The class <code>PlRecord</code> provides direct access to the 
reference counting aspects of the recorded term (through the <a class="func" href="#duplicate()">duplicate()</a> 
and
<a class="func" href="#erase()">erase()</a> methods), but does <em>not</em> 
connect these with C++'s copy constructor, assignment operator, or 
destructor. If the recorded term is encapsulated within an object, then 
the containing object can use the <a class="func" href="#duplicate()">duplicate()</a> 
and <a class="func" href="#erase()">erase()</a> methods in its copy and 
move constructors and assignment operators (and the <a class="func" href="#erase()">erase()</a> 
method in the destructor).<sup class="fn">29<span class="fn-text">The 
copy constructor and assignment use the <a class="func" href="#duplicate()">duplicate()</a> 
method; the move constructor and assignment use the <a class="func" href="#duplicate()">duplicate()</a> 
method to assign to the destination and the <a class="func" href="#erase()">erase()</a> 
method on the source; and the destructor uses <a class="func" href="#erase()">erase()</a>.</span></sup>

<p>Alternatively, the <code>std::shared_ptr</code> or <code>std::unique_ptr</code> 
can be used with the supplied <code>PlrecordDeleter</code>, which calls 
the
<a class="func" href="#erase()">erase()</a> method when the <code>shared_ptr</code> 
reference count goes to zero or when the <code>std::unique_ptr</code> 
goes out of scope.

<p>For example:

<pre class="code">
std::shared_ptr&lt;PlRecord&gt; r(new PlRecord(t.record()), PlRecordDeleter());
assert(t.unify_term(r-&gt;term()));
</pre>

<p>The class <code>PlRecordExternalCopy</code> keeps the <em>external 
record</em> as an uninterpreted string (which may contain nulls). It 
supports the following methods.

<dl class="latex">
<dt><strong>PlRecordExternalCopy :: PlRecordExternalCopy</strong>(<var>PlTerm 
t</var>)</dt>
<dd class="defbody">
Creates a string using <b>Pl_record_external()</b>, copies it into the 
object then deletes the reference using <b>PL_erase_external()</b>.
</dd>
<dt><strong>PlRecordExternalCopy :: PlRecordExternalCopy</strong>(<var>const 
std::string&amp; external</var>)</dt>
<dd class="defbody">
Saves the <var>external</var> string (which is assumed to have been 
created using <b>PL_record_external()</b>).
</dd>
<dt><strong>PlRecordExternalCopy :: PlRecordExternalCopy</strong>(<var>const 
char* external, size_t len</var>)</dt>
<dd class="defbody">
Saves the <var>external</var> string (which is assumed to have been 
created using <b>PL_record_external()</b>).
</dd>
<dt class="pubdef"><a id="term()"><var>PlTerm</var> <strong>term</strong>(<var></var>)</a></dt>
<dd class="defbody">
creates a term from the saved external record string, using <b>PL_recorded_external()</b>).
</dd>
<dt class="pubdef"><a id="term()"><var>static PlTerm</var> <strong>term</strong>(<var>const 
std::string&amp; external</var>)</a></dt>
<dd class="defbody">
Creates a term from the external record string. Equivalent to <b>PlRecordExternalCopy(external)</b>.<a class="func" href="#term()">term()</a>.
</dd>
<dt class="pubdef"><a id="term()"><var>static PlTerm</var> <strong>term</strong>(<var>const 
char* external</var>)</a></dt>
<dd class="defbody">
Creates a term from the external record string. Equivalent to <b>PlRecordExternalCopy(external,len)</b>.<a class="func" href="#term()">term()</a> 
except the length is inferred from <var>external</var>&rsquo;s contents.
</dd>
<dt class="pubdef"><a id="data()"><var>const std::string&amp;</var> <strong>data</strong>(<var></var>)</a></dt>
<dd class="defbody">
Gets the external string that was created by the constructor.
</dd>
</dl>

<p><h2 id="sec:cpp2-plregister"><a id="sec:1.12"><span class="sec-nr">1.12</span> <span class="sec-title">The 
class PlRegister</span></a></h2>

<a id="sec:cpp2-plregister"></a>

<p>This class encapsulates <b>PL_register_foreign()</b>. It is defined 
as a class rather then a function to exploit the C++ <em>global 
constructor</em> feature. This class provides a constructor to deal with 
the <a class="func" href="#PREDICATE()">PREDICATE()</a> way of defining 
foreign predicates as well as constructors to deal with more 
conventional foreign predicate definitions.

<dl class="latex">
<dt><strong>PlRegister :: PlRegister</strong>(<var>const char *module, 
const char *name, int arity, foreign_t (f)(term_t t0, int a, control_t 
ctx)</var>)</dt>
<dd class="defbody">
Register <var>f</var> as a the implementation of the foreign predicate
&lt;<var>name</var>&gt;/&lt;<var>arity</var>&gt;. This interface uses 
the <code>PL_FA_VARARGS</code> calling convention, where the argument 
list of the predicate is passed using an array of <code>term_t</code> 
objects as returned by <b>PL_new_term_refs()</b>. This interface poses 
no limits on the arity of the predicate and is faster, especially for a 
large number of arguments.
</dd>
<dt><strong>PlRegister :: PlRegister</strong>(<var>const char *module, 
const char *name, foreign_t (*f)(PlTerm a0, ...</var>)</dt>
<dd class="defbody">
Registers functions for use with the traditional calling conventional, 
where each positional argument to the predicate is passed as an argument 
to the function <var>f</var>. This can be used to define functions as 
predicates similar to what is used in the C-interface:

<pre class="code">
static foreign_t
pl_hello(PlTerm a1)
{ ...
}

PlRegister x_hello_1(NULL, "hello", 1, pl_hello);
</pre>

<p>This construct is currently supported upto 3 arguments.
</dd>
</dl>

<p><h2 id="sec:cpp2-plquery"><a id="sec:1.13"><span class="sec-nr">1.13</span> <span class="sec-title">The 
class PlQuery</span></a></h2>

<a id="sec:cpp2-plquery"></a>

<p>This class encapsulates the call-backs onto Prolog.

<dl class="latex">
<dt><strong>PlQuery :: PlQuery</strong>(<var>const char *name, const 
PlTermv &amp;av, int flags = PL_Q_PASS_EXCEPTION</var>)</dt>
<dd class="defbody">
Create a query where <var>name</var> defines the name of the predicate 
and
<var>av</var> the argument vector. The arity is deduced from <var>av</var>. 
The predicate is located in the Prolog module <code>user</code>.
</dd>
<dt><strong>PlQuery :: PlQuery</strong>(<var>const char *module, const 
char *name, const PlTermv &amp;av, int flags = PL_Q_PASS_EXCEPTION</var>)</dt>
<dd class="defbody">
Same, but performs the predicate lookup in the indicated module.
</dd>
<dt class="pubdef"><a id="PlQuery::next_solution()"><var>int</var> <strong>PlQuery::next_solution</strong>(<var></var>)</a></dt>
<dd class="defbody">
Provide the next solution to the query. Yields <code>true</code> if 
successful and <code>false</code> if there are no (more) solutions. 
Prolog exceptions are mapped to C++ exceptions. If the <a class="" href="#class:PlQuery">PlQuery</a> 
object was created with the <code>PL_Q_EXT_STATUS</code> flag, the 
extended return codes can also be returned (<code>TRUE</code>,
<code>FALSE</code>,
<code>PL_S_NOT_INNER</code>,
<code>PL_S_EXCEPTION</code>,
<code>PL_S_FALSE</code>,
<code>PL_S_TRUE</code>,
<code>PL_S_LAST</code>). Because of this, you shouldn't use <a class="func" href="#PlCheckFail()">PlCheckFail()</a> 
with <a class="func" href="#PlQuery::next_solution()">PlQuery::next_solution()</a> 
in this situation.</dd>
<dt class="pubdef"><a id="PlQuery::cut()"><var>void</var> <strong>PlQuery::cut</strong>(<var></var>)</a></dt>
<dd class="defbody">
Discards the query, but does not delete an of the data created by the 
query. If there is any pending Prolog exception, it is mapped to a C++ 
exception and thrown. The call to <a class="func" href="#PlQuery::cut()">PlQuery::cut()</a> 
is done implicitly by <code>PlQuery</code>&rsquo;s destructor.

<p>Below is an example listing the currently defined Prolog modules to 
the terminal.

<pre class="code">
PREDICATE(list_modules, 0)
{ PlTermv av(1);

  PlQuery q("current_module", av);
  while( q.next_solution() )
    cout &lt;&lt; av[0].as_string() &lt;&lt; endl;

  return true;
}
</pre>

<p></dd>
</dl>

<p>In addition to the above, the following functions have been defined.

<dl class="latex">
<dt class="pubdef"><a id="PlCall()"><var>int</var> <strong>PlCall</strong>(<var>const 
char *predicate, const PlTermv &amp;av</var>)</a></dt>
<dd class="defbody">
Creates a <code>PlQuery</code> from the arguments generates the first <b>next_solution()</b> 
and destroys the query. Returns the result of <b>next_solution()</b> or 
an exception.
</dd>
<dt class="pubdef"><a id="PlCall()"><var>int</var> <strong>PlCall</strong>(<var>const 
char *module, const char *predicate, const PlTermv &amp;av</var>)</a></dt>
<dd class="defbody">
Same, locating the predicate in the named module.
</dd>
<dt class="pubdef"><a id="PlCall()"><var>int</var> <strong>PlCall</strong>(<var>const 
wchar_t *goal</var>)</a></dt>
<dt class="pubdef"><a id="PlCall()"><var>int</var> <strong>PlCall</strong>(<var>const 
std::string&amp; goal</var>)</a></dt>
<dd class="defbody">
Translates <var>goal</var> into a term and calls this term as the other
<a class="func" href="#PlCall()">PlCall()</a> variations. Especially 
suitable for simple goals such as making Prolog load a file.
</dd>
<dt class="pubdef"><a id="PlTerm::call()"><var>bool</var> <strong>PlTerm::call</strong>(<var></var>)</a></dt>
<dd class="defbody">
Wrapper for <b>PL_call()</b>, returning <code>true</code> or <code>false</code> 
for the success/failure of the call; and throws an exception if there's 
an error.
<code>t.<a class="func" href="#call()">call()</a></code> is essentially 
the same as <code><a class="func" href="#PlCall()">PlCall(t)</a></code>.
</dd>
<dt class="pubdef"><a id="PlTerm::call()"><var>bool</var> <strong>PlTerm::call</strong>(<var>PlModule 
m</var>)</a></dt>
<dd class="defbody">
Same as <a class="func" href="#PlTerm::call()">PlTerm::call()</a> but 
specifying the module.
</dd>
</dl>

<p><h3 id="sec:cpp2-plframe"><a id="sec:1.13.1"><span class="sec-nr">1.13.1</span> <span class="sec-title">The 
class PlFrame - Unification and foreign frames</span></a></h3>

<a id="sec:cpp2-plframe"></a>

<p>As documented with <b>PL_unify()</b>, if a unification call fails and 
control isn't made immediately to Prolog, any changes made by 
unification must be undone. The functions <b>PL_open_foreign_frame()</b>,
<b>PL_rewind_foreign_frame()</b>, <b>PL_discard_foreign_frame()</b>, and
<b>PL_close_foreign_frame()</b> are encapsulated in the class
<code>PlFrame</code>, whose destructor calls
<b>PL_close_foreign_frame()</b>. Using this, the example code with <b>PL_unify()</b> 
can be written:

<pre class="code">
PREDICATE(can_unify_ffi, 2)
{ fid_t fid = PL_open_foreign_frame();

  int rval = PL_unify(A1.unwrap(), A2.unwrap());
  PL_discard_foreign_frame(fid);
  return rval;
}
</pre>

<pre class="code">
    /* equivalent to the Prolog code
       T1 = T2 -&gt; do_one_thing ; do_another_thing */
    { PlFrame fr;
      bool t1_t2_unified = A1.unify_term(A2);
      if ( ! t1_t2_unified )
        fr.rewind();
    if ( t1_t2_unified )
      do_one_thing(...);
    else
      do_another_thing(...);
}
</pre>

<p>The following is C++ version of the code example for
<b>PL_open_foreign_frame()</b>. The calls to <b>PL_close_foreign_frame()</b> 
and the check for <b>PL_exception(0)</b> in the C code aren't needed in 
the C++ code:

<pre class="code">
static std::vector&lt;std::string&gt; lookup_unifies =
  { "item(one, 1)", "item(two, 2)", "item(three, 3)" };

PREDICATE(lookup_unify, 1)
{ PlFrame fr;
  for (auto&amp; s : lookup_unifies )
  { PlCompound t(s);
    if ( A1.unify_term(t) )
      return true;
    fr.rewind();
  }
  return false;
}
</pre>

<p>or using this convenience wrapper:

<pre class="code">
    if ( RewindOnFail([t1=A1,t2=A2]()-&gt;bool
                      { return t1.unify_term(t2); }) )
      do_one_thing(...);
    else
      do_another_thing(...);
</pre>

<p>Note that <a class="func" href="#PlTerm::unify_term()">PlTerm::unify_term()</a> 
checks for an error and throws an exception to Prolog; if you wish to 
handle exceptions, you must call <code><b>PL_unify_term(t1. unwrap(),t2. 
unwrap())</b></code>.

<p>The class <code>PlFrame</code> provides an interface to discard 
unused term-references as well as rewinding unifications (<em>data-backtracking</em>).

<p>Reclaiming unused term-references is automatically performed after a 
call to a C++-defined predicate has finished and returns control to 
Prolog. In this scenario <code>PlFrame</code> is rarely of any use. This 
class comes into play if the toplevel program is defined in C++ and 
calls Prolog multiple times. Setting up arguments to a query requires 
term-references and using <code>PlFrame</code> is the only way to 
reclaim them.

<p>Another use of of <code>PlFrame</code> is when multiple separate 
unifications are done - if any of them fails, then the earlier 
unifications must be undone before returning to Prolog.

<dl class="latex">
<dt><strong>PlFrame :: PlFrame</strong>(<var></var>)</dt>
<dd class="defbody">
Creating an instance of this class marks all term-references created 
afterwards to be valid only in the scope of this instance.
</dd>
<dt><strong>~ PlFrame</strong>(<var></var>)</dt>
<dd class="defbody">
Reclaims all term-references created after constructing the instance. If 
either <b>close()</b> or <b>discard()</b> have been called, the 
destructor does nothing.
</dd>
<dt class="pubdef"><a id="PlFrame::rewind()"><var>void</var> <strong>PlFrame::rewind</strong>(<var></var>)</a></dt>
<dd class="defbody">
Discards all term-references <b>and</b> global-stack data created as 
well as undoing all unifications after the instance was created.
</dd>
<dt class="pubdef"><a id="PlFrame::close()"><var>void</var> <strong>PlFrame::close</strong>(<var></var>)</a></dt>
<dd class="defbody">
Reclaims all term-references created after constructing the instance.
</dd>
<dt class="pubdef"><a id="PlFrame::discard()"><var>void</var> <strong>PlFrame::discard</strong>(<var></var>)</a></dt>
<dd class="defbody">
Same as <a class="func" href="#PlFrame::rewind()">PlFrame::rewind()</a> 
+ <a class="func" href="#PlFrame::close()">PlFrame::close()</a>.
</dd>
<dt class="pubdef"><a id="PlRewindOnFail()"><var>bool</var> <strong>PlRewindOnFail</strong>(<var>std::function&lt;<b>bool()</b>&gt; 
f</var>)</a></dt>
<dd class="defbody">
is a convenience function that does a frame rewind if a function call 
fails (typically, failure due to unification failure). It takes a 
std::function&lt;<var>bool</var>&gt;()&gt; as an argument, which is 
called in the context of a new <code>PlFrame</code>.

<p></dd>
</dl>

<p><a id="idx:assert:42"></a>A typical use for <code>PlFrame</code> is 
the definition of C++ functions that call Prolog and may be called 
repeatedly from C++. Consider the definition of <b>assertWord()</b>, 
adding a fact to <a id="idx:word1:43"></a><span class="pred-ext">word/1</span>; 
the <code>PlFrame</code> removes the new term <code>av[0]</code> from 
the stack, which prevents the stack from growing each time <b>assertWord()</b> 
is called:

<pre class="code">
void
assertWord(const char *word)
{ PlFrame fr;
  PlTermv av(1);

  av[0] = PlCompound("word", PlTermv(word));
  PlQuery q("assert", av);
  PlCheckFail(q.next_solution());
}
</pre>

<p>The following example uses <code>PlFrame</code> in the context of a 
foreign predicate. The <a id="idx:canunify2:44"></a><span class="pred-ext">can_unify/2</span>&rsquo;s 
truth-value is the same as for Prolog unification (=/2), but has no side 
effects. In Prolog one would use double negation to achieve this:

<pre class="code">
PREDICATE(can_unify, 2)
{ PlFrame fr;

  int rval = (A1=A2);
  fr.discard(); // or, less efficiently: fr.rewindd();
  return rval;
}
</pre>

<p>Here is an example of using <a class="func" href="#PlRewindOnFail()">PlRewindOnFail()</a>, 
where <code>name_to_terms</code> contains a map from names to terms 
(which are made global by using the <b>PL_record()</b> function). The 
frame rewind is needed in the situation where the first <b>unify_term()</b> 
succeeds and the second one fails.

<pre class="code">
static const std::map&lt;const std::string, PlRecord&gt; name_to_term =
    { {"a", PlTerm(...).record(), PlTerm(...).record()},
    ... };

PREDICATE(name_to_terms, 3)
{ A1.must_be_atom_or_string();
  const auto it = name_to_term.find(A1.as_string());
  return it != name_to_term.cend() &amp;&amp;
    PlRewindOnFail([t1=A2,t2=A3,&amp;it]()
                   { return t1.unify_term(it-&gt;second.first.term()) &amp;&amp;
                            t2.unify_term(it-&gt;second.second.term()); });
}
</pre>

<p>The equivalent code without using <a class="func" href="#PlRewindOnFail()">PlRewindOnFail()</a> 
is:

<pre class="code">
PREDICATE(name_to_terms, 3)
{ PlTerm key(A1), term1(A2), term2(A3);
  const auto it = name_to_term.find(key.as_string());
  if ( it == name_to_term.cend() )
    return false;
  if ( !term1.unify_term(it-&gt;second.first.term()) )
    return false;
  PlFrame fr;
  if ( !term2.unify_term(it-&gt;second.second.term()) )
  { fr.discard();
    return false;
  }
  return true;
}
</pre>

<p><h2 id="sec:cpp2-predicate-macro"><a id="sec:1.14"><span class="sec-nr">1.14</span> <span class="sec-title">The 
PREDICATE and PREDICATE_NONDET macros</span></a></h2>

<a id="sec:cpp2-predicate-macro"></a>

<p>The PREDICATE macro is there to make your code look nice, taking care 
of the interface to the C-defined SWI-Prolog kernel as well as mapping 
exceptions. Using the macro

<pre class="code">
PREDICATE(hello, 1)
</pre>

<p>is the same as writing:<sup class="fn">30<span class="fn-text">There 
are a few more details, such as catching <code>std::bad_alloc</code>.</span></sup>:

<pre class="code">
static foreign_t pl_hello__1(PlTermv PL_av);

static foreign_t
_pl_hello__1(term_t t0, int arity, control_t ctx)
{ (void)arity; (void)ctx;
  try
  { return pl_hello__1(PlTermv(1, t0));
  } catch( PlFail&amp; )
  { return false;
  } catch ( PlException&amp; ex )
  { return ex.plThrow();
  }
}

static PlRegister _x_hello__1("hello", 1, _pl_hello__1);

static foreign_t
pl_hello__1(PlTermv PL_av)
</pre>

<p>The first function converts the parameters passed from the Prolog 
kernel to a <code>PlTermv</code> instance and maps exceptions raised in 
the body to simple failure or Prolog exceptions. The <code>PlRegister</code> 
global constructor registers the predicate. Finally, the function header 
for the implementation is created.

<p><h3 id="sec:cpp2-predicate-macro-variations"><a id="sec:1.14.1"><span class="sec-nr">1.14.1</span> <span class="sec-title">Variations 
of the PREDICATE macro</span></a></h3>

<a id="sec:cpp2-predicate-macro-variations"></a>

<p>The <a class="func" href="#PREDICATE()">PREDICATE()</a> macros have a 
number of variations that deal with special cases.

<dl class="latex">
<dt class="pubdef"><a id="PREDICATE()"><var></var> <strong>PREDICATE</strong>(<var>name, 
arity</var>)</a></dt>
<dd class="defbody">
Create a predicate with an automatically generated internal name, and 
register it with Prolog. The various term arguments are accessible as <code>A1</code>, <code>A2</code>, 
etc.</dd>
<dt class="pubdef"><a id="PREDICATE0()"><var></var> <strong>PREDICATE0</strong>(<var>name</var>)</a></dt>
<dd class="defbody">
This is the same as PREDICATE(name, 0). It avoids a compiler warning 
that <code>PL_av</code> is not used.</dd>
<dt class="pubdef"><a id="NAMED_PREDICATE()"><var></var> <strong>NAMED_PREDICATE</strong>(<var>plname, 
cname, arity</var>)</a></dt>
<dd class="defbody">
This version can be used to create predicates whose name is not a valid 
C++ identifier. Here is a ---hypothetical--- example, which unifies the 
second argument with a stringified version of the first. The <var>cname</var> 
is used to create a name for the functions. The concrete name does not 
matter, but must be unique. Typically it is a descriptive name using the 
limitations imposed by C++ indentifiers.

<pre class="code">
    NAMED_PREDICATE("#", hash, 2)
    { return A2.unify_string(A1.as_string());
    }
    </pre>

</dd>
<dt class="pubdef"><a id="PREDICATE_NONDET()"><var></var> <strong>PREDICATE_NONDET</strong>(<var>name, 
arity</var>)</a></dt>
<dd class="defbody">
Define a non-deterministic Prolog predicate in C++. See also
<a class="sec" href="#sec:1.14.2">section 1.14.2</a>.</dd>
<dt class="pubdef"><a id="NAMED_PREDICATE_NONDET()"><var></var> <strong>NAMED_PREDICATE_NONDET</strong>(<var>plname, 
cname, arity</var>)</a></dt>
<dd class="defbody">
Define a non-deterministic Prolog predicate in C++, whose name is not a 
valid C++ identifier. See also <a class="sec" href="#sec:1.14.2">section 
1.14.2</a>.

<p></dd>
</dl>

<p><h3 id="sec:cpp2-nondet"><a id="sec:1.14.2"><span class="sec-nr">1.14.2</span> <span class="sec-title">Non-deterministic 
predicates</span></a></h3>

<a id="sec:cpp2-nondet"></a>

<p>Non-deterministic predicates are defined using
<a class="func" href="#PREDICATE_NONDET()">PREDICATE_NONDET(plname, 
cname, arity)</a> or
<a class="func" href="#NAMED_PREDICATE_NONDET()">NAMED_PREDICATE_NONDET(plname, 
cname, arity)</a>.

<p>A non-deterministic predicate returns a &ldquo;context&rdquo; , which 
is passed to a subsequent retry. Typically, this context is allocated on 
the first call to the predicate and freed when the predicate either 
fails or does its last successful return (the context is <code>nullptr</code> 
on the first call). To simplify this, a template helper function 
PlControl::context_unique_ptr&lt;<var>ContextType</var>&gt;() provides a &ldquo;smart 
pointer&rdquo; that frees the context on normal return or an exception; 
when used with <b>PL_retry_address()</b>, the context's std:unique_ptr&lt;<var>ContextType</var>&gt;::<b>release()</b> 
is used to pass the context to Prolog for the next retry, and to prevent 
the context from being freed. If the predicate is called with <code>PL_PRUNE</code>, 
the normal <code>return true</code> will implicitly free the context.

<p>The skeleton for a typical non-deterministic predicate is as follows. 
The test for <code>PL_PRUNED</code> is done first to avoid an unneeded
<code>PlFrame</code> and also to ensure that <var>A1</var>, <var>A2</var>, 
etc. aren't used when they have the value
<code>PlTerm::null</code>.<sup class="fn">31<span class="fn-text">This 
code could be structured as a <code>switch</code> statement, but 
typically the <code>PL_FIRST_CALL</code> case falls through to the <code>PL_REDO</code> 
case.</span></sup> There are a number of examples of non-deterministic 
predicates in the test code <code>test_cpp.cpp</code>.

<pre class="code">
struct PredContext { ... }; // The "context" for retries

PREDICATE_NONDET(pred, &lt;arity&gt;)
{ // "ctxt" must be acquired so that the destructor deletes it
  auto ctxt = handle.context_unique_ptr&lt;PredContext&gt;();
  const auto control  = handle.foreign_control();
  if ( control == PL_PRUNED )
    return true;

  // Can use A1, A2, etc. after we know control != PL_PRUNED

  if ( ... ) // deterministic result
  { assert(control == PL_FIRST_CALL);
    if ( ... )
      return true;  // Success (and no more solutions)
    else
      return fase;
  }

  if ( control = PL_FIRST_CALL )
  { ctxt.reset(new PredContext(...));
    ...
  } else
  { assert(control == PL_REDO);
  }

  PlFrame fr;
  for ( ; ctxt-&gt;valid(...) ; ctxt-&gt;next() )
  { if ( ... unify a result ... )
    { ctxt-&gt;next();
      if ( ctxt-&gt;valid(...) )
        PL_retry_addresss(ctxt.release()); // Succeed with a choice point
      else
        return true; // deterministic success
    }
    fr.rewind();
  }

  return false;
}
</pre>

<p><h3 id="sec:cpp2-module"><a id="sec:1.14.3"><span class="sec-nr">1.14.3</span> <span class="sec-title">Controlling 
the Prolog destination module</span></a></h3>

<a id="sec:cpp2-module"></a>

<p>With no special precautions, the predicates are defined into the 
module from which <a id="idx:loadforeignlibrary1:45"></a><span class="pred-ext">load_foreign_library/1</span> 
was called, or in the module
<code>user</code> if there is no Prolog context from which to deduce the 
module such as while linking the extension statically with the Prolog 
kernel.

<p>Alternatively, <em>before</em> loading the SWI-Prolog include file, 
the macro PROLOG_MODULE may be defined to a string containing the name 
of the destination module. A module name may only contain 
alpha-numerical characters (letters, digits, _). See the example below:

<pre class="code">
#define PROLOG_MODULE "math"
#include &lt;SWI-Prolog.h&gt;
#include &lt;math.h&gt;

PREDICATE(pi, 1)
{ A1 = M_PI;
}
</pre>

<pre class="code">
?- math:pi(X).

X = 3.14159
</pre>

<p><h2 id="sec:cpp2-exceptions"><a id="sec:1.15"><span class="sec-nr">1.15</span> <span class="sec-title">Exceptions</span></a></h2>

<a id="sec:cpp2-exceptions"></a>

<p>See also <a class="url" href="https://www.swi-prolog.org/pldoc/man?section=foreign-exceptions">Prolog 
exceptions in foreign code</a>.

<p>Prolog exceptions are mapped to C++ exceptions using the class
<code>PlException</code> (a subclass of <code>PlExceptionBase</code> to 
represent the Prolog exception term. All type-conversion functions of 
the interface raise Prolog-compliant exceptions, providing decent 
error-handling support at no extra work for the programmer.

<p>For some commonly used exceptions, convenience functions have been 
created to exploit both their constructors for easy creation of these 
exceptions. If you wish to trap these, you should use
<code>PlException</code> or <code>PlExceptionBase</code> and then look 
for the appropriate error name. For example, the following code catches
<code>"type_error"</code> and passes all other exceptions:

<pre class="code">
try
{ do_something(...);
} catch (const PlException&amp; e)
{ PlTerm e_t = e.term();
  PlAtom ATOM_type_error("type_error");
  // e_t.name() == PlAtom("error") &amp;&amp; e_t.arity() == 2
  if ( e_t[1].name() == ATOM_type_error) )
  { ... // expected type and culprit are \exam{e_t[1][1]} and \exam{e_t[1][2]}
  } else throw;
}
</pre>

<p>The convenience functions are <b>PlTypeEror()</b> and <b>PlDomainError()</b>,
<b>PlDomainError()</b>, <b>PlInstantiationError()</b>, <b>PlExistenceError()</b>,
<b>PlUninstantiationError()</b>, <b>PlRepresentationError()</b>,
<b>PlPermissionError()</b>, <b>PlResourceError()</b>, <b>PlUnknownError()</b>. 
There is also a <b>PlGeneralError(inside)</b> that creates <code>error(inside,_)</code> 
terms and is used by the other error convience functions.

<p>To throw an exception, create an instance of <code>PlException</code> 
and use <code>throw</code>. This is intercepted by the PREDICATE macro 
and turned into a Prolog exception. See <a class="sec" href="#sec:1.17.2">section 
1.17.2</a>.

<pre class="code">
  char *data = "users";

  throw PlException(PlCompound("no_database", PlTerm(data)));
</pre>

<p><h3 id="sec:cpp2-plexception"><a id="sec:1.15.1"><span class="sec-nr">1.15.1</span> <span class="sec-title">The 
class PlException</span></a></h3>

<a id="sec:cpp2-plexception"></a>

<p>This subclass of <code>PlExceptionBase</code> is used to represent 
exceptions. Currently defined methods are:

<dl class="latex">
<dt><strong>PlException :: PlException</strong>(<var>const PlTerm &amp;</var>)</dt>
<dd class="defbody">
Create an exception from a general Prolog term. This provides the 
interface for throwing any Prolog terms as an exception.
</dd>
<dt class="pubdef"><a id="as_string()"><var>std::string</var> <strong>as_string</strong>(<var></var>)</a></dt>
<dd class="defbody">
The exception is translated into a message as produced by
<a id="idx:printmessage2:46"></a><span class="pred-ext">print_message/2</span>. 
The character data is stored in a ring. Example:

<pre class="code">
  ...;
  try
  { PlCall("consult(load)");
  } catch ( PlException&amp; ex )
  { cerr &lt;&lt; ex.as_string() &lt;&lt; endl;
  }
</pre>

</dd>
<dt class="pubdef"><a id="plThrow()"><var>int</var> <strong>plThrow</strong>(<var></var>)</a></dt>
<dd class="defbody">
Used in the <a class="func" href="#PREDICATE()">PREDICATE()</a> wrapper 
to pass the exception to Prolog. See
<b>PL_raise_exeption()</b>.

<p></dd>
</dl>

<p><h4 id="sec:cpp2-pl-type-error"><a id="sec:1.15.1.1"><span class="sec-nr">1.15.1.1</span> <span class="sec-title">The 
function PlTypeError</span></a></h4>

<a id="sec:cpp2-pl-type-error"></a>

<p>A <em>type error</em> expresses that a term does not satisfy the 
expected basic Prolog type.

<dl class="latex">
<dt><strong>PlTypeError :: PlTypeError</strong>(<var>const std::string&amp; 
expected, const PlTerm &amp;actual</var>)</dt>
<dd class="defbody">
Creates an ISO standard Prolog error term expressing the
<var>expected</var> type and <var>actual</var> term that does not 
satisfy this type.
</dd>
</dl>

<p><h4 id="sec:cpp2-pl-domain-error"><a id="sec:1.15.1.2"><span class="sec-nr">1.15.1.2</span> <span class="sec-title">The 
function PlDomainError</span></a></h4>

<a id="sec:cpp2-pl-domain-error"></a>

<p>A <em>domain error</em> expresses that a term satisfies the basic 
Prolog type expected, but is unacceptable to the restricted domain 
expected by some operation. For example, the standard Prolog <a id="idx:open3:47"></a><span class="pred-ext">open/3</span> 
call expect an <code>io_mode</code> (read, write, append, ...). If an 
integer is provided, this is a <em>type error</em>, if an atom other 
than one of the defined io-modes is provided it is a <em>domain error</em>.

<dl class="latex">
<dt><strong>PlDomainError :: PlDomainError</strong>(<var>const 
std::string&amp; expected, const PlTerm &amp;actual</var>)</dt>
<dd class="defbody">
Creates an ISO standard Prolog error term expressing a the
<var>expected</var> domain and the <var>actual</var> term found.
</dd>
</dl>

<p><h2 id="sec:cpp2-embedding"><a id="sec:1.16"><span class="sec-nr">1.16</span> <span class="sec-title">Embedded 
applications</span></a></h2>

<a id="sec:cpp2-embedding"></a>

<p>Most of the above assumes Prolog is&lsquo;in charge&rsquo;of the 
application and C++ is used to add functionality to Prolog, either for 
accessing external resources or for performance reasons. In some 
applications, there is a <em>main-program</em> and we want to use Prolog 
as a
<em>logic server</em>. For these applications, the class
<code>PlEngine</code> has been defined.

<p>Only a single instance of this class can exist in a process. When 
used in a multi-threading application, only one thread at a time may 
have a running query on this engine. Applications should ensure this 
using proper locking techniques.<sup class="fn">32<span class="fn-text">For 
Unix, there is a multi-threaded version of SWI-Prolog. In this version 
each thread can create and destroy a thread-engine. There is currently 
no C++ interface defined to access this functionality, though ---of 
course--- you can use the C-functions.</span></sup>

<dl class="latex">
<dt><strong>PlEngine :: PlEngine</strong>(<var>int argc, char **argv</var>)</dt>
<dd class="defbody">
Initialises the Prolog engine. The application should make sure to pass <code>argv[0]</code> 
from its main function, which is needed in the Unix version to find the 
running executable. See <b>PL_initialise()</b> for details.
</dd>
<dt><strong>PlEngine :: PlEngine</strong>(<var>char *argv0</var>)</dt>
<dd class="defbody">
Simple constructure using the main constructor with the specified 
argument for <code>argv[0]</code>.
</dd>
<dt><strong>~ PlEngine</strong>(<var></var>)</dt>
<dd class="defbody">
Calls <b>PL_cleanup()</b> to destroy all data created by the Prolog 
engine.
</dd>
</dl>

<p><a class="sec" href="#sec:1.11.10">Section 1.11.10</a> has a simple 
example using this class.

<p><h2 id="sec:cpp2-considerations"><a id="sec:1.17"><span class="sec-nr">1.17</span> <span class="sec-title">Considerations</span></a></h2>

<a id="sec:cpp2-considerations"></a>

<p><h3 id="sec:cpp2-vs-c"><a id="sec:1.17.1"><span class="sec-nr">1.17.1</span> <span class="sec-title">The 
C++ versus the C interface</span></a></h3>

<a id="sec:cpp2-vs-c"></a>

<p>Not all functionality of the C-interface is provided, but as
<code>PlTerm</code> and <code>term_t</code> are essentially the same 
thing with type-conversion between the two (using the <b>unwrap()</b> 
method), this interface can be freely mixed with the functions defined 
for plain C. For checking return codes from C functions, it is 
recommended to use <a class="func" href="#PlCheckFail()">PlCheckFail()</a> 
or <b>PlCheck_PL()</b>.

<p>Using this interface rather than the plain C-interface requires a 
little more resources. More term-references are wasted (but reclaimed on 
return to Prolog or using <code>PlFrame</code>). Use of some 
intermediate types (<code>functor_t</code> etc.) is not supported in the 
current interface, causing more hash-table lookups. This could be fixed, 
at the price of slighly complicating the interface.

<p>Global terms and atoms need to be handled slightly differently in C++ 
than in C - see <a class="sec" href="#sec:1.17.3">section 1.17.3</a>

<p><h3 id="sec:cpp2-exceptions-notes"><a id="sec:1.17.2"><span class="sec-nr">1.17.2</span> <span class="sec-title">Notes 
on exceptions</span></a></h3>

<a id="sec:cpp2-exceptions-notes"></a>

<p>Exceptions are normal Prolog terms that are handled specially by the 
PREDICATE macro when they are used by a C++ <code>throw</code>, and 
converted into Prolog exceptions. The exception term may not be unbound; 
that is, throw(_) must raise an error. The C++ code and underlying C 
code do not explicitly check for the term being a variable, and 
behaviour of raising an exception that is an unbound term is undefined, 
including the possibility of causing a crash or corrupting data.

<p>The Prolog exception term error(Formal, _) is special. If the 2nd 
argument of <a id="idx:error2:48"></a><span class="pred-ext">error/2</span> 
is undefined, and the term is thrown, the system finds the catcher (if 
any), and calls the hooks in library(prolog_stack) to add the context 
and stack trace information when appropriate. That is, <code>throw <b>PlDomainError(Domain,Culprit)</b></code> 
ends up doing the same thing as calling
<code><b>PL_domain_error(Domain,Culprit)</b></code> which internally 
calls
<b>PL_raise_exception()</b> and returns control back to Prolog.

<p>The VM handling of calling to C finds the <code>FALSE</code> return 
code, checks for the pending exception and propagates the exception into 
the Prolog environment. As the term references (<code>term_t</code>) 
used to create the exception are lost while returning from the foreign 
function we need some way to protect them. That is done using a global <code>term_t</code> 
handle that is allocated at the epoch of Prolog.
<b>PL_raise_exception()</b> sets this to the term using <b>PL_put_term()</b>.
<b>PL_exception(0)</b> returns the global exception <code>term_t</code> 
if it is bound and 0 otherwise.

<p>Special care needs to be taken with data backtracking using
<b>PL_discard_foreign_frame()</b> or <b>PL_close_query()</b> because 
that will invalidate the exception term. So, between raising the 
exception and returning control back to Prolog we must make sure not to 
do anything that invalidates the exception term. If you suspect 
something like that to happen, use the debugger with a breakpoint on
<b>__do_undo__LD()</b> defined in <code>pl-wam.c</code>.

<p>In order to always preserve Prolog exceptions and return as quickly 
as possible to Prolog on an exception, some of the C++ classes can throw 
an exception in their destructor. This is theoretically a dangerous 
thing to do, and can lead to a crash or program termination if the 
destructor is invoked as part of handling another exception.

<p><h3 id="sec:cpp2-global"><a id="sec:1.17.3"><span class="sec-nr">1.17.3</span> <span class="sec-title">Global 
terms, atoms, and functors</span></a></h3>

<a id="sec:cpp2-global"></a>

<p>Sometimes it is convenient to put constant terms and atoms as global 
variables in a file (with a <code>static</code> qualifier), so that they 
are only created (and looked up) cone. This is fine for atoms and 
functors, which can be created by something like this:

<pre class="code">
static PlAtom ATOM_foo("foo");
static PlFunctor FUNCTOR_ff_2("ff", 2);
</pre>

<p>C++ makes no guarantees about the order of creating global variables 
across &ldquo;translation units&rdquo; (that is, individual C++ files), 
but the Prolog runtime ensures that the necessary initialization has 
been done to allow <code>PlAtom</code> and <code>PlFunctor</code> 
objects to be created. However, to be safe, it is best to put such 
global variables
<em>inside</em> functions - C++ will initialize them on their firstuse.

<p>Global Terms need a bit of care. For one thing, terms are ephemeral, 
so it is wrong to have a <code>PlTerm</code> static variable - instead, 
a
<code>PlRecord</code> must be used, which will provide a fresh copy of 
the term using <b>PlRecord::term()</b>. There is no guarantee that the 
Prolog runtime has initialized everything needed for creating entries in 
the recorded database (see
<a class="url" href="https://www.swi-prolog.org/pldoc/man?section=foreign-recorded">Recorded 
database</a>). Therefore, global recorded terms must be wrapped inside a 
function. C++ will call the constructor upon first use. For example:

<pre class="code">
static PlTerm
term_foo_bar()
{ static PlRecord r(PlCompound("foo", PlTermv(PlTerm_atom("bar"))).record());
  return r.term();
}
</pre>

<p><h3 id="sec:cpp2-atom-map"><a id="sec:1.17.4"><span class="sec-nr">1.17.4</span> <span class="sec-title">Atom 
map utilities</span></a></h3>

<a id="sec:cpp2-atom-map"></a>

<p>The include file <code>SWI-cpp2-atommap.h</code> contains a templated 
class
<code>AtomMap</code> for mapping atoms to atoms or terms. The typical 
use case is for when it is desired to open a database or stream and, 
instead of passing around the blob, an atom can be used to identify the 
blob.

<p>The keys in the map must be standard Prolog atoms and not blobs - the 
code depends on the fact that an atom has a unique ID.

<p>The <code>AtomMap</code> is thread-safe (it contains a mutex). It 
also takes care of reference counts for both the key and the value. Here 
is a typical use case:

<pre class="code">
static AtomMap&lt;PlAtom, PlAtom&gt; map_atom_my_blob("alias", "my_blob");

// look up an entry:
   auto value = map_atom_my_blob(A1.as_atom());
   PlCheckFail(value.not_null());

// insert an entry:
   map_atom_my_blob.insert(A1.as_atom(), A2.as_atom());

// remove an entry:
   map_atom_my_blob.erase(A1.as_atom());
</pre>

<p>The constructor and methods are as follows:

<p>
<ul class="latex">
<dt class="pubdef"><a id="template<ValueType,StoredValueType>AtomMap::AtomMap()"><var></var> <strong>template&lt;ValueType, 
StoredValueType&gt; AtomMap::AtomMap</strong>(<var>const std::string&amp; 
insert_op</var>)</a></dt>
<dd class="defbody">
const std::string&amp; insert_type Construct an <code>AtomMap</code>. 
The <var>ValueType</var> and <var>StoredValueType</var> specify what 
type you wish for the value. Currently, two value types are supported:
<ul class="latex">
<li><code>PlAtom</code> - the <var>StoredValueType</var> should be <code>PlAtom</code>.
<li><code>PlTerm</code> - the <var>StoredValueType</var> shoud be <code>PlRecord</code> 
(because the term needs to be put on the global stack).
</ul>
The <var>insert_op</var> and <var>insert_type</var> values are used in 
constructing error terms - these correspond to the <var>operation</var> 
and
<var>type</var> arguments to <b>Pl_permission_error()</b>.</dd>
<dt class="pubdef"><a id="PlAtomkey,ValueTypevalue()"><var>insert</var> <strong>PlAtom 
key, ValueType value</strong>(<var>I</var>)</a></dt>
<dd class="defbody">
nserts a new value; raises a <code>permission_error</code> if the value 
is already in the map, unless the value is identical to the value in the 
map. The <b>insert()</b> method converts the value to the <code>StoredValueType</code>. 
The insertion code takes care of atom reference counts.</dd>
<dt class="pubdef"><a id="find()"><var>ValueType</var> <strong>find</strong>(<var>PlAtom 
key</var>)</a></dt>
<dd class="defbody">
Look up an entry. Success/failure can be determined by using <b>ValueType::is_null()</b> 
or <b>ValueType::not_null()</b>. The stored value is converted from <code>StoredValueType</code> 
to <code>ValueType</code>.</dd>
<dt class="pubdef"><a id="PlAtom()"><var>erase</var> <strong>PlAtom</strong>(<var>r</var>)</a></dt>
<dd class="defbody">
emoves the entry from the map. If there was no entry in the map with 
that key, this is a no-op. The erasure code takes care of atom reference 
counts.

<p>
</ul>

<p><h3 id="sec:cpp2-linking"><a id="sec:1.17.5"><span class="sec-nr">1.17.5</span> <span class="sec-title">Static 
linking and embedding</span></a></h3>

<a id="sec:cpp2-linking"></a>

<p>The mechanisms outlined in this document can be used for static 
linking with the SWI-Prolog kernel using <strong>swipl-ld</strong>(1). 
In general the C++ linker should be used to deal with the C++ runtime 
libraries and global constructors.

<p><h3 id="sec:cpp2-status"><a id="sec:1.17.6"><span class="sec-nr">1.17.6</span> <span class="sec-title">Status 
and compiler versions</span></a></h3>

<a id="sec:cpp2-status"></a>

<p>The current interface can be entirely defined in the <code>.h</code> 
file using inlined code. This approach has a few advantages: as no C++ 
code is in the Prolog kernel, different C++ compilers with different 
name-mangling schemas can cooperate smoothly. However, inlining 
everything can lead to code bloat, so the larger functions and methods 
have been put into a <code>.cpp</code> file that can be either compiled 
separately (by the same compiler as used by the foreign predicate) or 
inlined as if it were part of the <code>.h</code> file.

<p>Also, changes to the header file have no consequences to binary 
compatibility with the SWI-Prolog kernel. This makes it possible to have 
different versions of the header file with few compatibility 
consequences.

<p>As of 2023-04, some details remain to be decided, mostly to do with 
encodings. A few methods have a <code>PlEncoding</code> optional 
parameter (e.g., <a class="func" href="#PlTerm::as_string()">PlTerm::as_string()</a>), 
but this hasn't yet been extended to all methods that take or return a 
string. Also, the details of how the default encoding is set have not 
yet been decided.

<p>As of 2023-04, the various error convenience classes do not fully 
match what the equivalent C functions do. That is, <code>throw <b>PlInstantiationError(A1)</b></code> 
does not result in the same context and traceback information that would 
happen from
<code><b>Plx_instantiation_error(A1. unwrap())</b>; throw <b>PlFail()</b></code>. 
See
<a class="sec" href="#sec:1.17.2">section 1.17.2</a>.

<p>The Plx_*() wrappers may require small adjustments in whether their 
return values require <code>[[nodiscard]]</code> or whether their return 
values should be treated as an error.

<p>The implementation of <code>PlException</code> is likely to change 
somewhat in the future. Currently, to ensure that the exception term has 
a sufficient lifetime, it is serialized using <b>PL_record_external()</b>. 
In future, if this proves unnecessary, the term will be stored as-is. 
The API will not change if this implementation detail changes.

<p><h2 id="sec:cpp2-conclusions"><a id="sec:1.18"><span class="sec-nr">1.18</span> <span class="sec-title">Conclusions</span></a></h2>

<a id="sec:cpp2-conclusions"></a>

<p>In this document, we presented a high-level interface to Prolog 
exploiting automatic type-conversion and exception-handling defined in 
C++.

<p>Programming using this interface is much more natural and requires 
only little extra resources in terms of time and memory.

<p>Especially the smooth integration between C++ and Prolog exceptions 
reduce the coding effort for type checking and reporting in foreign 
predicates.

<h1><a id="document-index">Index</a></h1>

<dl>
<dt class="index-sep">?</dt>
<dt>add/3</dt>
<dd>
<a class="idx" href="#idx:add3:34">1.7.2</a></dd>
<dt>add_num/3</dt>
<dd>
<a class="idx" href="#idx:addnum3:2">1.3</a></dd>
<dt>arg/3</dt>
<dd>
<a class="idx" href="#idx:arg3:37">1.11.4</a></dd>
<dt><a class="idx" href="#as_string()">as_string()</a></dt>
<dt><a class="idx" href="#as_wstring()">as_wstring()</a></dt>
<dt>assert</dt>
<dd>
<a class="idx" href="#idx:assert:42">1.13.1</a></dd>
<dt>at_halt/1</dt>
<dd>
<a class="idx" href="#idx:athalt1:24">1.6.8.6</a></dd>
<dt>atom_chars/2</dt>
<dd>
<a class="idx" href="#idx:atomchars2:22">1.6.6</a> <a class="idx" href="#idx:atomchars2:39">1.11.8</a></dd>
<dt><a class="idx" href="#atom_or_string_as_string()">atom_or_string_as_string()</a></dt>
<dt>atomic/1</dt>
<dd>
<a class="idx" href="#idx:atomic1:38">1.11.5</a></dd>
<dt><a class="idx" href="#atomic_as_string()">atomic_as_string()</a></dt>
<dt>average/3</dt>
<dd>
<a class="idx" href="#idx:average3:5">1.3</a> <a class="idx" href="#idx:average3:35">1.7.3</a></dd>
<dt>between/3</dt>
<dd>
<a class="idx" href="#idx:between3:15">1.3</a></dd>
<dt><a class="idx" href="#blob_data()">blob_data()</a></dt>
<dt><a class="idx" href="#call()">call()</a></dt>
<dt>can_unify/2</dt>
<dd>
<a class="idx" href="#idx:canunify2:6">1.3</a> <a class="idx" href="#idx:canunify2:44">1.13.1</a></dd>
<dt>cappend/3</dt>
<dd>
<a class="idx" href="#idx:cappend3:12">1.3</a></dd>
<dt><a class="idx" href="#check_stream()">check_stream()</a></dt>
<dt>close_my_blob/1</dt>
<dd>
<a class="idx" href="#idx:closemyblob1:23">1.6.8.6</a> <a class="idx" href="#idx:closemyblob1:25">1.6.8.6</a> <a class="idx" href="#idx:closemyblob1:29">1.6.8.6</a></dd>
<dt>create_my_blob/2</dt>
<dd>
<a class="idx" href="#idx:createmyblob2:28">1.6.8.6</a></dd>
<dt><a class="idx" href="#data()">data()</a></dt>
<dt><a class="idx" href="#duplicate()">duplicate()</a></dt>
<dt>entry/1</dt>
<dd>
<a class="idx" href="#idx:entry1:41">1.11.10</a></dd>
<dt>eq1/1</dt>
<dd>
<a class="idx" href="#idx:eq11:8">1.3</a></dd>
<dt>eq2/2</dt>
<dd>
<a class="idx" href="#idx:eq22:9">1.3</a></dd>
<dt>eq3/2</dt>
<dd>
<a class="idx" href="#idx:eq32:10">1.3</a></dd>
<dt><a class="idx" href="#erase()">erase()</a></dt>
<dt>error/2</dt>
<dd>
<a class="idx" href="#idx:error2:48">1.17.2</a></dd>
<dt>fail/0</dt>
<dd>
<a class="idx" href="#idx:fail0:20">1.5</a></dd>
<dt><a class="idx" href="#find()">find()</a></dt>
<dt>functor/3</dt>
<dd>
<a class="idx" href="#idx:functor3:4">1.3</a></dd>
<dt>happy/1</dt>
<dd>
<a class="idx" href="#idx:happy1:18">1.3</a></dd>
<dt>hello/1</dt>
<dd>
<a class="idx" href="#idx:hello1:32">1.7.1</a></dd>
<dt>int_info/2</dt>
<dd>
<a class="idx" href="#idx:intinfo2:16">1.3</a></dd>
<dt><a class="idx" href="#is_null()">is_null()</a></dt>
<dt><a class="idx" href="#is_valid()">is_valid()</a></dt>
<dt>likes/2</dt>
<dd>
<a class="idx" href="#idx:likes2:17">1.3</a></dd>
<dt>load_foreign_library/1</dt>
<dd>
<a class="idx" href="#idx:loadforeignlibrary1:45">1.14.3</a></dd>
<dt>my_blob_properties/2</dt>
<dd>
<a class="idx" href="#idx:myblobproperties2:26">1.6.8.6</a></dd>
<dt>my_file_close/1</dt>
<dd>
<a class="idx" href="#idx:myfileclose1:31">1.6.8.8</a></dd>
<dt>my_file_open/4</dt>
<dd>
<a class="idx" href="#idx:myfileopen4:30">1.6.8.8</a></dd>
<dt><a class="idx" href="#name_arity()">name_arity()</a></dt>
<dt>name_arity/3</dt>
<dd>
<a class="idx" href="#idx:namearity3:3">1.3</a></dd>
<dt><a class="idx" href="#nify_term()">nify_term()</a></dt>
<dt><a class="idx" href="#not_null()">not_null()</a></dt>
<dt>open/3</dt>
<dd>
<a class="idx" href="#idx:open3:47">1.15.1.2</a></dd>
<dt><a class="idx" href="#operator!=()">operator!=()</a></dt>
<dt><a class="idx" href="#operator<()">operator&lt;()</a></dt>
<dt><a class="idx" href="#operator<=()">operator&lt;=()</a></dt>
<dt><a class="idx" href="#operator=()">operator=()</a></dt>
<dt><a class="idx" href="#operator==()">operator==()</a></dt>
<dt><a class="idx" href="#operator>()">operator&gt;()</a></dt>
<dt><a class="idx" href="#operator>=()">operator&gt;=()</a></dt>
<dt>print_message/2</dt>
<dd>
<a class="idx" href="#idx:printmessage2:46">1.15.1</a></dd>
<dt>qsave_program/[1,2]</dt>
<dd>
<a class="idx" href="#idx:qsaveprogram12:27">1.6.8.6</a></dd>
<dt>range_cpp/3</dt>
<dd>
<a class="idx" href="#idx:rangecpp3:14">1.3</a></dd>
<dt>read/1</dt>
<dd>
<a class="idx" href="#idx:read1:40">1.11.9</a></dd>
<dt><a class="idx" href="#register_atom()">register_atom()</a></dt>
<dt><a class="idx" href="#reset()">reset()</a></dt>
<dt><a class="idx" href="#reset_term_refs()">reset_term_refs()</a></dt>
<dt><a class="idx" href="#size_tindex()">size_tindex()</a></dt>
<dt>square_roots/2</dt>
<dd>
<a class="idx" href="#idx:squareroots2:13">1.3</a></dd>
<dt><a class="idx" href="#term()">term()</a></dt>
<dt>throw/1</dt>
<dd>
<a class="idx" href="#idx:throw1:1">1.1</a> <a class="idx" href="#idx:throw1:21">1.5</a></dd>
<dt>unifiable/3</dt>
<dd>
<a class="idx" href="#idx:unifiable3:7">1.3</a></dd>
<dt><a class="idx" href="#unregister_atom()">unregister_atom()</a></dt>
<dt>use_foreign_library/1</dt>
<dd>
<a class="idx" href="#idx:useforeignlibrary1:19">1.5</a></dd>
<dt>word/1</dt>
<dd>
<a class="idx" href="#idx:word1:43">1.13.1</a></dd>
<dt><a class="idx" href="#write()">write()</a></dt>
<dt>write/1</dt>
<dd>
<a class="idx" href="#idx:write1:33">1.7.1</a> <a class="idx" href="#idx:write1:36">1.11.1</a></dd>
<dt>write_list/1</dt>
<dd>
<a class="idx" href="#idx:writelist1:11">1.3</a></dd>
<dt><a class="idx" href="#NAMED_PREDICATE()">NAMED_PREDICATE()</a></dt>
<dt><a class="idx" href="#NAMED_PREDICATE_NONDET()">NAMED_PREDICATE_NONDET()</a></dt>
<dt class="index-sep">P</dt>
<dt><a class="idx" href="#PlAtom!=()">PlAtom!=()</a></dt>
<dt><a class="idx" href="#PlAtom()">PlAtom()</a></dt>
<dt><a class="idx" href="#PlAtom==()">PlAtom==()</a></dt>
<dt><a class="idx" href="#PlAtomkey,ValueTypevalue()">PlAtomkey,ValueTypevalue()</a></dt>
<dt><a class="idx" href="#PlBlob::acquire()">PlBlob::acquire()</a></dt>
<dt><a class="idx" href="#PlBlob::compare_fields()">PlBlob::compare_fields()</a></dt>
<dt><a class="idx" href="#PlBlob::write_fields()">PlBlob::write_fields()</a></dt>
<dt><a class="idx" href="#PlBlob::PlBlob::load()">PlBlob::PlBlob::load()</a></dt>
<dt><a class="idx" href="#PlBlob::PlBlob::pre_delete()">PlBlob::PlBlob::pre_delete()</a></dt>
<dt><a class="idx" href="#PlBlob::PlBlob::save()">PlBlob::PlBlob::save()</a></dt>
<dt><a class="idx" href="#PlCall()">PlCall()</a></dt>
<dt><a class="idx" href="#PlCheckFail()">PlCheckFail()</a></dt>
<dt><a class="idx" href="#PlEx()">PlEx()</a></dt>
<dt><a class="idx" href="#PlFrame::close()">PlFrame::close()</a></dt>
<dt><a class="idx" href="#PlFrame::discard()">PlFrame::discard()</a></dt>
<dt><a class="idx" href="#PlFrame::rewind()">PlFrame::rewind()</a></dt>
<dt>PlQuery</dt>
<dd>
<a class="sec" href="#sec:1.13">1.13</a></dd>
<dt><a class="idx" href="#PlQuery::cut()">PlQuery::cut()</a></dt>
<dt><a class="idx" href="#PlQuery::next_solution()">PlQuery::next_solution()</a></dt>
<dt><a class="idx" href="#PlRecord()">PlRecord()</a></dt>
<dt><a class="idx" href="#~PlRecord()">&nbsp;PlRecord()</a></dt>
<dt><a class="idx" href="#PREDICATE()">PREDICATE()</a></dt>
<dt><a class="idx" href="#PREDICATE0()">PREDICATE0()</a></dt>
<dt><a class="idx" href="#PREDICATE_NONDET()">PREDICATE_NONDET()</a></dt>
<dt><a class="idx" href="#PlRewindOnFail()">PlRewindOnFail()</a></dt>
<dt><a class="idx" href="#PlStream::release()">PlStream::release()</a></dt>
<dt><a class="idx" href="#PlTerm!=()">PlTerm!=()</a></dt>
<dt><a class="idx" href="#PlTerm::arity()">PlTerm::arity()</a></dt>
<dt><a class="idx" href="#PlTerm::as_atom()">PlTerm::as_atom()</a></dt>
<dt><a class="idx" href="#PlTerm::as_bool()">PlTerm::as_bool()</a></dt>
<dt><a class="idx" href="#PlTerm::as_double()">PlTerm::as_double()</a></dt>
<dt><a class="idx" href="#PlTerm::as_float()">PlTerm::as_float()</a></dt>
<dt><a class="idx" href="#PlTerm::as_int()">PlTerm::as_int()</a></dt>
<dt><a class="idx" href="#PlTerm::as_int32_t()">PlTerm::as_int32_t()</a></dt>
<dt><a class="idx" href="#PlTerm::as_int64_t()">PlTerm::as_int64_t()</a></dt>
<dt><a class="idx" href="#PlTerm::as_long()">PlTerm::as_long()</a></dt>
<dt><a class="idx" href="#PlTerm::as_nil()">PlTerm::as_nil()</a></dt>
<dt><a class="idx" href="#PlTerm::as_pointer()">PlTerm::as_pointer()</a></dt>
<dt><a class="idx" href="#PlTerm::as_size_t()">PlTerm::as_size_t()</a></dt>
<dt><a class="idx" href="#PlTerm::as_string()">PlTerm::as_string()</a></dt>
<dt><a class="idx" href="#PlTerm::as_uint()">PlTerm::as_uint()</a></dt>
<dt><a class="idx" href="#PlTerm::as_uint32_t()">PlTerm::as_uint32_t()</a></dt>
<dt><a class="idx" href="#PlTerm::as_uint64_t()">PlTerm::as_uint64_t()</a></dt>
<dt><a class="idx" href="#PlTerm::as_ulong()">PlTerm::as_ulong()</a></dt>
<dt><a class="idx" href="#PlTerm::as_wstring()">PlTerm::as_wstring()</a></dt>
<dt><a class="idx" href="#PlTerm::call()">PlTerm::call()</a></dt>
<dt><a class="idx" href="#PlTerm::compare()">PlTerm::compare()</a></dt>
<dt><a class="idx" href="#PlTerm::copy_term_ref()">PlTerm::copy_term_ref()</a></dt>
<dt><a class="idx" href="#PlTerm::eq_if_atom()">PlTerm::eq_if_atom()</a></dt>
<dt><a class="idx" href="#PlTerm::free_term_ref()">PlTerm::free_term_ref()</a></dt>
<dt><a class="idx" href="#PlTerm::free_term_ref_reset()">PlTerm::free_term_ref_reset()</a></dt>
<dt><a class="idx" href="#PlTerm::get_arg()">PlTerm::get_arg()</a></dt>
<dt><a class="idx" href="#PlTerm::get_atom()">PlTerm::get_atom()</a></dt>
<dt><a class="idx" href="#PlTerm::get_atom_ex()">PlTerm::get_atom_ex()</a></dt>
<dt><a class="idx" href="#PlTerm::get_atom_nchars()">PlTerm::get_atom_nchars()</a></dt>
<dt><a class="idx" href="#PlTerm::get_attr()">PlTerm::get_attr()</a></dt>
<dt><a class="idx" href="#PlTerm::get_blob()">PlTerm::get_blob()</a></dt>
<dt><a class="idx" href="#PlTerm::get_bool()">PlTerm::get_bool()</a></dt>
<dt><a class="idx" href="#PlTerm::get_bool_ex()">PlTerm::get_bool_ex()</a></dt>
<dt><a class="idx" href="#PlTerm::get_char_ex()">PlTerm::get_char_ex()</a></dt>
<dt><a class="idx" href="#PlTerm::get_chars()">PlTerm::get_chars()</a></dt>
<dt><a class="idx" href="#PlTerm::get_compound_name_arity()">PlTerm::get_compound_name_arity()</a></dt>
<dt><a class="idx" href="#PlTerm::get_dict_key()">PlTerm::get_dict_key()</a></dt>
<dt><a class="idx" href="#PlTerm::get_file_name()">PlTerm::get_file_name()</a></dt>
<dt><a class="idx" href="#PlTerm::get_float()">PlTerm::get_float()</a></dt>
<dt><a class="idx" href="#PlTerm::get_float_ex()">PlTerm::get_float_ex()</a></dt>
<dt><a class="idx" href="#PlTerm::get_functor()">PlTerm::get_functor()</a></dt>
<dt><a class="idx" href="#PlTerm::get_head()">PlTerm::get_head()</a></dt>
<dt><a class="idx" href="#PlTerm::get_int64_ex()">PlTerm::get_int64_ex()</a></dt>
<dt><a class="idx" href="#PlTerm::get_integer()">PlTerm::get_integer()</a></dt>
<dt><a class="idx" href="#PlTerm::get_integer_ex()">PlTerm::get_integer_ex()</a></dt>
<dt><a class="idx" href="#PlTerm::get_intptr()">PlTerm::get_intptr()</a></dt>
<dt><a class="idx" href="#PlTerm::get_intptr_ex()">PlTerm::get_intptr_ex()</a></dt>
<dt><a class="idx" href="#PlTerm::get_list()">PlTerm::get_list()</a></dt>
<dt><a class="idx" href="#PlTerm::get_list_chars()">PlTerm::get_list_chars()</a></dt>
<dt><a class="idx" href="#PlTerm::get_list_ex()">PlTerm::get_list_ex()</a></dt>
<dt><a class="idx" href="#PlTerm::get_list_nchars()">PlTerm::get_list_nchars()</a></dt>
<dt><a class="idx" href="#PlTerm::get_long()">PlTerm::get_long()</a></dt>
<dt><a class="idx" href="#PlTerm::get_long_ex()">PlTerm::get_long_ex()</a></dt>
<dt><a class="idx" href="#PlTerm::get_module()">PlTerm::get_module()</a></dt>
<dt><a class="idx" href="#PlTerm::get_name_arity()">PlTerm::get_name_arity()</a></dt>
<dt><a class="idx" href="#PlTerm::get_nchars()">PlTerm::get_nchars()</a></dt>
<dt><a class="idx" href="#PlTerm::get_nil()">PlTerm::get_nil()</a></dt>
<dt><a class="idx" href="#PlTerm::get_nil_ex()">PlTerm::get_nil_ex()</a></dt>
<dt><a class="idx" href="#PlTerm::get_pointer()">PlTerm::get_pointer()</a></dt>
<dt><a class="idx" href="#PlTerm::get_pointer_ex()">PlTerm::get_pointer_ex()</a></dt>
<dt><a class="idx" href="#PlTerm::get_size_ex()">PlTerm::get_size_ex()</a></dt>
<dt><a class="idx" href="#PlTerm::get_tail()">PlTerm::get_tail()</a></dt>
<dt><a class="idx" href="#PlTerm::get_uint64_ex()">PlTerm::get_uint64_ex()</a></dt>
<dt><a class="idx" href="#PlTerm::get_wchars()">PlTerm::get_wchars()</a></dt>
<dt><a class="idx" href="#PlTerm::integer()">PlTerm::integer()</a></dt>
<dt><a class="idx" href="#PlTerm::is_acyclic()">PlTerm::is_acyclic()</a></dt>
<dt><a class="idx" href="#PlTerm::is_atom()">PlTerm::is_atom()</a></dt>
<dt><a class="idx" href="#PlTerm::is_atom_or_string()">PlTerm::is_atom_or_string()</a></dt>
<dt><a class="idx" href="#PlTerm::is_atomic()">PlTerm::is_atomic()</a></dt>
<dt><a class="idx" href="#PlTerm::is_attvar()">PlTerm::is_attvar()</a></dt>
<dt><a class="idx" href="#PlTerm::is_blob()">PlTerm::is_blob()</a></dt>
<dt><a class="idx" href="#PlTerm::is_callable()">PlTerm::is_callable()</a></dt>
<dt><a class="idx" href="#PlTerm::is_compound()">PlTerm::is_compound()</a></dt>
<dt><a class="idx" href="#PlTerm::is_dict()">PlTerm::is_dict()</a></dt>
<dt><a class="idx" href="#PlTerm::is_float()">PlTerm::is_float()</a></dt>
<dt><a class="idx" href="#PlTerm::is_functor()">PlTerm::is_functor()</a></dt>
<dt><a class="idx" href="#PlTerm::is_ground()">PlTerm::is_ground()</a></dt>
<dt><a class="idx" href="#PlTerm::is_integer()">PlTerm::is_integer()</a></dt>
<dt><a class="idx" href="#PlTerm::is_list()">PlTerm::is_list()</a></dt>
<dt><a class="idx" href="#PlTerm::is_number()">PlTerm::is_number()</a></dt>
<dt><a class="idx" href="#PlTerm::is_pair()">PlTerm::is_pair()</a></dt>
<dt><a class="idx" href="#PlTerm::is_rational()">PlTerm::is_rational()</a></dt>
<dt><a class="idx" href="#PlTerm::is_string()">PlTerm::is_string()</a></dt>
<dt><a class="idx" href="#PlTerm::is_variable()">PlTerm::is_variable()</a></dt>
<dt><a class="idx" href="#PlTerm::must_be_acyclic()">PlTerm::must_be_acyclic()</a></dt>
<dt><a class="idx" href="#PlTerm::must_be_atom()">PlTerm::must_be_atom()</a></dt>
<dt><a class="idx" href="#PlTerm::must_be_atom_or_string()">PlTerm::must_be_atom_or_string()</a></dt>
<dt><a class="idx" href="#PlTerm::must_be_atomic()">PlTerm::must_be_atomic()</a></dt>
<dt><a class="idx" href="#PlTerm::must_be_attvar()">PlTerm::must_be_attvar()</a></dt>
<dt><a class="idx" href="#PlTerm::must_be_callable()">PlTerm::must_be_callable()</a></dt>
<dt><a class="idx" href="#PlTerm::must_be_compound()">PlTerm::must_be_compound()</a></dt>
<dt><a class="idx" href="#PlTerm::must_be_dict()">PlTerm::must_be_dict()</a></dt>
<dt><a class="idx" href="#PlTerm::must_be_float()">PlTerm::must_be_float()</a></dt>
<dt><a class="idx" href="#PlTerm::must_be_ground()">PlTerm::must_be_ground()</a></dt>
<dt><a class="idx" href="#PlTerm::must_be_integer()">PlTerm::must_be_integer()</a></dt>
<dt><a class="idx" href="#PlTerm::must_be_list()">PlTerm::must_be_list()</a></dt>
<dt><a class="idx" href="#PlTerm::must_be_number()">PlTerm::must_be_number()</a></dt>
<dt><a class="idx" href="#PlTerm::must_be_pair()">PlTerm::must_be_pair()</a></dt>
<dt><a class="idx" href="#PlTerm::must_be_rational()">PlTerm::must_be_rational()</a></dt>
<dt><a class="idx" href="#PlTerm::must_be_string()">PlTerm::must_be_string()</a></dt>
<dt><a class="idx" href="#PlTerm::must_be_variable()">PlTerm::must_be_variable()</a></dt>
<dt><a class="idx" href="#PlTerm::name()">PlTerm::name()</a></dt>
<dt><a class="idx" href="#PlTerm::put_atom()">PlTerm::put_atom()</a></dt>
<dt><a class="idx" href="#PlTerm::put_atom_chars()">PlTerm::put_atom_chars()</a></dt>
<dt><a class="idx" href="#PlTerm::put_atom_nchars()">PlTerm::put_atom_nchars()</a></dt>
<dt><a class="idx" href="#PlTerm::put_blob()">PlTerm::put_blob()</a></dt>
<dt><a class="idx" href="#PlTerm::put_bool()">PlTerm::put_bool()</a></dt>
<dt><a class="idx" href="#PlTerm::put_chars()">PlTerm::put_chars()</a></dt>
<dt><a class="idx" href="#PlTerm::put_float()">PlTerm::put_float()</a></dt>
<dt><a class="idx" href="#PlTerm::put_functor()">PlTerm::put_functor()</a></dt>
<dt><a class="idx" href="#PlTerm::put_integer()">PlTerm::put_integer()</a></dt>
<dt><a class="idx" href="#PlTerm::put_list()">PlTerm::put_list()</a></dt>
<dt><a class="idx" href="#PlTerm::put_list_chars()">PlTerm::put_list_chars()</a></dt>
<dt><a class="idx" href="#PlTerm::put_list_codes()">PlTerm::put_list_codes()</a></dt>
<dt><a class="idx" href="#PlTerm::put_list_nchars()">PlTerm::put_list_nchars()</a></dt>
<dt><a class="idx" href="#PlTerm::put_list_ncodes()">PlTerm::put_list_ncodes()</a></dt>
<dt><a class="idx" href="#PlTerm::put_nil()">PlTerm::put_nil()</a></dt>
<dt><a class="idx" href="#PlTerm::put_pointer()">PlTerm::put_pointer()</a></dt>
<dt><a class="idx" href="#PlTerm::put_string_chars()">PlTerm::put_string_chars()</a></dt>
<dt><a class="idx" href="#PlTerm::put_string_nchars()">PlTerm::put_string_nchars()</a></dt>
<dt><a class="idx" href="#PlTerm::put_term()">PlTerm::put_term()</a></dt>
<dt><a class="idx" href="#PlTerm::put_variable()">PlTerm::put_variable()</a></dt>
<dt><a class="idx" href="#PlTerm::record()">PlTerm::record()</a></dt>
<dt><a class="idx" href="#PlTerm::type()">PlTerm::type()</a></dt>
<dt><a class="idx" href="#PlTerm::unify_atom()">PlTerm::unify_atom()</a></dt>
<dt><a class="idx" href="#PlTerm::unify_blob()">PlTerm::unify_blob()</a></dt>
<dt><a class="idx" href="#PlTerm::unify_bool()">PlTerm::unify_bool()</a></dt>
<dt><a class="idx" href="#PlTerm::unify_bool_ex()">PlTerm::unify_bool_ex()</a></dt>
<dt><a class="idx" href="#PlTerm::unify_chars()">PlTerm::unify_chars()</a></dt>
<dt><a class="idx" href="#PlTerm::unify_float()">PlTerm::unify_float()</a></dt>
<dt><a class="idx" href="#PlTerm::unify_functor()">PlTerm::unify_functor()</a></dt>
<dt><a class="idx" href="#PlTerm::unify_integer()">PlTerm::unify_integer()</a></dt>
<dt><a class="idx" href="#PlTerm::unify_list()">PlTerm::unify_list()</a></dt>
<dt><a class="idx" href="#PlTerm::unify_list_chars()">PlTerm::unify_list_chars()</a></dt>
<dt><a class="idx" href="#PlTerm::unify_list_codes()">PlTerm::unify_list_codes()</a></dt>
<dt><a class="idx" href="#PlTerm::unify_list_ex()">PlTerm::unify_list_ex()</a></dt>
<dt><a class="idx" href="#PlTerm::unify_nil()">PlTerm::unify_nil()</a></dt>
<dt><a class="idx" href="#PlTerm::unify_nil_ex()">PlTerm::unify_nil_ex()</a></dt>
<dt><a class="idx" href="#PlTerm::unify_pointer()">PlTerm::unify_pointer()</a></dt>
<dt><a class="idx" href="#PlTerm::unify_string()">PlTerm::unify_string()</a></dt>
<dt><a class="idx" href="#PlTerm::unify_term()">PlTerm::unify_term()</a></dt>
<dt><a class="idx" href="#PlTerm<()">PlTerm&lt;()</a></dt>
<dt><a class="idx" href="#PlTerm<=()">PlTerm&lt;=()</a></dt>
<dt><a class="idx" href="#PlTerm==()">PlTerm==()</a></dt>
<dt><a class="idx" href="#PlTerm>()">PlTerm&gt;()</a></dt>
<dt><a class="idx" href="#PlTerm>=()">PlTerm&gt;=()</a></dt>
<dt><a class="idx" href="#PlTerm\[]()">PlTerm[]()</a></dt>
<dt><a class="idx" href="#PlTerm_tail::append()">PlTerm_tail::append()</a></dt>
<dt><a class="idx" href="#PlTerm_tail::close()">PlTerm_tail::close()</a></dt>
<dt><a class="idx" href="#PlTerm_tail::next()">PlTerm_tail::next()</a></dt>
<dt><a class="idx" href="#PlTermScoped::get()">PlTermScoped::get()</a></dt>
<dt><a class="idx" href="#PlTermScoped::release()">PlTermScoped::release()</a></dt>
<dt><a class="idx" href="#PlTermScoped::reset()">PlTermScoped::reset()</a></dt>
<dt><a class="idx" href="#PlTermScoped::swap()">PlTermScoped::swap()</a></dt>
<dt><a class="idx" href="#PlTermScoped=()">PlTermScoped=()</a></dt>
<dt><a class="idx" href="#PlTerm::get_file_nameW()">PlTerm::get_file_nameW()</a></dt>
<dt><a class="idx" href="#PlWrap()">PlWrap()</a></dt>
<dt class="index-sep">T</dt>
<dt><a class="idx" href="#plThrow()">plThrow()</a></dt>
<dt class="index-sep">V</dt>
<dt><a class="idx" href="#template<ValueType,StoredValueType>AtomMap::AtomMap()">template&lt;ValueType,StoredValueType&gt;AtomMap::AtomMap()</a></dt>
<dd>
</dd>
</dl>

</body></html>