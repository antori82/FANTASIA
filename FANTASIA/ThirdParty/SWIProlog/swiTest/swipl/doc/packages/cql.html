<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
<title>Constraint Query Language A high level interface to SQL databases</title>
<style type="text/css">

/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef, dt.multidef
{ color: #fff;
padding: 2px 10px 0px 10px;
margin-bottom: 5px;
font-size: 18px;
vertical-align: middle;
overflow: hidden;
}

dt.pubdef { background-color: #0c3d6e; }
dt.multidef { background-color: #ef9439; }

.bib dd
{ margin-bottom: 1em;
}

.bib dt
{ float: left;
margin-right: 1.3ex;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{
}

span.sec-title
{
}

span.pred-ext
{ font-weight: bold;
}

span.pred-tag
{ float: right;
padding-top: 0.2em;
font-size: 80%;
font-style: italic;
color: #fff;
}

div.caption
{ width: 80%;
margin: auto;
text-align:center;
}

/* Footnotes */
.fn {
color: red;
font-size: 70%;
}

.fn-text, .fnp {
position: absolute;
top: auto;
left: 10%;
border: 1px solid #000;
box-shadow: 5px 5px 5px #888;
display: none;
background: #fff;
color: #000;
margin-top: 25px;
padding: 8px 12px;
font-size: larger;
}

sup:hover span.fn-text
{ display: block;
}

/* Lists */

dl.latex
{ margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.latex dl.latex dd.defbody
{ margin-bottom: 0.5ex;
}

/* PlDoc Tags */

dl.tags
{ font-size: 90%;
margin-left: 5ex;
margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.tags dt
{ margin-left: 0pt;
font-weight: bold;
}

dl.tags dd
{ margin-left: 3ex;
}

td.param
{ font-style: italic;
font-weight: bold;
}

/* Index */

dt.index-sep
{ font-weight: bold;
font-size: +1;
margin-top: 1ex;
}

/* Tables */

table.center
{ margin: auto;
}

table.latex
{ border-collapse:collapse;
}

table.latex tr
{ vertical-align: text-top;
}

table.latex td,th
{ padding: 2px 1em;
}

table.latex tr.hline td,th
{ border-top: 1px solid black;
}

table.frame-box
{ border: 2px solid black;
}

</style>
</head>
<body style="background:white"> 
<div class="title">Constraint Query Language A high level interface to 
SQL databases</div>
<div class="author">Mike Elston <br>
Matt Lilley <br>
E-Mail: matt.s.lilley@gmail.com</div>
<div class="abstract">
<div class="abstract-title">Abstract</div> CQL is a high level Prolog 
interface to SQL databases. It is inspired by the work of Christoph 
Draxler <cite><a class="cite" href="#Draxler:ALPUK91">Draxler, 1991</a></cite> 
in the sense that SQL queries are generated but unlike Draxler's work, 
database tables are not mapped to Prolog predicates, but database 
queries are described by Prolog terms. These terms allow for accessing 
table columns by name and provide access to several aspects of SQL that 
have no natural Prolog equivalent, such as outer joins, inserts, etc.
</div>

<h1><a id="document-contents">Table of Contents</a></h1>

<div class="toc">
<div class="toc-h2"><a class="sec" href="#sec:1"><span class="sec-nr">1</span> <span class="sec-title">library(cql/cql): 
CQL - Constraint Query Language</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.1"><span class="sec-nr">1.1</span> <span class="sec-title">Warnings 
from CQL</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.1.1"><span class="sec-nr">1.1.1</span> <span class="sec-title">CQL 
Comparisons with NULL</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.1.2"><span class="sec-nr">1.1.2</span> <span class="sec-title">Avoid <span class="pred-ext">setof/3</span> 
and <span class="pred-ext">bagof/3</span> in CQL queries</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.2"><span class="sec-nr">1.2</span> <span class="sec-title">CQL: 
Retrieved nulls have special logic to handle outer joins</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.3"><span class="sec-nr">1.3</span> <span class="sec-title">CQL: 
Getting Started Quickly</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.4"><span class="sec-nr">1.4</span> <span class="sec-title">Debugging 
CQL queries</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.5"><span class="sec-nr">1.5</span> <span class="sec-title">Prolog 
Variables in CQL queries</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.6"><span class="sec-nr">1.6</span> <span class="sec-title">CQL 
Special Attributes</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.7"><span class="sec-nr">1.7</span> <span class="sec-title">CQL 
Examples</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.1"><span class="sec-nr">1.7.1</span> <span class="sec-title">CQL 
Simple INSERT</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.2"><span class="sec-nr">1.7.2</span> <span class="sec-title">CQL 
Simple INSERT with retrieval of identity of the inserted</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.3"><span class="sec-nr">1.7.3</span> <span class="sec-title">CQL 
Simple DELETE</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.4"><span class="sec-nr">1.7.4</span> <span class="sec-title">CQL 
Simple SELECT</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.5"><span class="sec-nr">1.7.5</span> <span class="sec-title">CQL 
Simple UPDATE</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.6"><span class="sec-nr">1.7.6</span> <span class="sec-title">CQL 
WHERE with arithmetic comparison</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.7"><span class="sec-nr">1.7.7</span> <span class="sec-title">CQL 
Simple INNER JOIN</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.8"><span class="sec-nr">1.7.8</span> <span class="sec-title">CQL 
Arithmetic UPDATE with an INNER JOIN and a WHERE restriction</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.9"><span class="sec-nr">1.7.9</span> <span class="sec-title">CQL: 
Confirm row does not exist</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.10"><span class="sec-nr">1.7.10</span> <span class="sec-title">CQL: 
Aggregation - Count</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.11"><span class="sec-nr">1.7.11</span> <span class="sec-title">CQL: 
Aggregation - Sum</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.12"><span class="sec-nr">1.7.12</span> <span class="sec-title">CQL: 
Aggregation - Average</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.13"><span class="sec-nr">1.7.13</span> <span class="sec-title">CQL: 
Maximum Value</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.14"><span class="sec-nr">1.7.14</span> <span class="sec-title">CQL: 
Minimum Value</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.15"><span class="sec-nr">1.7.15</span> <span class="sec-title">CQL: 
Aggregation requiring GROUP BY</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.16"><span class="sec-nr">1.7.16</span> <span class="sec-title">CQL: 
INNER JOIN with an aggregation sub-query where the sub-query is 
constrained by a shared variable from the main query</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.17"><span class="sec-nr">1.7.17</span> <span class="sec-title">CQL: 
INNER JOIN in an aggregation sub-query</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.18"><span class="sec-nr">1.7.18</span> <span class="sec-title">CQL: 
Negation</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.19"><span class="sec-nr">1.7.19</span> <span class="sec-title">CQL: 
EXISTS</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.20"><span class="sec-nr">1.7.20</span> <span class="sec-title">CQL: 
Left Outer Join</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.21"><span class="sec-nr">1.7.21</span> <span class="sec-title">CQL: 
List-based Restrictions</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.22"><span class="sec-nr">1.7.22</span> <span class="sec-title">CQL: 
Compile time in-list constraint</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.23"><span class="sec-nr">1.7.23</span> <span class="sec-title">CQL: 
Disjunction resulting in OR in WHERE clause</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.24"><span class="sec-nr">1.7.24</span> <span class="sec-title">CQL: 
Disjunction resulting in different joins (implemented as a SQL UNION)</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.25"><span class="sec-nr">1.7.25</span> <span class="sec-title">CQL: 
Disjunction resulting in different SELECT attributes (implemented as 
separate ODBC queries)</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.26"><span class="sec-nr">1.7.26</span> <span class="sec-title">CQL: 
ORDER BY</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.27"><span class="sec-nr">1.7.27</span> <span class="sec-title">CQL: 
DISTINCT</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.28"><span class="sec-nr">1.7.28</span> <span class="sec-title">CQL: 
SELECT with NOT NULL restriction</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.29"><span class="sec-nr">1.7.29</span> <span class="sec-title">CQL: 
First N</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.30"><span class="sec-nr">1.7.30</span> <span class="sec-title">CQL: 
Self JOIN</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.31"><span class="sec-nr">1.7.31</span> <span class="sec-title">CQL: 
Removing null comparisions</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.32"><span class="sec-nr">1.7.32</span> <span class="sec-title">CQL: 
Three table JOIN</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.33"><span class="sec-nr">1.7.33</span> <span class="sec-title">CQL: 
Three table JOIN with NOLOCK locking hint</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.34"><span class="sec-nr">1.7.34</span> <span class="sec-title">CQL: 
SELECT with LIKE</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.35"><span class="sec-nr">1.7.35</span> <span class="sec-title">CQL: 
Writing exceptions directly to the database</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.36"><span class="sec-nr">1.7.36</span> <span class="sec-title">CQL: 
TOP N is Parametric</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.37"><span class="sec-nr">1.7.37</span> <span class="sec-title">CQL: 
Using <span class="pred-ext">compile_time_goal/1</span></span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.38"><span class="sec-nr">1.7.38</span> <span class="sec-title">CQL: 
ON</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.39"><span class="sec-nr">1.7.39</span> <span class="sec-title">CQL: 
Expressions In Where Restrictions</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.40"><span class="sec-nr">1.7.40</span> <span class="sec-title">CQL: 
Explicitly avoid the "No WHERE restriction" message</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.41"><span class="sec-nr">1.7.41</span> <span class="sec-title">CQL: 
HAVING</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.42"><span class="sec-nr">1.7.42</span> <span class="sec-title">CQL: 
INSERT and UPDATE value in-line formatting</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.43"><span class="sec-nr">1.7.43</span> <span class="sec-title">CQL: 
Negations in WHERE Clauses</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.44"><span class="sec-nr">1.7.44</span> <span class="sec-title">CQL: 
Predicate-generated Attribute Values</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.7.45"><span class="sec-nr">1.7.45</span> <span class="sec-title">CQL: 
INSERT from SELECT</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.8"><span class="sec-nr">1.8</span> <span class="sec-title">CQL: 
Hooks</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.8.1"><span class="sec-nr">1.8.1</span> <span class="sec-title">CQL: 
Generated Code Hooks</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.8.2"><span class="sec-nr">1.8.2</span> <span class="sec-title">CQL: 
Data Representation Hooks</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.8.3"><span class="sec-nr">1.8.3</span> <span class="sec-title">CQL: 
Application Integration</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.8.4"><span class="sec-nr">1.8.4</span> <span class="sec-title">CQL: 
Inline values</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.8.5"><span class="sec-nr">1.8.5</span> <span class="sec-title">CQL: 
Schema</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.8.6"><span class="sec-nr">1.8.6</span> <span class="sec-title">CQL: 
Event Processing and History</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.8.7"><span class="sec-nr">1.8.7</span> <span class="sec-title">CQL: 
Statistical Hooks</span></a></div>
</div>

<p><h2 id="sec:cql"><a id="sec:1"><span class="sec-nr">1</span> <span class="sec-title">library(cql/cql): 
CQL - Constraint Query Language</span></a></h2>

<p><a id="sec:cql"></a>

<p>Note that CQL is currently in a state of flux. Features may be 
dropped in future releases, and the generated SQL may change between 
releases. In particular, <i>runtime</i> mode is deprecated.

<p>CQL is a Prolog interface to SQL databases. There are two modes: <i>fully 
compiled</i> and <i>runtime</i>. The <i>fully compiled</i> mode should 
be used if possible due to the far greater compile time checking it 
provides.

<p><h3 id="sec:cql-warnings"><a id="sec:1.1"><span class="sec-nr">1.1</span> <span class="sec-title">Warnings 
from CQL</span></a></h3>

<p><a id="sec:cql-warnings"></a>

<p><h4 id="sec:cql-compare-null"><a id="sec:1.1.1"><span class="sec-nr">1.1.1</span> <span class="sec-title">CQL 
Comparisons with NULL</span></a></h4>

<p><a id="sec:cql-compare-null"></a>

<p>CQLv2 correctly compiles equality comparisons with NULL into the 
appropriate expression at runtime. In CQLv1, executing

<pre class="code">
A={null}, {[A], foo :: [a-A]}
</pre>

<p>would never succeed, regardless of the value of foo.a. This is no 
longer the case: If A is <code>{null}</code> then this will execute as <code>SELECT .... WHERE a IS NULL</code> 
and if A is not {null}, it will execute as <code>SELECT .... WHERE a = ?</code>

<p>See the section <i>Removing null comparisions</i> for the dealing 
with the common requirement to ignore comparisons with null.

<p><h4 id="sec:cql-and-setof"><a id="sec:1.1.2"><span class="sec-nr">1.1.2</span> <span class="sec-title">Avoid <span class="pred-ext">setof/3</span> 
and <span class="pred-ext">bagof/3</span> in CQL queries</span></a></h4>

<p><a id="sec:cql-and-setof"></a>

<p>It is generally not a good idea to wrap CQL inside a <span class="pred-ext">setof/3</span> 
or a
<span class="pred-ext">bagof/3</span> ... unless you are prepared to 
declare all the CQL variables that are neither bound nor mentioned in 
the setof/bagof template. If you want to sort, use <span class="pred-ext">findall/3</span> 
followed by <span class="pred-ext">sort/2</span>. Note that <span class="pred-ext">sort/2</span> 
(like
<span class="pred-ext">setof/3</span>) removes duplicates. If you don't 
want to remove duplicates, use
<span class="pred-ext">msort/2</span>.

<p><h3 id="sec:cql-null-outer-jpin"><a id="sec:1.2"><span class="sec-nr">1.2</span> <span class="sec-title">CQL: 
Retrieved nulls have special logic to handle outer joins</span></a></h3>

<p><a id="sec:cql-null-outer-jpin"></a>

<p>In the course of executing a select query, the following rules are 
applied:

<p>
<ol class="latex">
<li>Any selected attribute that is null does not bind its associated 
variable.
<li>Just before returning from the query any select variables that are 
still free are bound to {null}.
</ol>

<p>This is so we can handle outer joins. Consider this:

<pre class="code">
x :: [a-A] *== y :: [a-A]
</pre>

<p>Assume x.a binds A to a non-null value. If there is no matching row 
in
<code>y</code>, then <code>y.a = null</code>. If variable <var>A</var> 
was truly shared the query could never succeed. By not binding the 
variable associated with <code>y.a</code> the query can succeed ( rule 
1) and <var>A</var> will be bound to the value in <code>x.a</code>.

<p><h3 id="sec:cql-quickstart"><a id="sec:1.3"><span class="sec-nr">1.3</span> <span class="sec-title">CQL: 
Getting Started Quickly</span></a></h3>

<p><a id="sec:cql-quickstart"></a>

<p>Here is a simple example of a SQL SELECT from the table <code>se_lt_x</code>

<pre class="code">
test(A) :-
  format('About to call CQL with A=~w', [A]),
  {[],
  se_lt_x :: [a-A,
              b-B,
              c-C]},
  format('B=~w, C=~w', [B, C]).
</pre>

<p>
<ul class="latex">
<li>The CQL is distinguished from the ordinary Prolog by appearing in 
curly brackets
<li>Prolog variables which are ground when the CQL is executed will 
appear in the resulting SQL as part of the WHERE clause
</ul>

<p>Comparisons can be done in-line e.g.

<pre class="code">
[a-'ELSTON_M']
</pre>

<p>or with the <code>==</code> operator e.g.

<pre class="code">
[a-A], A == 'ELSTON_M'.
</pre>

<p><b>The single = operator means unify, not compare. Use = for 
unification, not comparison</b>

<p>FIXME: Unification is deprecated.

<p>The operators <code>=:=</code> and <code>\==</code> are also 
available for numerical value comparisons (they just translate to SQL <code>=</code> 
and <code>&lt;&gt;</code>, so in fact you could use them for string 
comparisons)

<p><h3 id="sec:cql-debugging"><a id="sec:1.4"><span class="sec-nr">1.4</span> <span class="sec-title">Debugging 
CQL queries</span></a></h3>

<p><a id="sec:cql-debugging"></a>

<p>You can debug CQL using the meta-predicates <span class="pred-ext">?/1</span>, <span class="pred-ext">??/2</span> 
and <span class="pred-ext">???/3</span>:

<pre class="code">
???{[], se_lt_x :: [a-A, b-_], A == 'ELSTON_M'}.
</pre>

<dl class="latex">
<dt><b><span class="pred-ext">?/1</span></b></dt>
<dd>
Display a summary form of the generated SQL before and after the goal is 
called.

<pre class="code">
[main]  CALL   SELECT slx_2.b, slx_2.a  FROM se_lt_x AS slx_2 WHERE slx_2.a = 'ELSTON_M'
[main]  EXIT   SELECT slx_2.b, slx_2.a  FROM se_lt_x AS slx_2 WHERE slx_2.a = 'ELSTON_M' (0.006963s, 0.01cpu, 3,899 inferences)
</pre>

</dd>
<dt><b><span class="pred-ext">??/1</span></b></dt>
<dd>
Display the exact query (and results) in a format which can be executed 
directly by the DBMS (In this case, SQL Server) The generated SQL may be 
significantly more complicated than expected, and this can be used to 
debug the CQL compiler itself

<pre class="code">
[main]  CALL
DECLARE @P0 VARCHAR(50);
SET @P0 = 'ELSTON_M';
SELECT slx_450.b,
       slx_450.a
FROM se_lt_x AS slx_450
WHERE slx_450.a = @P0 AND slx_450.a COLLATE Latin1_General_CS_AS = @P0
Result: se_lt_x.b = {null}
        se_lt_x.a = 'ELSTON_M'
 (0.003304s, 0.00cpu, 359 inferences)
</pre>

</dd>
<dt><b><span class="pred-ext">???/1</span></b></dt>
<dd>
Display simplified SQL before the goal is called and display the results 
afterwards

<pre class="code">
[main]  CALL
SELECT slx_450.b,
       slx_450.a
FROM se_lt_x AS slx_450
WHERE slx_450.a = 'ELSTON_M'
Result: se_lt_x.b = {null}
        se_lt_x.a = 'ELSTON_M'
 (0.003304s, 0.00cpu, 359 inferences)
</pre>

<p></dd>
</dl>

<p><h3 id="sec:cql-prolog-vars"><a id="sec:1.5"><span class="sec-nr">1.5</span> <span class="sec-title">Prolog 
Variables in CQL queries</span></a></h3>

<p><a id="sec:cql-prolog-vars"></a>

<p>A Prolog variable can be simultaneously a <i>SELECT</i> variable, a
<i>JOIN</i> variable and a <i>WHERE</i> variable as A is in the 
following example:

<pre class="code">
{[],
 se_lt_x :: [a-A, c-C]
 =*=
 se_lt_y :: [d-A, f-F],
 A == 'A4'}
</pre>

<p>which generates the following SQL

<pre class="code">
SELECT
  x_192.a, x_192.c, y_73.d, y_73.f
 FROM
  se_lt_x x_192 INNER JOIN se_lt_y y_73 ON y_73.d=x_192.a
 WHERE   x_192.a = ? and y_73.d = ?
</pre>

<p>Note how <b>all the variables referenced in the query</b> are 
retrieved in the SELECT. This is done to make the query <i>Prolog-like</i>. 
This means the retrieved row should behave like a Prolog fact so that 
when a query succeeds all the variables become instantiated.

<p>There is one notable exception however: <b>WHERE variables and JOIN 
variables are not bound in aggregation selections</b>

<p>FIXME: Is this still the case?

<pre class="code">
sum_test :-
  {[],
   #se_lt_x :: [a-ValueA,
                sum(b)-Summation]
   =*=
   #se_lt_y :: [e-ValueB],

   ValueA == ValueB,   % Explicit join point

   group_by([ValueA])},

  writeln(ValueA-ValueB-Summation).
</pre>

<pre class="code">
'ELSTON_M'-_G375971-99450
true ;
</pre>

<p><h3 id="sec:cql-special-attrs"><a id="sec:1.6"><span class="sec-nr">1.6</span> <span class="sec-title">CQL 
Special Attributes</span></a></h3>

<p><a id="sec:cql-special-attrs"></a>

<p>The following attributes are automatically provided i.e if the 
attribute is present in the table, CQL will automatically fill in the 
value:

<p>
<ol class="latex">
<li><b>generation_</b> Set to 0 on INSERT and incremented by 1 on each 
update
<li><b>inserted_</b> Set to the current time at the time of the INSERT 
transaction
<li><b>inserted_by_</b> Set to the user ID corresponding to the access 
token supplied to the transaction
<li><b>updated_</b> Set to the current time at the time of the UPDATE 
transaction. Note that updated_ is also set by an INSERT
<li><b>updated_by_</b> Set to the user ID corresponding to the access 
token supplied to the transaction. Note that updated_by_ is also set by 
an INSERT
<li><b>transaction_id_</b> Set to the transaction ID
</ol>

<p>All the special attributes can be overridden by supplying the 
attribute-value pair explicitly.

<p><h3 id="sec:cql-examples"><a id="sec:1.7"><span class="sec-nr">1.7</span> <span class="sec-title">CQL 
Examples</span></a></h3>

<p><a id="sec:cql-examples"></a>

<p>Rather than provide an abstract description of CQL syntax here is a 
set of examples that show how to use it.

<p><h4 id="sec:cql-insert"><a id="sec:1.7.1"><span class="sec-nr">1.7.1</span> <span class="sec-title">CQL 
Simple INSERT</span></a></h4>

<p><a id="sec:cql-insert"></a>

<pre class="code">
{[],
 insert(se_lt_x, [a-'A', b-'B', c-100])}
</pre>

<p><h4 id="sec:cql-insert2"><a id="sec:1.7.2"><span class="sec-nr">1.7.2</span> <span class="sec-title">CQL 
Simple INSERT with retrieval of identity of the inserted</span></a></h4>

<p><a id="sec:cql-insert2"></a>

<pre class="code">
{[],
 insert(se_lt_x, [a-'A', b-'B', c-100]),
 identity(I)}
</pre>

<p><h4 id="sec:cql-delete"><a id="sec:1.7.3"><span class="sec-nr">1.7.3</span> <span class="sec-title">CQL 
Simple DELETE</span></a></h4>

<p><a id="sec:cql-delete"></a>

<pre class="code">
{[],
 delete(se_lt_x, [x_pk-I])}
</pre>

<p>Note that the WHERE clause is part of the <span class="pred-ext">delete/2</span> 
term unlike <i>update</i> where the WHERE clause is defined outside the <span class="pred-ext">update/2</span> 
term. I could have made delete consisent with update, but this would 
have required the @ alias in the delete WHERE clause to identify the 
table where the rows are to be deleted). This seems like overkill 
because a delete can in fact refer to only one table anyway i.e. you 
can't identify rows to delete via a JOIN.

<p><h4 id="sec:cql-select"><a id="sec:1.7.4"><span class="sec-nr">1.7.4</span> <span class="sec-title">CQL 
Simple SELECT</span></a></h4>

<p><a id="sec:cql-select"></a>

<pre class="code">
{[],
 se_lt_x :: [a-A, b-B]}
</pre>

<p>This query will either:

<p>
<ul class="latex">
<li>If A is bound, and B are bound, fail if there are no such rows, or 
succeed (without binding anything) the same number of times as there are 
matching rows in se_lt_x.
<li>If A is bound and B is unbound, bind B to each of the values in
<code>se_lt_x.b</code> where <code>se_lt_x.a = A</code>
<li>If B is bound and A is unbound, bind A to each of the values in
<code>se_lt_x.a</code> where <code>se_lt_x.b = B</code>
<li>If <var>A</var> and <var>B</var> are both unbound, bind <var>A</var> 
and <var>B</var> to each of the tuples in <code>se_lt_x</code>
</ul>

<p><h4 id="sec:cql-update"><a id="sec:1.7.5"><span class="sec-nr">1.7.5</span> <span class="sec-title">CQL 
Simple UPDATE</span></a></h4>

<p><a id="sec:cql-update"></a>

<pre class="code">
{[],
 update(se_lt_x, [c-100]),
 @ :: [a-'A1'],
 row_count(N)}
</pre>

<p>This corresponds to <code>UPDATE se_lt_x SET c=100 WHERE se_lt_x.a='A1'</code>. 
The&rsquo;@&rsquo;is a special alias referring to the table that is 
being updated. The <span class="pred-ext">row_count/1</span> term gives 
the number or rows updated.

<p><h4 id="sec:cql-where-arith"><a id="sec:1.7.6"><span class="sec-nr">1.7.6</span> <span class="sec-title">CQL 
WHERE with arithmetic comparison</span></a></h4>

<p><a id="sec:cql-where-arith"></a>

<pre class="code">
{[],
 se_lt_x :: [a-A, c-C],
 C &gt; 10}
</pre>

<p><h4 id="sec:cql-inner-join"><a id="sec:1.7.7"><span class="sec-nr">1.7.7</span> <span class="sec-title">CQL 
Simple INNER JOIN</span></a></h4>

<p><a id="sec:cql-inner-join"></a>

<pre class="code">
{[],
 se_lt_x :: [a-J1, c-C]
  =*=
 se_lt_y :: [d-J1, f-F]}
</pre>

<p>The join is <code>se_lt_x.a = se_lt_y.d</code> because of the shared 
variable <var>J1</var>.
<code>se_lt_x.c</code> will be returned in <var>C</var> and <code>se_lt_y.f</code> 
will be returned in
<var>F</var>

<p><h4 id="sec:cql-update-join-where"><a id="sec:1.7.8"><span class="sec-nr">1.7.8</span> <span class="sec-title">CQL 
Arithmetic UPDATE with an INNER JOIN and a WHERE restriction</span></a></h4>

<p><a id="sec:cql-update-join-where"></a>

<pre class="code">
{[],
 update(se_lt_x, [c-(C + 2 * F + 20)]),
 @ :: [a-A, c-C] =*= se_lt_y :: [d-A, f-F],
 C &lt; 100}
</pre>

<p>This joins the table being updated (table <code>se_lt_x</code>) on 
table <code>se_lt_y</code> where <code>se_lt_x.a = se_lt_y.a</code> and 
where <code>se_lt_x.c &lt; 200</code> then updates each identified row <code>se_lt_x.c</code> 
with the specified expression.

<p><h4 id="sec:cql-not-exists"><a id="sec:1.7.9"><span class="sec-nr">1.7.9</span> <span class="sec-title">CQL: 
Confirm row does not exist</span></a></h4>

<p><a id="sec:cql-not-exists"></a>

<pre class="code">
\+ exists {[], se_lt_x :: [a-'Z']}
</pre>

<p><h4 id="sec:cql-count"><a id="sec:1.7.10"><span class="sec-nr">1.7.10</span> <span class="sec-title">CQL: 
Aggregation - Count</span></a></h4>

<p><a id="sec:cql-count"></a>

<pre class="code">
{[],
 se_lt_x :: [count(c)-C]}
</pre>

<p>This will count the rows in table se_lt_x

<p><h4 id="sec:cql-sum"><a id="sec:1.7.11"><span class="sec-nr">1.7.11</span> <span class="sec-title">CQL: 
Aggregation - Sum</span></a></h4>

<p><a id="sec:cql-sum"></a>

<pre class="code">
{[],
 se_lt_x :: [sum(c)-C]}
</pre>

<p>Sum the values of attribute c in table se_lt_x

<p><h4 id="sec:cql-avg"><a id="sec:1.7.12"><span class="sec-nr">1.7.12</span> <span class="sec-title">CQL: 
Aggregation - Average</span></a></h4>

<p><a id="sec:cql-avg"></a>

<pre class="code">
{[],
 se_lt_x :: [avg(c)-C]}
</pre>

<p>Calculate the mean of the values of attribute c in table se_lt_x

<p><h4 id="sec:cql-max"><a id="sec:1.7.13"><span class="sec-nr">1.7.13</span> <span class="sec-title">CQL: 
Maximum Value</span></a></h4>

<p><a id="sec:cql-max"></a>

<pre class="code">
{[],
 se_lt_x :: [max(c)-C]}
</pre>

<p>Calculate the maximum of the values of attribute c in table se_lt_x

<p><h4 id="sec:cql-min"><a id="sec:1.7.14"><span class="sec-nr">1.7.14</span> <span class="sec-title">CQL: 
Minimum Value</span></a></h4>

<p><a id="sec:cql-min"></a>

<pre class="code">
{[],
 se_lt_x :: [min(c)-C]}
</pre>

<p>Calculate the minimum of the values of attribute c in table se_lt_x

<p><h4 id="sec:cql-group-by"><a id="sec:1.7.15"><span class="sec-nr">1.7.15</span> <span class="sec-title">CQL: 
Aggregation requiring GROUP BY</span></a></h4>

<p><a id="sec:cql-group-by"></a>

<pre class="code">
{[],
 se_lt_z :: [g-G, sum(i)-I],
 group_by([G])}
</pre>

<p>This will generate the <code>GROUP BY SQL</code> and sum <code>se_lt_z.i</code> 
for each value of <code>se_lt_z.g</code>

<p><h4 id="sec:cql-agg-subquery"><a id="sec:1.7.16"><span class="sec-nr">1.7.16</span> <span class="sec-title">CQL: 
INNER JOIN with an aggregation sub-query where the sub-query is 
constrained by a shared variable from the main query</span></a></h4>

<p><a id="sec:cql-agg-subquery"></a>

<pre class="code">
{[],
 se_lt_x :: [b-J1, a-A]
   =*=
 se_lt_z :: [h-J1, i-I, g-Z],
 I &gt; min(Y, se_lt_y :: [f-Y, d-Z])}
</pre>

<p>The main query and the sub-query share variable Z. The generated SQL 
is:

<pre class="code">
SELECT
  x37.a, z4.i, z4.g
 FROM
  se_lt_x x37 INNER JOIN se_lt_z z4 ON x37.b=z4.h and z4.h=x37.b
 WHERE
  z4.i &gt; (SELECT min(y11.f) FROM se_lt_y y11 WHERE z4.g=y11.d)
</pre>

<p><h4 id="sec:cql-join-subquery"><a id="sec:1.7.17"><span class="sec-nr">1.7.17</span> <span class="sec-title">CQL: 
INNER JOIN in an aggregation sub-query</span></a></h4>

<p><a id="sec:cql-join-subquery"></a>

<pre class="code">
{[],
 se_lt_y :: [d-D,f-F],
 F &lt; sum(I,
         se_lt_x :: [b-J1]
           =*=
         se_lt_z :: [h-J1, i-I])}
</pre>

<p><h4 id="sec:cql-negation"><a id="sec:1.7.18"><span class="sec-nr">1.7.18</span> <span class="sec-title">CQL: 
Negation</span></a></h4>

<p><a id="sec:cql-negation"></a>

<pre class="code">
{[],
 se_lt_x :: [a-A, b-B],
 \+ exists se_lt_y :: [d-A]}
</pre>

<p>The generated SQL is:

<pre class="code">
SELECT
  x39.a, x39.b
 FROM
  se_lt_x x39
 WHERE NOT EXISTS (SELECT * FROM se_lt_y y13 WHERE x39.a = y13.d)
</pre>

<p><h4 id="sec:cql-exists"><a id="sec:1.7.19"><span class="sec-nr">1.7.19</span> <span class="sec-title">CQL: 
EXISTS</span></a></h4>

<p><a id="sec:cql-exists"></a>

<p>An exists restriction translates to a <code>WHERE</code> sub-query 
and is used to say that "each row returned in the main query must 
satisfy some condition expressed by another query".

<p><b>Example</b>

<pre class="code">
{[],
 se_lt_x :: [a-A, b-B],
 exists se_lt_y :: [d-A]}
</pre>

<p>compiles to:

<pre class="code">
SELECT
  x.b, x.a
FROM
  se_lt_x x
WHERE
  EXISTS (SELECT * FROM se_lt_y WHERE x.a = y.d)
</pre>

<p><h4 id="sec:cql-left-outer-join"><a id="sec:1.7.20"><span class="sec-nr">1.7.20</span> <span class="sec-title">CQL: 
Left Outer Join</span></a></h4>

<p><a id="sec:cql-left-outer-join"></a>

<pre class="code">
se_lt_x :: [a-J1, b-B]
  *==
se_lt_y :: [d-J1, e-E]}
</pre>

<p><h4 id="sec:cql-list-restrictions"><a id="sec:1.7.21"><span class="sec-nr">1.7.21</span> <span class="sec-title">CQL: 
List-based Restrictions</span></a></h4>

<p><a id="sec:cql-list-restrictions"></a>

<p>CQL supports query restrictions based on lists. Note that in both 
cases
<b><code>\==</code> <code>[]</code> and <code>==</code> <code>[]</code> 
are equivalent</b> despite the obvious logical inconsistency.

<p>FIXME: Can we make this behaviour be controlled by a flag? It IS 
quite useful, even if it is completely illogical

<pre class="code">
{[], se_lt_x :: [a-Bar], Bar == []}
</pre>

<p>and

<pre class="code">
{[], se_lt_x :: [a-Bar], Bar \== []}
</pre>

<p>both do <b>exactly</b> the same thing - they will not restrict the 
query based on Bar. The second case seems to be logically consistent - 
all things are not in the empty list.

<p><h4 id="sec:cql-list-compilation"><a id="sec:1.7.22"><span class="sec-nr">1.7.22</span> <span class="sec-title">CQL: 
Compile time in-list constraint</span></a></h4>

<p><a id="sec:cql-list-compilation"></a>

<p>If your list is bound at compile-time, you can simply use it as the 
attribute value in CQL, for example:

<pre class="code">
{[], se_lt_x :: [a-['ELSTON_M', 'LILLEY_N']]}
</pre>

<p>This does not require the list to be <b>ground</b>, merely <b>bound</b>. 
For example, this is not precluded:

<pre class="code">
foo(V1, V2):-
    {[], se_lt_x :: [a-[V1, V2]]}.
</pre>

<p>If, however, your list is not bound at compile-time, you must wrap 
the variable in <span class="pred-ext">list/1</span>:

<pre class="code">
Bar = [a,b,c],
{[], se_lt_x :: [bar-list(Bar)]}
</pre>

<p>If you write

<pre class="code">
foo(V1):-
    {[], se_lt_x :: [a-V1]}.
</pre>

<p>and at runtime call <code>foo([value1])</code>, you will get a type 
error.

<p><i>Remember:</i> If the list of IN values is <i>empty</i> then no 
restriction is generated i.e.

<pre class="code">
{[], se_lt_x :: [a-[], b-B}

is the exactly the same as

{[], se_lt_x :: [b-B}
</pre>

<p><h4 id="sec:cql-disjunction"><a id="sec:1.7.23"><span class="sec-nr">1.7.23</span> <span class="sec-title">CQL: 
Disjunction resulting in OR in WHERE clause</span></a></h4>

<p><a id="sec:cql-disjunction"></a>

<pre class="code">
{[],
 se_lt_x :: [a-A, b-B, c-C],
 (C == 10 ; B == 'B2', C &lt; 4)}
</pre>

<p>The generated SQL is:

<pre class="code">
SELECT
  x.a, x.b, x.c
 FROM
  se_lt_x x
 WHERE
  ((x.b = ? AND x.c &lt; ?) OR x.c = ?)
</pre>

<p><h4 id="sec:cql-disj-diff-joins"><a id="sec:1.7.24"><span class="sec-nr">1.7.24</span> <span class="sec-title">CQL: 
Disjunction resulting in different joins (implemented as a SQL UNION)</span></a></h4>

<p><a id="sec:cql-disj-diff-joins"></a>

<pre class="code">
{[],
 se_lt_x :: [a-A, c-C]
 =*=
 (se_lt_y :: [d-A] ; se_lt_z :: [g-A])}
</pre>

<p>The generated SQL is:

<pre class="code">
SELECT
  x43.c
 FROM
  (se_lt_x x43 INNER JOIN se_lt_z z6 ON x43.a=z6.g AND z6.g=x43.a)

UNION

SELECT
  x44.c
 FROM
  (se_lt_x x44 INNER JOIN se_lt_y y16 ON x44.a=y16.d AND y16.d=x44.a)
</pre>

<p><h4 id="sec:cql-disj-attrs"><a id="sec:1.7.25"><span class="sec-nr">1.7.25</span> <span class="sec-title">CQL: 
Disjunction resulting in different SELECT attributes (implemented as 
separate ODBC queries)</span></a></h4>

<p><a id="sec:cql-disj-attrs"></a>

<pre class="code">
{[],
 (se_lt_x :: [a-A, c-10]
 ;
 se_lt_y :: [d-A, f-25])}
</pre>

<p>The output variable A is bound to the value from two different 
attributes and so the query is implemented as two separate ODBC queries

<p><h4 id="sec:cql-order-by"><a id="sec:1.7.26"><span class="sec-nr">1.7.26</span> <span class="sec-title">CQL: 
ORDER BY</span></a></h4>

<p><a id="sec:cql-order-by"></a>

<pre class="code">
{[],
 se_lt_z :: [g-G, h-H],
 order_by([-G])}
</pre>

<p>The order_by specification is a list of "signed" variables. The 
example above will order by se_lt_z.g descending

<p><h4 id="sec:cql-distinct"><a id="sec:1.7.27"><span class="sec-nr">1.7.27</span> <span class="sec-title">CQL: 
DISTINCT</span></a></h4>

<p><a id="sec:cql-distinct"></a>

<p>Use <code>distinct(ListOfVars)</code> to specify which attributes you 
want to be distinct:

<pre class="code">
test_distinct :-
  findall(UserName,
          {[],
           se_lt_x :: [a-UserName,
                       c-Key],
           Key &gt;= 7,
           distinct([UserName])},
          L),
  length(L, N),
  format('~w solutions~n', [N]).

CALL  : user:test_distinct/0
26 solutions
EXIT  : user:test_distinct/0 (0.098133s, 0.00cpu, 1,488 inferences)
</pre>

<p><h4 id="sec:cql-select-not-null"><a id="sec:1.7.28"><span class="sec-nr">1.7.28</span> <span class="sec-title">CQL: 
SELECT with NOT NULL restriction</span></a></h4>

<p><a id="sec:cql-select-not-null"></a>

<pre class="code">
{[],
 se_lt_z :: [i-I, j-J],
 J \== {null}}
</pre>

<p><h4 id="sec:cql-top"><a id="sec:1.7.29"><span class="sec-nr">1.7.29</span> <span class="sec-title">CQL: 
First N</span></a></h4>

<p><a id="sec:cql-top"></a>

<pre class="code">
{[],
 N = 3,
 se_lt_z :: [i-I],
 top(N),
 order_by([+I])}
</pre>

<p>This generates a TOP clause in SQL Server, and LIMIT clauses for 
PostgreSQL and SQLite

<p><h4 id="sec:cql-self-join"><a id="sec:1.7.30"><span class="sec-nr">1.7.30</span> <span class="sec-title">CQL: 
Self JOIN</span></a></h4>

<p><a id="sec:cql-self-join"></a>

<pre class="code">
{[],
 se_lt_z :: [h-H, i-I1]
  =*=
 se_lt_z :: [h-H, i-I2],
 I1 \== I2}
</pre>

<p><h4 id="sec:cql-no-null-compare"><a id="sec:1.7.31"><span class="sec-nr">1.7.31</span> <span class="sec-title">CQL: 
Removing null comparisions</span></a></h4>

<p><a id="sec:cql-no-null-compare"></a>

<p>Use the ignore_if_null wrapper in your CQL to&rsquo;filter out&rsquo;null 
input values. This is a useful extension for creating user-designed 
searches.

<pre class="code">
{[],
 se_lt_x :: [a-UserName,
             b-ignore_if_null(SearchKey),
             ...]}
</pre>

<p>At runtime, if SearchKey is bound to a value other than {null} then 
the query will contain <code>WHERE ... b = ?</code>. If, however, 
SearchKey is bound to <code>{null}</code>, then this comparison will be 
omitted.

<p><b>Disjunctions</b>

<p>In general, don't use ignore_if_null in disjunctions. Consider this 
query:

<pre class="code">
SearchKey = '%ELSTON%',
{[],
 se_lt_x :: [a-UserName,
             b-RealName],
 ( RealName =~ SearchKey
 ; UserName =~ SearchKey)}
</pre>

<p>The query means "find a user where the UserName contains ELSTON OR 
the RealName contain ELSTON". If !SearchKey is {null} then RealName=<code>~</code> {null} 
will fail, which is correct. If ignore_if_null was used, the test would
<i>succeed</i>, which means the disjunction would always succeed i.e. 
the query would contain no restriction, which is clearly not the 
intended result. FIXME: Mike, what is this all about?

<p><h4 id="sec:cql-three-table-join"><a id="sec:1.7.32"><span class="sec-nr">1.7.32</span> <span class="sec-title">CQL: 
Three table JOIN</span></a></h4>

<p><a id="sec:cql-three-table-join"></a>

<pre class="code">
{[],
 se_lt_x :: [a-A, c-C]
  =*=
 se_lt_y :: [d-A, f-F]
  =*=
 se_lt_z :: [i-F, g-G]}
</pre>

<p>The shared variable A joins <code>se_lt_x</code> and <code>se_lt_y</code>; 
the shared variable
<var>F</var> joins <code>se_lt_y</code> and <code>se_lt_z</code>

<p><h4 id="sec:cql-three-nolock"><a id="sec:1.7.33"><span class="sec-nr">1.7.33</span> <span class="sec-title">CQL: 
Three table JOIN with NOLOCK locking hint</span></a></h4>

<p><a id="sec:cql-three-nolock"></a>

<pre class="code">
{[],
 se_lt_x :: [a-A, c-C]
  =*=
 #se_lt_y :: [d-A, f-F]
  =*=
 #se_lt_z :: [i-F, g-G]}
</pre>

<p>The hash operator indicates the table that should be accessed WITH 
(NOLOCK)

<p><h4 id="sec:cql-like"><a id="sec:1.7.34"><span class="sec-nr">1.7.34</span> <span class="sec-title">CQL: 
SELECT with LIKE</span></a></h4>

<p><a id="sec:cql-like"></a>

<pre class="code">
{[],
 se_lt_z :: [g-G, i-I],
 G =~ 'A_'}
</pre>

<p>The operator =<code>~</code> means LIKE. If you are using PostgreSQL, 
it means ILIKE.

<p><h4 id="sec:cql-write"><a id="sec:1.7.35"><span class="sec-nr">1.7.35</span> <span class="sec-title">CQL: 
Writing exceptions directly to the database</span></a></h4>

<p><a id="sec:cql-write"></a>

<p>You can write an exception term directly to a varchar-type column in 
the database. Note that it will be rendered as text using <code>~</code>p, 
and truncated if necessary - so you certainly can't read it out again 
and expect to get an exception! Example code:

<pre class="code">
catch(process_message(Message),
      Exception,
      {[],
      update(some_table, [status-'ERROR',
                          status_comment-Exception]),
      @ :: [some_table_primary_key-PrimaryKey]}).
</pre>

<p>FIXME: This code is specific to my usage of CQL

<p><h4 id="sec:cql-top-n-parametric"><a id="sec:1.7.36"><span class="sec-nr">1.7.36</span> <span class="sec-title">CQL: 
TOP N is Parametric</span></a></h4>

<p><a id="sec:cql-top-n-parametric"></a>

<p>You can pass the "N" is TOP N as a parameter (Subject to DBMS 
compatibility. This works in SQL Server 2005 and later, and PostgreSQL 9 
(possibly earlier versions) and SQLite3.

<pre class="code">
N = 3,
findall(I,
        {[],
         se_lt_z :: [i-I], top(N), order_by([+I])},
        L)
</pre>

<p><h4 id="sec:cql-compile-time-goal"><a id="sec:1.7.37"><span class="sec-nr">1.7.37</span> <span class="sec-title">CQL: 
Using <span class="pred-ext">compile_time_goal/1</span></span></a></h4>

<p><a id="sec:cql-compile-time-goal"></a>

<p>You can include <code>compile_time_goal(Goal)</code> in your CQL. If 
you specify a module, it will be used, otherwise the goal will be called 
in the current module. Note that the goal is executed in-order - if you 
want to use the bindings in your CQL, you must put the compile_time_goal 
before them.

<p><b>Example 1</b>

<pre class="code">
{[],
 se_lt_x :: [a-UserName,
             b-RealName,
             d-FavouriteColour],
   compile_time_goal(standard_batch_size_for_search(StandardBatchSize)),
   top(StandardBatchSize),
   order_by([+UserName]}
</pre>

<p><b>Example 2</b>

<pre class="code">
excellent_colours(['RED', 'BLUE']).

{[],
 se_lt_x :: [a-UserName,
             b-RealName,
             d-FavouriteColour],
 compile_time_goal(excellent_colours(Colours)),
 FavouriteColour == Colours}
</pre>

<p><h4 id="sec:cql-on"><a id="sec:1.7.38"><span class="sec-nr">1.7.38</span> <span class="sec-title">CQL: 
ON</span></a></h4>

<p><a id="sec:cql-on"></a>

<p>CQL supports both constant and shared variable join specifications. 
This is particularly useful when specifying outer joins.

<p><b>Example</b>

<pre class="code">
{[],
 se_lt_x :: [a-UserNameA,
             b-RealName,
             d-FavouriteColour]
 *==
 se_lt_x :: [a-UserNameB,
             e-FavouriteFood] on( UserNameA == UserNameB,
                                  FavouriteColour == FavouriteFood,
                                  FavouriteFood == 'ORANGE')}
</pre>

<p>All the CQL comparison operators, <code>&lt;, =&lt;, ==, =~, \=~, \==, &gt;=, &gt;</code> 
can be used in ON specifications.

<p>For example:

<pre class="code">
{[],
 se_lt_z :: [i-J1, k-K]
 *==
 se_lt_x :: [c-J1, a-A, b-B] on A \== 'A1'},
</pre>

<p><h4 id="sec:cql-expr-in-where"><a id="sec:1.7.39"><span class="sec-nr">1.7.39</span> <span class="sec-title">CQL: 
Expressions In Where Restrictions</span></a></h4>

<p><a id="sec:cql-expr-in-where"></a>

<p>Expressions in WHERE restrictions are supported, for example:

<pre class="code">
{[],
 se_lt_n :: [i-I, j-J, k-K],
 J &gt; 10 * (K / I) + 15},
</pre>

<p><h4 id="sec:cql-no-where"><a id="sec:1.7.40"><span class="sec-nr">1.7.40</span> <span class="sec-title">CQL: 
Explicitly avoid the "No WHERE restriction" message</span></a></h4>

<p><a id="sec:cql-no-where"></a>

<p>To avoid accidentally deleting or updating all rows in a table CQL 
raises an exception if there is no WHERE restriction.

<p>Sometimes however you really do need to delete or update all rows in 
a table.

<p>To support this requirement in a disciplined way (and to avoid the 
creation of "dummy" WHERE restrictions) the keyword
<b>absence_of_where_restriction_is_deliberate</b> has been added. For 
example:

<pre class="code">
{[],
 update(se_lt_x, [c-10]),
        @ :: [],
        absence_of_where_restriction_is_deliberate}
</pre>

<p><h4 id="sec:cql-having"><a id="sec:1.7.41"><span class="sec-nr">1.7.41</span> <span class="sec-title">CQL: 
HAVING</span></a></h4>

<p><a id="sec:cql-having"></a>

<p>HAVING restrictions can be specified. For example:

<pre class="code">
{[],
 se_lt_z :: [sum(i)-I,
             g-G],
 group_by([G]),
 having(I &gt; 30)}
</pre>

<p>For a description of HAVING see
<a class="url" href="http://en.wikipedia.org/wiki/Having_(SQL)">http://en.wikipedia.org/wiki/Having_(SQL)</a>

<p>There is one important difference between SQL HAVING and SQL WHERE 
clauses. The SQL WHERE clause condition is tested against <b>each and 
every</b> row of data, while the SQL HAVING clause condition is tested 
against the <i>groups and/or aggregates specified in the SQL GROUP BY 
clause and/or the SQL SELECT column list</i>.

<p><h4 id="sec:cql-inst-update-value"><a id="sec:1.7.42"><span class="sec-nr">1.7.42</span> <span class="sec-title">CQL: 
INSERT and UPDATE value in-line formatting</span></a></h4>

<p><a id="sec:cql-inst-update-value"></a>

<p>INSERT and UPDATE values can be formatted in-line at runtime. For 
example:

<pre class="code">
Suffix = 'NOGG',
cql_transaction(Schema, UserId,
                {[],
                insert(se_lt_x, [a-'A', b-'B', c-100, d-format('EGG_~w', [Suffix])])}),
</pre>

<p>will insert&rsquo;EGG_NOGG&rsquo;into attribute&rsquo;d&rsquo;.

<p><h4 id="sec:cql-neg-where"><a id="sec:1.7.43"><span class="sec-nr">1.7.43</span> <span class="sec-title">CQL: 
Negations in WHERE Clauses</span></a></h4>

<p><a id="sec:cql-neg-where"></a>

<p>You can specify negations in CQL WHERE clauses e.g.

<pre class="code">
{[],
 se_lt_z :: [g-G, h-H, i-I],
 \+((G == 'A1', H == 'B1' ; G == 'D1', H == 'B3'))},
</pre>

<p>Note that, just like in Prolog, <code>\+</code> is a unary operator 
hence the "double" brackets in the example above.

<p><h4 id="sec:cql-gen-att-values"><a id="sec:1.7.44"><span class="sec-nr">1.7.44</span> <span class="sec-title">CQL: 
Predicate-generated Attribute Values</span></a></h4>

<p><a id="sec:cql-gen-att-values"></a>

<p>It is possible to generate <b>compile time</b> attribute values by 
specifying a <i>predicate</i> which is executed when the CQL statement 
is compiled.

<p>The predicate must return the value you want as its last argument. 
You specify the predicate where you would normally put the attribute 
value. The predicate is specified <i>with its output argument missing</i>.

<p><b>Example</b> - Using domain allowed values in a query.

<p>In the following CQL statement the predicate <span class="pred-ext">cql_domain_allowed_value/3</span> 
is called within <span class="pred-ext">findall/3</span> <b>at compile 
time</b> to generate a list of domain values that restrict 
favourite_colour to be&rsquo;ORANGE&rsquo;or&rsquo;PINK&rsquo;or&rsquo;BLUE&rsquo;, 
or&rsquo;GREEN&rsquo;.

<pre class="code">
colour('ORANGE').
colour('PINK').
colour('BLUE').
colour('GREEN').

{[],
 se_lt_x :: [d-findall(Value,
                       permissible_colour(Value)),
             a-UserName]}
</pre>

<p>Note how <span class="pred-ext">findall/3</span> is actually called 
by specifying <span class="pred-ext">findall/2</span>.

<p>There is not much point using predicate-generated attribute values in 
compile-at-runtime CQL as you can always call the predicate to generate 
the required values <i>outside</i> the CQL statement.

<p><h4 id="sec:cql-insert-from-select"><a id="sec:1.7.45"><span class="sec-nr">1.7.45</span> <span class="sec-title">CQL: 
INSERT from SELECT</span></a></h4>

<p><a id="sec:cql-insert-from-select"></a>

<p>INSERT from SELECT is supported:

<pre class="code">
Constant = 'MIKE',
{[],
 insert(se_lt_x1, [x_pk-Pk, a-A, b-B, c-C, d-Constant]),
 se_lt_x :: [x_pk-Pk, a-A, b-B, c-C, as(d)-Constant]}
</pre>

<p>which generates the following SQL:

<pre class="code">
INSERT INTO se_lt_x1 (x_pk, a, b, c, d)
SELECT se_lt_x_955.x_pk, se_lt_x_955.a, se_lt_x_955.b, se_lt_x_955.c, ? AS d
  FROM se_lt_x lt_x_955
</pre>

<p>Note the use of the <code>as(d)</code> construct in the SELECT part 
of the CQL to make the constant <b>&rsquo;MIKE&rsquo;</b> appear to come 
from the SELECT thus setting
<code>lt_x1.d</code> to <b>&rsquo;MIKE&rsquo;</b> in every row inserted.

<p><h3 id="sec:cql-hooks"><a id="sec:1.8"><span class="sec-nr">1.8</span> <span class="sec-title">CQL: 
Hooks</span></a></h3>

<p><a id="sec:cql-hooks"></a>

<p>CQL provides a large number of hooks to fine-tune behaviour and allow 
for customization. These are:

<p><h4 id="sec:cql-code-hooks"><a id="sec:1.8.1"><span class="sec-nr">1.8.1</span> <span class="sec-title">CQL: 
Generated Code Hooks</span></a></h4>

<p><a id="sec:cql-code-hooks"></a>

<p>
<ul class="latex">
<li>cql:<code>cql_dependency_hook(+EntitySet, +Module)</code> can be 
defined to be notified when a given Module references a list of database 
entities. This can be used to manage metadata/code dependency
<li>cql:<code>cql_generated_sql_hook(+Filename, +LineNumber, +Goals)</code> 
can be defined to examine generated SQL. Use <code>cql_sql_clause(+Goals, -SQL, -Parameters)</code> 
to examine the goals
<li>cql:<code>cql_index_suggestion_hook(+Index)</code> can be defined if 
you are interested in proposed indices for your schema. Note that this 
is not very mature (yet)
</ul>

<p><h4 id="sec:cql-represent-hooks"><a id="sec:1.8.2"><span class="sec-nr">1.8.2</span> <span class="sec-title">CQL: 
Data Representation Hooks</span></a></h4>

<p><a id="sec:cql-represent-hooks"></a>

<p>
<ul class="latex">
<li>cql:<code>cql_atomic_value_check_hook(+Value)</code> can be defined 
to declare new&rsquo;atomic&rsquo;types (That is, types which can be 
written directly to the database), such as a representation like <code>boolean(true)</code> 
for 1.
<li>cql:<code>cql_check_value_hook(+Value)</code> can be used to check 
that a value is legal
<li>cql:<code>application_value_to_odbc_value_hook(+OdbcDataType, +Schema, +TableName, +ColumnName, +Qualifiers, +ApplicationValue, -OdbcValue)</code>.
<li>cql:<code>odbc_value_to_application_value_hook(+OdbcDataType, +Schema, +TableName, +ColumnName, +Domain, +OdbcValue, -ApplicationValue)</code>.
</ul>

<p><h4 id="sec:cql-appl-hooks"><a id="sec:1.8.3"><span class="sec-nr">1.8.3</span> <span class="sec-title">CQL: 
Application Integration</span></a></h4>

<p><a id="sec:cql-appl-hooks"></a>

<p>
<ul class="latex">
<li>cql:<code>cql_access_token_hook(+AccessToken, -UserId)</code> can be 
defined to map the generic&rsquo;AccessToken&rsquo;passed to <span class="pred-ext">cql_transaction/3</span> 
to a user ID. If not defined, the AccessToken is assumed to be the user 
ID. This UserID is used in logging.
<li>cql:log_selects can be defined if you want to receive logging 
information about selects. By default only update, delete and insert are 
logged
<li>cql:<code>cql_execution_hook(+Statement, +OdbcParameters, +OdbcParameterDataTypes, -Row)</code> 
can be defined if you want to implement the exeuction yourself (for 
example, to add extra debugging)
<li>cql:<code>cql_log_hook(+Topics, +Level, +Format, +Args)</code> can 
be defined to redirect CQL logging.

<p>
<ul class="latex">
<li>Levels is one of informational, warning, or error
<li>Topics is a list of topics. Currently the only lists possible are <code>[]</code> 
and [<code>debug(deadlocks)</code>]
</ul>

<p>
<li>cql:<code>sql_gripe_hook(+Level, +Format, +Args)</code> is called 
when suspect SQL is found by the SQL parser
<li>cql:<code>cql_normalize_atom_hook(+DBMS, +ApplciationAtom, -DBMSAtom)</code> 
can be used to create a map for atoms in a specific DBMS. For example, 
your schema may have arbitrarily long table names, but your DBMS may 
only allow names up to 64 bytes long. In this case, you can create a 
scheme for mapping the application-level atom to the DBMS. Other uses 
include deleting or normalizing illegal characters in names
<li>cql:<code>cql_error_hook(+ErrorId, +Format, +Args)</code> can be 
defined to generate a specific exception term from the given arguments. 
If not defined (or if it does not throw an exception, or fails), you 
will get <code>cql_error(ErrorId, FormattedMessage)</code>.
<li>cql:<code>cql_max_db_connections_hook(-Max)</code> can be defined to 
limit the number of simultaneous connections each thread will attempt to 
have
<li>cql:<code>odbc_connection_complete_hook(+Schema, +Details, +Connection)</code> 
can be hooked if you want to know every time a connection is made
<li>cql:<code>cql_transaction_info_hook(+AccessToken, +Connection, +DBMS, +Goal, -Info)</code> 
can be defined if you want to define any application-defined information 
on a per-transaction level. This can be recovered via
<code>database_transaction_query_info(?ThreadId, ?Goal, ?Info)</code>.
</ul>

<p><h4 id="sec:cql-inline-hooks"><a id="sec:1.8.4"><span class="sec-nr">1.8.4</span> <span class="sec-title">CQL: 
Inline values</span></a></h4>

<p><a id="sec:cql-inline-hooks"></a>

<dl class="latex">
<dt><var><code>cql</code></var><strong><code>:</code></strong><var><code>cql_inline_domain_value_hook(+DomainName, 
+Value)</code></var></dt>
<dd class="defbody">
can be defined if you want the given value to be&rsquo;inlined&rsquo;into 
the CQL (ie not supplied as a parameter). Great care must be taken to 
avoid SQL injection attacks if this is used.
</dd>
</dl>

<p><h4 id="sec:cql-shema-hook"><a id="sec:1.8.5"><span class="sec-nr">1.8.5</span> <span class="sec-title">CQL: 
Schema</span></a></h4>

<p><a id="sec:cql-shema-hook"></a>

<p>These define the schema. You MUST either define them, or include
<code>library(cql/cql_autoschema)</code> and add two directives to build 
the schema automatically:

<p>
<ul class="compact">
<li><code>:-</code><code>register_database_connection_details(+Schema, +ConnectionInfo)</code>.
<li><code>:-</code><code>build_schema(+Schema)</code>.
</ul>

<p>Otherwise, you need to define at least <span class="pred-ext">cql:default_schema/1</span> 
and
<span class="pred-ext">cql:dbms/2</span>, and then as many of the other 
facts as needed for your schema.

<p>
<ul class="latex">
<li>cql:<code>default_schema(-Schema)</code> MUST be defined. CQL 
autoschema will define this for you if you use it.
<li>cql:<code>dbms(+Schema, -DBMS)</code> MUST be defined for every 
schema you use. CQL autoschema will define this for you if you use it. 
DBMS must be one of the following:

<p>
<ul class="compact">
<li>&rsquo;Microsoft SQL Server&rsquo;
<li>&rsquo;PostgreSQL&rsquo;
<li>&rsquo;SQLite&rsquo;
</ul>

<p>
<li>cql:<code>odbc_data_type(+Schema, +TableName, +ColumnName, +OdbcDataType)</code>.
<li>cql:<code>primary_column_name(+Schema, +Tablename, +ColumnName)</code>.
<li>cql:database_attribute(+EntityType:table/view, +Schema:atom, 
+EntityName:atom, +ColumnName:atom, +DomainOrNativeType:atom, 
+AllowsNulls:<code>allows_nulls(true/false)</code>, +IsIdentity:<code>is_identity(true/false)</code>, 
+ColumnDefault).
<li>cql:<code>database_domain(+DomainName, +OdbcDataType)</code>.
<li>cql:<code>routine_return_type(+Schema, +RoutineName, +OdbcDataType)</code>.
<li>cql:<code>database_constraint(+Schema, +EntityName, +ConstraintName, +Constraint)</code>.
</ul>

<p><h4 id="sec:cql-events-and-history"><a id="sec:1.8.6"><span class="sec-nr">1.8.6</span> <span class="sec-title">CQL: 
Event Processing and History</span></a></h4>

<p><a id="sec:cql-events-and-history"></a>

<p>CQL provides hooks for maintaining detailed history of data in the 
database.

<p>The hook predicates are:

<p>
<ul class="compact">
<li>cql:<code>cql_event_notification_table(+Schema, +TableName)</code>
<li>cql:<code>cql_history_attribute(+Schema, +TableName, +ColumnName)</code>
<li>cql:<code>cql_update_history_hook(+Schema, +TableName, +ColumnName, +PrimaryKeyColumnName, +PrimaryKeyValue, +ApplicationValueBefore, +ApplicationValueAfter, +AccessToken, +TransactionId, +TransactionTimestamp, +ThreadId, +Connection, +Goal)</code>.
<li>cql:<code>process_database_events(+Events)</code>
</ul>

<p>Event Processing and History recording can be suppressed for a 
particular update/insert/delete statement by including the 
_no_state_change_actions_9 directive.

<p>For example

<pre class="code">
{[],
 update(se_lt_x, [f-'LILAC']
 @ :: [a-'ELSTON_M'],
 no_state_change_actions,   % Don't want history to record this change
 row_count(RowCount)}
</pre>

<p><h4 id="sec:cql-statistics-hooks"><a id="sec:1.8.7"><span class="sec-nr">1.8.7</span> <span class="sec-title">CQL: 
Statistical Hooks</span></a></h4>

<p><a id="sec:cql-statistics-hooks"></a>

<p>CQL has hooks to enable in-memory statistics to be tracked for 
database tables. Using this hook, it's possible to monitor the number of 
rows in a table with a particular value in a particular column.

<p>Often the kind of statistics of interest are&rsquo;how many rows in 
this table are in ERROR&rsquo;or&rsquo;how many in this table are at NEW&rsquo;? 
While it may be possible to maintain these directly in any code which 
updates tables, it can be difficult to ensure all cases are accounted 
for, and requires developers to remember which attributes are tracked.

<p>To ensure that all (CQL-originated) updates to statuses are captured, 
it's possible to use the CQL hook system to update them automatically. 
Define add a fact like:

<pre class="code">
cql_statistic_monitored_attribute_hook(my_schema, my_table,
                                       my_table_status_column).
</pre>

<p>This will examine the domain for the column&rsquo;my_table_status_column&rsquo;, 
and generate a statistic for each of my_table::<code>my_table_status_column(xxx)</code>, 
where xxx is each possible allowed value for the domain. Code will be 
automatically generated to trap updates to this specific column, and 
maintain the state. This way, if you are interested in the number of 
rows in my_table which have a status of&rsquo;NEW&rsquo;, you can look 
at my_table::<code>my_table_status_column('NEW')</code>, without having 
to manage the state directly. CQL update statements which affect the 
status will automatically maintain the statistics.

<p>The calculations are vastly simpler than the history mechanism, so as 
to keep performance as high as possible. For inserts, there is no cost 
to monitoring the table (the insert simply increments the statistic if 
the transaction completes). For deletes, the delete query is first run 
as a select, aggregating on the monitored columns to find the number of 
deletes for each domain allowed value. This means that a delete of 
millions of rows might requires a select returning only a single row for 
statistics purposes. For updates, the delete code is run, then the 
insert calculation is done, multiplied by the number of rows affected by 
the update.

<p>In all cases, CQL ends up calling
<span class="pred-ext">cql_statistic_monitored_attribute_change_hook/5</span>, 
where the last argument is a signed value indicating the number of 
changes to that particular statistic.

<dl class="latex">
<dt class="pubdef"><a id="cql_set_module_default_schema/1"><strong>cql_set_module_default_schema</strong>(<var>+Schema</var>)</a></dt>
<dd class="defbody">
Set the <var>Schema</var> for a module</dd>
<dt class="pubdef"><a id="cql_get_module_default_schema/2"><strong>cql_get_module_default_schema</strong>(<var>+Module, 
?ModuleDefaultSchema</var>)</a></dt>
<dd class="defbody">
</dd>
<dt class="pubdef"><a id="cql_goal_expansion/3"><strong>cql_goal_expansion</strong>(<var>?Schema, 
?Cql, ?GoalExpansion</var>)</a></dt>
<dd class="defbody">
Expand at compile time if the first term is a list of unbound input 
variables

<p>Expand at runtime if the first term is compile_at_runtime</dd>
<dt class="pubdef"><a id="cql_runtime/7"><strong>cql_runtime</strong>(<var>+Schema, 
+IgnoreIfNullVariables, +CqlA, +CqlB, +VariableMap, +FileName, 
+LineNumber</var>)</a></dt>
<dd class="defbody">
</dd>
<dt class="pubdef"><a id="cql_temporary_column_name/4"><strong>cql_temporary_column_name</strong>(<var>?Schema, 
?DataType, ?ColumnName, ?Type</var>)</a></dt>
<dd class="defbody">
</dd>
<dt class="pubdef"><a id="cql_show/2"><strong>cql_show</strong>(<var>:Goal, 
+Mode</var>)</a></dt>
<dd class="defbody">
Called when <span class="pred-ext">?/1</span>, <span class="pred-ext">??/1</span>, 
and <span class="pred-ext">???/1</span> applied to CQL
<table class="arglist">
<tr><td><var>Goal</var> </td><td>goal term </td></tr>
<tr><td><var>Mode</var> </td><td>minimal ; explicit ; full </td></tr>
</table>
</dd>
<dt class="pubdef"><a id="statistic_monitored_attribute/3"><strong>statistic_monitored_attribute</strong>(<var>+Schema, 
+TableName, +ColumnName</var>)</a></dt>
<dd class="defbody">
</dd>
<dt class="multidef"><span class="pred-tag">[multifile]</span><a id="dbms/2"><strong>dbms</strong>(<var>+Schema, 
-DBMSName</var>)</a></dt>
<dd class="defbody">
Determine the DBMS for a given <var>Schema</var>. Can be autoconfigured.</dd>
<dt class="multidef"><span class="pred-tag">[multifile]</span><a id="odbc_data_type/4"><strong>odbc_data_type</strong>(<var>+Schema, 
+TableSpec, +ColumnName, ?OdbcDataType</var>)</a></dt>
<dd class="defbody">
<var>OdbcDataType</var> must be a native SQL datatype, such as <code>varchar(30)</code> 
or <code>decimal(10, 5)</code> Can be autoconfigured.</dd>
<dt class="multidef"><span class="pred-tag">[multifile]</span><a id="primary_key_column_name/3"><strong>primary_key_column_name</strong>(<var>+Schema, 
+TableName, -PrimaryKeyAttributeName</var>)</a></dt>
<dd class="defbody">
Can be autoconfigured.</dd>
<dt class="multidef"><span class="pred-tag">[multifile]</span><a id="routine_return_type/3"><strong>routine_return_type</strong>(<var>?Schema:atom, 
?EntityName:atom, ?OdbcType</var>)</a></dt>
<dd class="defbody">
Can be autoconfigured</dd>
<dt class="multidef"><span class="pred-tag">[nondet,multifile]</span><a id="database_constraint/4"><strong>database_constraint</strong>(<var>?Schema:atom, 
?EntityName:atom, ?ConstraintName:atom, ?Constraint</var>)</a></dt>
<dd class="defbody">
<var>Constraint</var> is one of:

<p>
<ul class="compact">
<li><code>primary_key(ColumnNames:list)</code>
<li><code>foreign_key(ForeignTableName:atom, ForeignColumnNames:list, ColumnNames:list)</code>
<li><code>unique(ColumnNames:list)</code>
<li><code>check(CheckClause)</code>
</ul>

<p>In theory this can be autoconfigured too, but I have not written the 
code for it yet</dd>
<dt class="pubdef"><a id="attribute_domain/4"><strong>attribute_domain</strong>(<var>+Schema, 
+TableName, +ColumnName, -Domain</var>)</a></dt>
<dd class="defbody">
</dd>
<dt class="pubdef"><a id="database_identity/3"><strong>database_identity</strong>(<var>?Schema:atom, 
?EntityName:atom, ?ColumnName:atom</var>)</a></dt>
<dd class="defbody">
</dd>
<dt class="pubdef"><a id="database_key/5"><strong>database_key</strong>(<var>?Schema:atom, 
?EntityName:atom, ?ConstraintName:atom, ?KeyColumnNames:list, ?KeyType</var>)</a></dt>
<dd class="defbody">
<table class="arglist">
<tr><td><var>KeyColumnNames</var> </td><td>list of <i>atom</i> in 
database-supplied order </td></tr>
<tr><td><var>KeyType</var> </td><td><i>identity</i> ; <i>&rsquo;primary 
key&rsquo;</i> ; <i>unique</i> </td></tr>
</table>
</dd>
<dt class="multidef"><span class="pred-tag">[multifile]</span><a id="cql_event_notification_table/2"><strong>cql_event_notification_table</strong>(<var>+Schema, 
+TableName</var>)</a></dt>
<dd class="defbody">
</dd>
<dt class="multidef"><span class="pred-tag">[multifile]</span><a id="cql_history_attribute/3"><strong>cql_history_attribute</strong>(<var>+Schema, 
+TableName, +ColumnName</var>)</a></dt>
<dd class="defbody">
</dd>
<dt class="multidef"><span class="pred-tag">[multifile]</span><a id="sql_gripe_hook/3"><strong>sql_gripe_hook</strong>(<var>+Level, 
+Format, +Args</var>)</a></dt>
<dd class="defbody">
Called when something dubious is found by the SQL parser.</dd>
<dt class="pubdef"><a id="cql_normalize_name/3"><strong>cql_normalize_name</strong>(<var>+DBMS, 
+Name, -NormalizedName</var>)</a></dt>
<dd class="defbody">
Normalize a name which is potentially longer than the <var>DBMS</var> 
allows to a unique truncation</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="register_database_connection_details/2"><strong>register_database_connection_details</strong>(<var>+Schema:atom, 
+ConnectionDetails</var>)</a></dt>
<dd class="defbody">
This should be called once to register the database connection details.
<table class="arglist">
<tr><td><var>ConnectionDetails</var> </td><td><code>driver_string(DriverString)</code> 
or <code>dsn(Dsn, Username, Password)</code> </td></tr>
</table>
</dd>
</dl>

<h2>Bibliography</h2>

<dl class="bib">
<dt class="bib"><a id="Draxler:ALPUK91"><strong>Draxler, 1991</strong></a></dt>
<dd class="bib">
C.&nbsp;Draxler. Accessing relational and <var>NF^2</var> databases 
through database set predicates. In Geraint&nbsp;A. Wiggins, Chris 
Mellish, and Tim Duncan, editors, <em>ALPUK91: Proceedings of the 3rd UK 
Annual Conference on Logic Programming, Edinburgh 1991</em>, Workshops 
in Computing, pages 156--173. Springer-Verlag, 1991.

<p></dd>
</dl>

<h1><a id="document-index">Index</a></h1>

<dl>
<dt class="index-sep">?</dt>
<dt><a class="idx" href="#attribute_domain/4">attribute_domain/4</a></dt>
<dt><a class="idx" href="#cql_event_notification_table/2">cql_event_notification_table/2</a></dt>
<dt><a class="idx" href="#cql_get_module_default_schema/2">cql_get_module_default_schema/2</a></dt>
<dt><a class="idx" href="#cql_goal_expansion/3">cql_goal_expansion/3</a></dt>
<dt><a class="idx" href="#cql_history_attribute/3">cql_history_attribute/3</a></dt>
<dt><a class="idx" href="#cql_normalize_name/3">cql_normalize_name/3</a></dt>
<dt><a class="idx" href="#cql_runtime/7">cql_runtime/7</a></dt>
<dt><a class="idx" href="#cql_set_module_default_schema/1">cql_set_module_default_schema/1</a></dt>
<dt><a class="idx" href="#cql_show/2">cql_show/2</a></dt>
<dt><a class="idx" href="#cql_temporary_column_name/4">cql_temporary_column_name/4</a></dt>
<dt><a class="idx" href="#database_constraint/4">database_constraint/4</a></dt>
<dt><a class="idx" href="#database_identity/3">database_identity/3</a></dt>
<dt><a class="idx" href="#database_key/5">database_key/5</a></dt>
<dt><a class="idx" href="#dbms/2">dbms/2</a></dt>
<dt><a class="idx" href="#odbc_data_type/4">odbc_data_type/4</a></dt>
<dt><a class="idx" href="#primary_key_column_name/3">primary_key_column_name/3</a></dt>
<dt><a class="idx" href="#register_database_connection_details/2">register_database_connection_details/2</a></dt>
<dt><a class="idx" href="#routine_return_type/3">routine_return_type/3</a></dt>
<dt><a class="idx" href="#sql_gripe_hook/3">sql_gripe_hook/3</a></dt>
<dt><a class="idx" href="#statistic_monitored_attribute/3">statistic_monitored_attribute/3</a></dt>
<dd>
</dd>
</dl>

</body></html>