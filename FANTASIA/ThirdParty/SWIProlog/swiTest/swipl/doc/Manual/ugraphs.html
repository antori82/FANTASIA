<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
<title>SWI-Prolog 9.2.9 Reference Manual: Section A.60</title><link rel="home" href="index.html">
<link rel="contents" href="Contents.html">
<link rel="index" href="DocIndex.html">
<link rel="summary" href="summary.html">
<link rel="previous" href="threadpool.html">
<link rel="next" href="url.html">

<style type="text/css">

/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef, dt.multidef
{ color: #fff;
padding: 2px 10px 0px 10px;
margin-bottom: 5px;
font-size: 18px;
vertical-align: middle;
overflow: hidden;
}

dt.pubdef { background-color: #0c3d6e; }
dt.multidef { background-color: #ef9439; }

.bib dd
{ margin-bottom: 1em;
}

.bib dt
{ float: left;
margin-right: 1.3ex;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{
}

span.sec-title
{
}

span.pred-ext
{ font-weight: bold;
}

span.pred-tag
{ float: right;
padding-top: 0.2em;
font-size: 80%;
font-style: italic;
color: #fff;
}

div.caption
{ width: 80%;
margin: auto;
text-align:center;
}

/* Footnotes */
.fn {
color: red;
font-size: 70%;
}

.fn-text, .fnp {
position: absolute;
top: auto;
left: 10%;
border: 1px solid #000;
box-shadow: 5px 5px 5px #888;
display: none;
background: #fff;
color: #000;
margin-top: 25px;
padding: 8px 12px;
font-size: larger;
}

sup:hover span.fn-text
{ display: block;
}

/* Lists */

dl.latex
{ margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.latex dl.latex dd.defbody
{ margin-bottom: 0.5ex;
}

/* PlDoc Tags */

dl.tags
{ font-size: 90%;
margin-left: 5ex;
margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.tags dt
{ margin-left: 0pt;
font-weight: bold;
}

dl.tags dd
{ margin-left: 3ex;
}

td.param
{ font-style: italic;
font-weight: bold;
}

/* Index */

dt.index-sep
{ font-weight: bold;
font-size: +1;
margin-top: 1ex;
}

/* Tables */

table.center
{ margin: auto;
}

table.latex
{ border-collapse:collapse;
}

table.latex tr
{ vertical-align: text-top;
}

table.latex td,th
{ padding: 2px 1em;
}

table.latex tr.hline td,th
{ border-top: 1px solid black;
}

table.frame-box
{ border: 2px solid black;
}

</style>
</head>
<body style="background:white">
<div class="navigate"><a class="nav" href="index.html"><img src="home.gif" alt="Home"></a>
<a class="nav" href="Contents.html"><img src="index.gif" alt="Contents"></a>
<a class="nav" href="DocIndex.html"><img src="yellow_pages.gif" alt="Index"></a>
<a class="nav" href="summary.html"><img src="info.gif" alt="Summary"></a>
<a class="nav" href="threadpool.html"><img src="prev.gif" alt="Previous"></a>
<a class="nav" href="url.html"><img src="next.gif" alt="Next"></a>
</div>
<h2 id="sec:ugraphs"><a id="sec:A.60"><span class="sec-nr">A.60</span> <span class="sec-title">library(ugraphs): 
Graph manipulation library</span></a></h2>

<p><a id="sec:ugraphs"></a>

<dl class="tags">
<dt class="mtag">author</dt>
<dd>
- R.A.O'Keefe <br>
- Vitor Santos Costa <br>
- Jan Wielemaker
</dd>
<dt class="tag">license</dt>
<dd>
BSD-2 or Artistic 2.0
</dd>
</dl>

<p>The S-representation of a graph is a list of (vertex-neighbours) 
pairs, where the pairs are in standard order (as produced by keysort) 
and the neighbours of each vertex are also in standard order (as 
produced by sort). This form is convenient for many calculations.

<p>A new UGraph from raw data can be created using
<a class="pred" href="ugraphs.html#vertices_edges_to_ugraph/3">vertices_edges_to_ugraph/3</a>.

<p>Adapted to support some of the functionality of the SICStus ugraphs 
library by Vitor Santos Costa.

<p>Ported from YAP 5.0.1 to SWI-Prolog by Jan Wielemaker.

<dl class="latex">
<dt class="pubdef"><a id="vertices/2"><strong>vertices</strong>(<var>+Graph, 
-Vertices</var>)</a></dt>
<dd class="defbody">
Unify <var>Vertices</var> with all vertices appearing in <var>Graph</var>. 
Example:

<pre class="code">
?- vertices([1-[3,5],2-[4],3-[],4-[5],5-[]], L).
L = [1, 2, 3, 4, 5]
</pre>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="vertices_edges_to_ugraph/3"><strong>vertices_edges_to_ugraph</strong>(<var>+Vertices:list, 
+Edges:pairs, -UGraph</var>)</a></dt>
<dd class="defbody">
Create a <var>UGraph</var> from <var>Vertices</var> and <var>Edges</var>. <var>UGraph</var> 
must unify with the corresponding S-representation. Note that vertices 
that do not appear in any of the <var>Edges</var> appear in <var>UGraph</var> 
as <code>Vertice-[]</code>. The set of vertices in <var>UGraph</var> is 
the union of <var>Vertices</var> and all vertices that appear in the <var>Edges</var> 
pairs.

<pre class="code">
?- vertices_edges_to_ugraph([],[1-3,2-4,4-5,1-5], L).
L = [1-[3,5], 2-[4], 3-[], 4-[5], 5-[]]
</pre>

<p>In this case all vertices are defined implicitly. The next example 
shows three unconnected vertices:

<pre class="code">
?- vertices_edges_to_ugraph([1,2,6,7,8],[1-3,2-4,4-5,1-5], L).
L = [1-[3,5], 2-[4], 3-[], 4-[5], 5-[], 6-[], 7-[], 8-[]]
</pre>

</dd>
<dt class="pubdef"><a id="add_vertices/3"><strong>add_vertices</strong>(<var>+Graph, 
+Vertices, -NewGraph</var>)</a></dt>
<dd class="defbody">
Unify <var>NewGraph</var> with a new graph obtained by adding the list 
of
<var>Vertices</var> to <var>Graph</var>. Example:

<pre class="code">
?- add_vertices([1-[3,5],2-[]], [0,1,2,9], NG).
NG = [0-[], 1-[3,5], 2-[], 9-[]]
</pre>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="del_vertices/3"><strong>del_vertices</strong>(<var>+Graph, 
+Vertices, -NewGraph</var>)</a></dt>
<dd class="defbody">
Unify <var>NewGraph</var> with a new graph obtained by deleting the list 
of
<var>Vertices</var> and all the edges that start from or go to a vertex 
in
<var>Vertices</var> to the <var>Graph</var>. Example:

<pre class="code">
?- del_vertices([1-[3,5],2-[4],3-[],4-[5],5-[],6-[],7-[2,6],8-[]],
                [2,1],
                NL).
NL = [3-[],4-[5],5-[],6-[],7-[6],8-[]]
</pre>

<dl class="tags">
<dt class="tag">Compatibility</dt>
<dd>
Upto 5.6.48 the argument order was (+<var>Vertices</var>, +<var>Graph</var>, 
-<var>NewGraph</var>). Both YAP and SWI-Prolog have changed the argument 
order for compatibility with recent SICStus as well as consistency with <a class="pred" href="ugraphs.html#del_edges/3">del_edges/3</a>.
</dd>
</dl>

</dd>
<dt class="pubdef"><a id="add_edges/3"><strong>add_edges</strong>(<var>+Graph, 
+Edges, -NewGraph</var>)</a></dt>
<dd class="defbody">
Unify <var>NewGraph</var> with a new graph obtained by adding the list 
of <var>Edges</var> to <var>Graph</var>. Example:

<pre class="code">
?- add_edges([1-[3,5],2-[4],3-[],4-[5],
              5-[],6-[],7-[],8-[]],
             [1-6,2-3,3-2,5-7,3-2,4-5],
             NL).
NL = [1-[3,5,6], 2-[3,4], 3-[2], 4-[5],
      5-[7], 6-[], 7-[], 8-[]]
</pre>

</dd>
<dt class="pubdef"><a id="ugraph_union/3"><strong>ugraph_union</strong>(<var>+Graph1, 
+Graph2, -NewGraph</var>)</a></dt>
<dd class="defbody">
<var>NewGraph</var> is the union of <var>Graph1</var> and <var>Graph2</var>. 
Example:

<pre class="code">
?- ugraph_union([1-[2],2-[3]],[2-[4],3-[1,2,4]],L).
L = [1-[2], 2-[3,4], 3-[1,2,4]]
</pre>

</dd>
<dt class="pubdef"><a id="del_edges/3"><strong>del_edges</strong>(<var>+Graph, 
+Edges, -NewGraph</var>)</a></dt>
<dd class="defbody">
Unify <var>NewGraph</var> with a new graph obtained by removing the list 
of
<var>Edges</var> from <var>Graph</var>. Notice that no vertices are 
deleted. Example:

<pre class="code">
?- del_edges([1-[3,5],2-[4],3-[],4-[5],5-[],6-[],7-[],8-[]],
             [1-6,2-3,3-2,5-7,3-2,4-5,1-3],
             NL).
NL = [1-[5],2-[4],3-[],4-[],5-[],6-[],7-[],8-[]]
</pre>

</dd>
<dt class="pubdef"><a id="edges/2"><strong>edges</strong>(<var>+Graph, 
-Edges</var>)</a></dt>
<dd class="defbody">
Unify <var>Edges</var> with all edges appearing in <var>Graph</var>. 
Example:

<pre class="code">
?- edges([1-[3,5],2-[4],3-[],4-[5],5-[]], L).
L = [1-3, 1-5, 2-4, 4-5]
</pre>

</dd>
<dt class="pubdef"><a id="transitive_closure/2"><strong>transitive_closure</strong>(<var>+Graph, 
-Closure</var>)</a></dt>
<dd class="defbody">
Generate the graph <var>Closure</var> as the transitive closure of <var>Graph</var>. 
Example:

<pre class="code">
?- transitive_closure([1-[2,3],2-[4,5],4-[6]],L).
L = [1-[2,3,4,5,6], 2-[4,5,6], 4-[6]]
</pre>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="transpose_ugraph/2"><strong>transpose_ugraph</strong>(<var>Graph, 
NewGraph</var>)</a></dt>
<dd class="defbody">
Unify <var>NewGraph</var> with a new graph obtained from <var>Graph</var> 
by replacing all edges of the form V1-V2 by edges of the form V2-V1. The 
cost is O(<code>|</code>V<code>|</code>*log(<code>|</code>V<code>|</code>)). 
Notice that an undirected graph is its own transpose. Example:

<pre class="code">
?- transpose([1-[3,5],2-[4],3-[],4-[5],
              5-[],6-[],7-[],8-[]], NL).
NL = [1-[],2-[],3-[1],4-[2],5-[1,4],6-[],7-[],8-[]]
</pre>

<dl class="tags">
<dt class="tag">Compatibility</dt>
<dd>
This predicate used to be known as <a class="pred" href="clpfd.html#transpose/2">transpose/2</a>. 
Following SICStus 4, we reserve <a class="pred" href="clpfd.html#transpose/2">transpose/2</a> 
for matrix transposition and renamed ugraph transposition to
<a class="pred" href="ugraphs.html#transpose_ugraph/2">transpose_ugraph/2</a>.
</dd>
</dl>

</dd>
<dt class="pubdef"><a id="compose/3"><strong>compose</strong>(<var>+LeftGraph, 
+RightGraph, -NewGraph</var>)</a></dt>
<dd class="defbody">
Compose <var>NewGraph</var> by connecting the <i>drains</i> of <var>LeftGraph</var> 
to the
<i>sources</i> of <var>RightGraph</var>. Example:

<pre class="code">
?- compose([1-[2],2-[3]],[2-[4],3-[1,2,4]],L).
L = [1-[4], 2-[1,2,4], 3-[]]
</pre>

</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="ugraph_layers/2"><strong>ugraph_layers</strong>(<var>Graph, 
-Layers</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="top_sort/2"><strong>top_sort</strong>(<var>+Graph, 
-Sorted</var>)</a></dt>
<dd class="defbody">
Sort vertices topologically. <var>Layers</var> is a list of lists of 
vertices where there are no edges from a layer to an earlier layer. The 
predicate <a class="pred" href="ugraphs.html#top_sort/2">top_sort/2</a> 
flattens the layers using <a class="pred" href="lists.html#append/2">append/2</a>.

<p>These predicates fail if <var>Graph</var> is cyclic. If <var>Graph</var> 
is not connected, the sub-graphs are individually sorted, where the root 
of each subgraph is in the first layer, the nodes connected to the roots 
in the second, etc.

<pre class="code">
?- top_sort([1-[2], 2-[3], 3-[]], L).
L = [1, 2, 3]
</pre>

<dl class="tags">
<dt class="mtag">Compatibility</dt>
<dd>
- The original version of this library provided <span class="pred-ext">top_sort/3</span> 
as a <i>difference list</i> version of <a class="pred" href="ugraphs.html#top_sort/2">top_sort/2</a>. 
We removed this because the argument order was non-standard. Fixing 
causes hard to debug compatibility issues while we expect <span class="pred-ext">top_sort/3</span> 
was rarely used. A backward compatible <span class="pred-ext">top_sort/3</span> 
can be defined as

<pre class="code">
top_sort(Graph, Tail, Sorted) :-
    top_sort(Graph, Sorted0),
    append(Sorted0, Tail, Sorted).
</pre>

<p>The original version returned all vertices in a <i>layer</i> in 
reverse order. The current one returns them in standard order of terms, 
i.e., each layer is an <i>ordered set</i>. <br>
- <a class="pred" href="ugraphs.html#ugraph_layers/2">ugraph_layers/2</a> 
is a SWI-Prolog specific addition to this library.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="neighbors/3"><strong>neighbors</strong>(<var>+Vertex, 
+Graph, -Neigbours</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="neighbours/3"><strong>neighbours</strong>(<var>+Vertex, 
+Graph, -Neigbours</var>)</a></dt>
<dd class="defbody">
<var>Neigbours</var> is a sorted list of the neighbours of <var>Vertex</var> 
in <var>Graph</var>. Example:

<pre class="code">
?- neighbours(4,[1-[3,5],2-[4],3-[],
                 4-[1,2,7,5],5-[],6-[],7-[],8-[]], NL).
NL = [1,2,7,5]
</pre>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="connect_ugraph/3"><strong>connect_ugraph</strong>(<var>+UGraphIn, 
-Start, -UGraphOut</var>)</a></dt>
<dd class="defbody">
Adds <var>Start</var> as an additional vertex that is connected to all 
vertices in <var>UGraphIn</var>. This can be used to create an 
topological sort for a not connected graph. <var>Start</var> is before 
any vertex in <var>UGraphIn</var> in the standard order of terms. No 
vertex in <var>UGraphIn</var> can be a variable.

<p>Can be used to order a not-connected graph as follows:

<pre class="code">
top_sort_unconnected(Graph, Vertices) :-
    (   top_sort(Graph, Vertices)
    -&gt;  true
    ;   connect_ugraph(Graph, Start, Connected),
        top_sort(Connected, Ordered0),
        Ordered0 = [Start|Vertices]
    ).
</pre>

</dd>
<dt class="pubdef"><a id="complement/2"><strong>complement</strong>(<var>+UGraphIn, 
-UGraphOut</var>)</a></dt>
<dd class="defbody">
<var>UGraphOut</var> is a ugraph with an edge between all vertices that 
are
<i>not</i> connected in <var>UGraphIn</var> and all edges from <var>UGraphIn</var> 
removed. Example:

<pre class="code">
?- complement([1-[3,5],2-[4],3-[],
               4-[1,2,7,5],5-[],6-[],7-[],8-[]], NL).
NL = [1-[2,4,6,7,8],2-[1,3,5,6,7,8],3-[1,2,4,5,6,7,8],
      4-[3,5,6,8],5-[1,2,3,4,6,7,8],6-[1,2,3,4,5,7,8],
      7-[1,2,3,4,5,6,8],8-[1,2,3,4,5,6,7]]
</pre>

<dl class="tags">
<dt class="tag">To be done</dt>
<dd>
Simple two-step algorithm. You could be smarter, I suppose.
</dd>
</dl>

</dd>
<dt class="pubdef"><a id="reachable/3"><strong>reachable</strong>(<var>+Vertex, 
+UGraph, -Vertices</var>)</a></dt>
<dd class="defbody">
True when <var>Vertices</var> is an ordered set of vertices reachable in
<var>UGraph</var>, including <var>Vertex</var>. Example:

<pre class="code">
?- reachable(1,[1-[3,5],2-[4],3-[],4-[5],5-[]],V).
V = [1, 3, 5]
</pre>

<p></dd>
</dl>

<p></body></html>