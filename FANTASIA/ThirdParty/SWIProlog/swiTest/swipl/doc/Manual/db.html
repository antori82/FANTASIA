<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
<title>SWI-Prolog 9.2.9 Reference Manual: Section 4.14</title><link rel="home" href="index.html">
<link rel="contents" href="Contents.html">
<link rel="index" href="DocIndex.html">
<link rel="summary" href="summary.html">
<link rel="previous" href="DCG.html">
<link rel="next" href="dynamic.html">

<style type="text/css">

/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef, dt.multidef
{ color: #fff;
padding: 2px 10px 0px 10px;
margin-bottom: 5px;
font-size: 18px;
vertical-align: middle;
overflow: hidden;
}

dt.pubdef { background-color: #0c3d6e; }
dt.multidef { background-color: #ef9439; }

.bib dd
{ margin-bottom: 1em;
}

.bib dt
{ float: left;
margin-right: 1.3ex;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{
}

span.sec-title
{
}

span.pred-ext
{ font-weight: bold;
}

span.pred-tag
{ float: right;
padding-top: 0.2em;
font-size: 80%;
font-style: italic;
color: #fff;
}

div.caption
{ width: 80%;
margin: auto;
text-align:center;
}

/* Footnotes */
.fn {
color: red;
font-size: 70%;
}

.fn-text, .fnp {
position: absolute;
top: auto;
left: 10%;
border: 1px solid #000;
box-shadow: 5px 5px 5px #888;
display: none;
background: #fff;
color: #000;
margin-top: 25px;
padding: 8px 12px;
font-size: larger;
}

sup:hover span.fn-text
{ display: block;
}

/* Lists */

dl.latex
{ margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.latex dl.latex dd.defbody
{ margin-bottom: 0.5ex;
}

/* PlDoc Tags */

dl.tags
{ font-size: 90%;
margin-left: 5ex;
margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.tags dt
{ margin-left: 0pt;
font-weight: bold;
}

dl.tags dd
{ margin-left: 3ex;
}

td.param
{ font-style: italic;
font-weight: bold;
}

/* Index */

dt.index-sep
{ font-weight: bold;
font-size: +1;
margin-top: 1ex;
}

/* Tables */

table.center
{ margin: auto;
}

table.latex
{ border-collapse:collapse;
}

table.latex tr
{ vertical-align: text-top;
}

table.latex td,th
{ padding: 2px 1em;
}

table.latex tr.hline td,th
{ border-top: 1px solid black;
}

table.frame-box
{ border: 2px solid black;
}

</style>
</head>
<body style="background:white">
<div class="navigate"><a class="nav" href="index.html"><img src="home.gif" alt="Home"></a>
<a class="nav" href="Contents.html"><img src="index.gif" alt="Contents"></a>
<a class="nav" href="DocIndex.html"><img src="yellow_pages.gif" alt="Index"></a>
<a class="nav" href="summary.html"><img src="info.gif" alt="Summary"></a>
<a class="nav" href="DCG.html"><img src="prev.gif" alt="Previous"></a>
<a class="nav" href="dynamic.html"><img src="next.gif" alt="Next"></a>
</div>
<h2 id="sec:db"><a id="sec:4.14"><span class="sec-nr">4.14</span> <span class="sec-title">Database</span></a></h2>

<a id="sec:db"></a>

<p>SWI-Prolog offers several ways to store data in globally accessible 
memory, i.e., outside the Prolog <em>stacks</em>. Data stored this way 
notably does not change on <em>backtracking</em>. Typically it is a bad 
idea to use any of the predicates in this section for realising global 
variables that can be assigned to. Typically, first consider 
representing data processed by your program as terms passed around as 
predicate arguments. If you need to reason over multiple solutions to a 
goal, consider <a id="idx:findall3:924"></a><a class="pred" href="allsolutions.html#findall/3">findall/3</a>, <a id="idx:aggregate3:925"></a><a class="pred" href="aggregate.html#aggregate/3">aggregate/3</a> 
and related predicates.

<p>Nevertheless, there are scenarios where storing data outside the 
Prolog stacks is a good option. Below are the main options for storing 
data:

<dl class="latex">
<dt><b>Using dynamic predicates</b></dt>
<dd>
Dynamic predicates are predicates for which the list of clauses is 
modified at runtime using <a id="idx:asserta1:926"></a><a class="pred" href="db.html#asserta/1">asserta/1</a>, <a id="idx:assertz1:927"></a><a class="pred" href="db.html#assertz/1">assertz/1</a>, <a id="idx:retract1:928"></a><a class="pred" href="db.html#retract/1">retract/1</a> 
or
<a id="idx:retractall1:929"></a><a class="pred" href="db.html#retractall/1">retractall/1</a>. 
Following the ISO standard, predicates that are modified this way need 
to be declared using the <a id="idx:dynamic1:930"></a><a class="pred" href="dynamic.html#dynamic/1">dynamic/1</a> <em>directive</em>. 
These facilities are defined by the ISO standard and widely supported. 
The mechanism is often considered slow in the literature. Performance 
depends on the Prolog implementation. In SWI-Prolog, querying dynamic 
predicates has the same performance as static ones. The manipulation 
predicates are fast. Using <a id="idx:retract1:931"></a><a class="pred" href="db.html#retract/1">retract/1</a> 
or <a id="idx:retractall1:932"></a><a class="pred" href="db.html#retractall/1">retractall/1</a> 
on a predicate registers the predicate as&lsquo;dirty&rsquo;. Dirty 
predicates are cleaned by
<a id="idx:garbagecollectclauses0:933"></a><a class="pred" href="memory.html#garbage_collect_clauses/0">garbage_collect_clauses/0</a>, 
which is normally automatically invoked. Some workloads may result in 
significant performance reduction due to skipping retracted clauses 
and/or clause garbage collection.

<p>Dynamic predicates can be wrapped using library <code>library(persistency)</code> 
to maintain a backup of the data on disk. Dynamic predicates come in two 
flavours, <em>shared</em> between threads and <em>local</em> to each 
thread. The latter version is created using the directive
<a id="idx:threadlocal1:934"></a><a class="pred" href="threadcom.html#thread_local/1">thread_local/1</a>.</dd>
<dt><b>The recorded database</b></dt>
<dd>
The&lsquo;recorded database&rsquo;registers a list of terms with a <em>key</em>, 
an atom or compound term. The list is managed using <a id="idx:recorda3:935"></a><a class="pred" href="db.html#recorda/3">recorda/3</a>, <a id="idx:recordz3:936"></a><a class="pred" href="db.html#recordz/3">recordz/3</a> 
and <a id="idx:erase1:937"></a><a class="pred" href="db.html#erase/1">erase/1</a>. 
It is queried using <a id="idx:recorded3:938"></a><a class="pred" href="db.html#recorded/3">recorded/3</a>. 
The recorded database is not part of the ISO standard but fairly widely 
supported, notably in implementations building on the&lsquo;Edinburgh 
tradition&rsquo;. There are few reasons to use this database in 
SWI-Prolog due to the good performance of dynamic predicates. Advantages 
are (1) the handle provides a direct reference to a term, (2) cyclic 
terms can be stored and (3) attributes (<a class="sec" href="attvar.html#sec:8.1">section 
8.1</a>) are preserved. Disadvantages are (1) the terms in a list 
associated with a key are not indexed, (2) the poorly specified
<em>immediate update semantics</em> (see <a class="sec" href="db.html#sec:4.14.5">section 
4.14.5</a> applies to the recorded database and (3) reduced portability.</dd>
<dt><b>The <a id="idx:flag3:939"></a><a class="pred" href="db.html#flag/3">flag/3</a> 
predicate</b></dt>
<dd>
The predicate <a id="idx:flag3:940"></a><a class="pred" href="db.html#flag/3">flag/3</a> 
associates one simple value (number or atom) with a key (atom, integer 
or compound). It is an old SWI-Prolog specific predicate that should be 
considered deprecated, although there is no plan to remove it.</dd>
<dt><b>Using global variables</b></dt>
<dd>
The predicates <a id="idx:bsetval2:941"></a><a class="pred" href="gvar.html#b_setval/2">b_setval/2</a> 
and <a id="idx:nbsetval2:942"></a><a class="pred" href="gvar.html#nb_setval/2">nb_setval/2</a> 
associate a term living on the Prolog stack with a name, either 
backtrackable or non-backtrackable. Backtrackable and non-backtrackable 
assignment without using a global name can be realised with <a id="idx:setarg3:943"></a><a class="pred" href="manipterm.html#setarg/3">setarg/3</a> 
and <a id="idx:nbsetarg3:944"></a><a class="pred" href="manipterm.html#nb_setarg/3">nb_setarg/3</a>. 
Notably the latter are used to realise aggregation as e.g., <a id="idx:aggregateall3:945"></a><a class="pred" href="aggregate.html#aggregate_all/3">aggregate_all/3</a> 
performs.</dd>
<dt><b>Tries</b></dt>
<dd>
As of version 7.3.21, SWI-Prolog provides <em>tries</em> (prefix trees) 
to associate a term <em>variant</em> with a value. Tries have been 
introduced to support <var>tabling</var> and are described in <a class="sec" href="db.html#sec:4.14.4">section 
4.14.4</a>.
</dd>
</dl>

<p><h3 id="sec:dynpreds"><a id="sec:4.14.1"><span class="sec-nr">4.14.1</span> <span class="sec-title">Managing 
(dynamic) predicates</span></a></h3>

<a id="sec:dynpreds"></a>

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a id="abolish/1"><strong>abolish</strong>(<var>:PredicateIndicator</var>)</a></dt>
<dd class="defbody">
Removes all clauses of a predicate with functor <var>Functor</var> and 
arity
<var>Arity</var> from the database. All predicate attributes (dynamic, 
multifile, index, etc.) are reset to their defaults. Abolishing an 
imported predicate only removes the import link; the predicate will keep 
its old definition in its definition module.

<p>According to the ISO standard, <a id="idx:abolish1:946"></a><a class="pred" href="db.html#abolish/1">abolish/1</a> 
can only be applied to dynamic procedures. This is odd, as for dealing 
with dynamic procedures there is already <a id="idx:retract1:947"></a><a class="pred" href="db.html#retract/1">retract/1</a> 
and <a id="idx:retractall1:948"></a><a class="pred" href="db.html#retractall/1">retractall/1</a>. 
The <a id="idx:abolish1:949"></a><a class="pred" href="db.html#abolish/1">abolish/1</a> 
predicate was introduced in DEC-10 Prolog precisely for dealing with 
static procedures. In SWI-Prolog, <a id="idx:abolish1:950"></a><a class="pred" href="db.html#abolish/1">abolish/1</a> 
works on static procedures, unless the Prolog flag <a class="flag" href="flags.html#flag:iso">iso</a> 
is set to <code>true</code>.

<p>It is advised to use <a id="idx:retractall1:951"></a><a class="pred" href="db.html#retractall/1">retractall/1</a> 
for erasing all clauses of a dynamic predicate.</dd>
<dt class="pubdef"><a id="abolish/2"><strong>abolish</strong>(<var>+Name, 
+Arity</var>)</a></dt>
<dd class="defbody">
Same as <code>abolish(Name/Arity)</code>. The predicate <a id="idx:abolish2:952"></a><a class="pred" href="db.html#abolish/2">abolish/2</a> 
conforms to the Edinburgh standard, while <a id="idx:abolish1:953"></a><a class="pred" href="db.html#abolish/1">abolish/1</a> 
is ISO compliant.</dd>
<dt class="pubdef"><a id="copy_predicate_clauses/2"><strong>copy_predicate_clauses</strong>(<var>:From, 
:To</var>)</a></dt>
<dd class="defbody">
Copy all clauses of predicate <var>From</var> to <var>To</var>. The 
predicate
<var>To</var> must be dynamic or undefined. If <var>To</var> is 
undefined, it is created as a dynamic predicate holding a copy of the 
clauses of
<var>From</var>. If <var>To</var> is a dynamic predicate, the clauses of
<var>From</var> are added (as in <a id="idx:assertz1:954"></a><a class="pred" href="db.html#assertz/1">assertz/1</a>) 
to the clauses of <var>To</var>.
<var>To</var> and <var>From</var> must have the same arity. Acts as if 
defined by the program below, but at a much better performance by 
avoiding decompilation and compilation.

<pre class="code">
copy_predicate_clauses(From, To) :-
        head(From, MF:FromHead),
        head(To, MT:ToHead),
        FromHead =.. [_|Args],
        ToHead =.. [_|Args],
        forall(clause(MF:FromHead, Body),
               assertz(MT:ToHead, Body)).

head(From, M:Head) :-
        strip_module(From, M, Name/Arity),
        functor(Head, Name, Arity).
</pre>

</dd>
<dt class="pubdef"><a id="redefine_system_predicate/1"><strong>redefine_system_predicate</strong>(<var>+Head</var>)</a></dt>
<dd class="defbody">
This directive may be used both in module <code>user</code> and in 
normal modules to redefine any system predicate. If the system 
definition is redefined in module <code>user</code>, the new definition 
is the default definition for all sub-modules. Otherwise the 
redefinition is local to the module. The system definition remains in 
the module <code>system</code>.

<p>Redefining system predicate facilitates the definition of 
compatibility packages. Use in other contexts is discouraged.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO,nondet]</span><a id="retract/1"><strong>retract</strong>(<var>+Term</var>)</a></dt>
<dd class="defbody">
When <var>Term</var> is an atom or a term it is unified with the first 
unifying fact or clause in the database. The fact or clause is removed 
from the database. The <a id="idx:retract1:955"></a><a class="pred" href="db.html#retract/1">retract/1</a> 
predicate respects the <em>logical update view</em>. This implies that <a id="idx:retract1:956"></a><a class="pred" href="db.html#retract/1">retract/1</a> 
succeeds for all clauses that match <var>Term</var> when the predicate 
was <em>called</em>. The example below illustrates that the first call 
to <a id="idx:retract1:957"></a><a class="pred" href="db.html#retract/1">retract/1</a> 
succeeds on <code>bee</code> on backtracking despite the fact that <code>bee</code> 
is already retracted.<sup class="fn">86<span class="fn-text">Example by 
Jan Burse</span></sup>

<pre class="code">
:- dynamic insect/1.
insect(ant).
insect(bee).

?- (   retract(insect(I)),
       writeln(I),
       retract(insect(bee)),
       fail
   ;   true
   ).
ant ;
bee.
</pre>

<p>If multiple threads start a retract on the same predicate at the same 
time their notion of the <em>entry generation</em> is adjusted such that 
they do not retract the same first clause. This implies that, if 
multiple threads use <code>once(retract(Term))</code>, no two threads 
will retract the same clause. Note that on backtracking over <a id="idx:retract1:958"></a><a class="pred" href="db.html#retract/1">retract/1</a>, 
multiple threads may retract the same clause as both threads respect the 
logical update view.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO,det]</span><a id="retractall/1"><strong>retractall</strong>(<var>+Head</var>)</a></dt>
<dd class="defbody">
All facts or clauses in the database for which the <var>head</var> 
unifies with <var>Head</var> are removed. If <var>Head</var> refers to a 
predicate that is not defined, it is implicitly created as a dynamic 
predicate. See also <a id="idx:dynamic1:959"></a><a class="pred" href="dynamic.html#dynamic/1">dynamic/1</a>.<sup class="fn">87<span class="fn-text">The 
ISO standard only allows using <a id="idx:dynamic1:960"></a><a class="pred" href="dynamic.html#dynamic/1">dynamic/1</a> 
as a <em>directive</em>.</span></sup></dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a id="asserta/1"><strong>asserta</strong>(<var>+Term</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a id="assertz/1"><strong>assertz</strong>(<var>+Term</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[deprecated]</span><a id="assert/1"><strong>assert</strong>(<var>+Term</var>)</a></dt>
<dd class="defbody">
Assert a clause (fact or rule) into the database. The predicate
<a id="idx:asserta1:961"></a><a class="pred" href="db.html#asserta/1">asserta/1</a> 
asserts the clause as first clause of the predicate while
<a id="idx:assertz1:962"></a><a class="pred" href="db.html#assertz/1">assertz/1</a> 
assert the clause as last clause. The deprecated <a id="idx:assert1:963"></a><a class="pred" href="db.html#assert/1">assert/1</a> 
is equivalent to <a id="idx:assertz1:964"></a><a class="pred" href="db.html#assertz/1">assertz/1</a>. 
If the program space for the target module is limited (see <a id="idx:setmodule1:965"></a><a class="pred" href="manipmodule.html#set_module/1">set_module/1</a>), <a id="idx:asserta1:966"></a><a class="pred" href="db.html#asserta/1">asserta/1</a> 
can raise a
<code>resource_error(program_space)</code> exception. The example below 
adds two facts and a rule. Note the double parentheses around the rule.

<pre class="code">
?- assertz(parent('Bob', 'Jane')).
?- assertz(female('Jane')).
?- assertz((mother(Child, Mother) :-
                parent(Child, Mother),
                female(Mother))).
</pre>

</dd>
<dt class="pubdef"><a id="asserta/2"><strong>asserta</strong>(<var>+Term, 
-Reference</var>)</a></dt>
<dt class="pubdef"><a id="assertz/2"><strong>assertz</strong>(<var>+Term, 
-Reference</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[deprecated]</span><a id="assert/2"><strong>assert</strong>(<var>+Term, 
-Reference</var>)</a></dt>
<dd class="defbody">
Equivalent to <a id="idx:asserta1:967"></a><a class="pred" href="db.html#asserta/1">asserta/1</a>, <a id="idx:assertz1:968"></a><a class="pred" href="db.html#assertz/1">assertz/1</a>, <a id="idx:assert1:969"></a><a class="pred" href="db.html#assert/1">assert/1</a>, 
but in addition unifies
<var>Reference</var> with a handle to the asserted clauses. The handle 
can be used to access this clause with <a id="idx:clause3:970"></a><a class="pred" href="examineprog.html#clause/3">clause/3</a> 
and <a id="idx:erase1:971"></a><a class="pred" href="db.html#erase/1">erase/1</a>.
</dd>
</dl>

<p><h4 id="sec:transactions"><a id="sec:4.14.1.1"><span class="sec-nr">4.14.1.1</span> <span class="sec-title">Transactions</span></a></h4>

<a id="sec:transactions"></a>

<p><a id="idx:transaction:972"></a><a id="idx:isolation:973"></a>Traditionally, 
Prolog database updates add or remove individual clauses. The <em>Logical 
Update View</em> ensures that a goal that is started on a dynamic 
predicate does not see modifications due to <a id="idx:assert1:974"></a><a class="pred" href="db.html#assert/1">assert/1</a> 
or
<a id="idx:retract1:975"></a><a class="pred" href="db.html#retract/1">retract/1</a> 
during its life time. See <a class="sec" href="db.html#sec:4.14.5">section 
4.14.5</a>. In a multi-threaded context this assumption still holds for 
individual predicates: concurrent modifications to a dynamic predicate 
are invisible.

<p><em>Transactions</em> allow running a goal in <em>isolation</em>. The 
goals running inside the transaction&lsquo;see&rsquo;the database as it 
was when the transaction was started together with database changes done 
by the transaction goal. Other threads see no changes until the 
transaction is
<em>committed</em>. The commit, also if it involved multiple clauses 
spread over multiple predicates, becomes <em>atomically</em> visible to 
other threads. Transactions have several benefits
<cite><a class="cite" href="Bibliography.html#DBLP:journals/corr/abs-1301-7669">Wielemaker, 
2013</a></cite>

<p>
<ul class="latex">
<li>If a database update requires multiple <a id="idx:assert1:976"></a><a class="pred" href="db.html#assert/1">assert/1</a> 
and/or <a id="idx:retract1:977"></a><a class="pred" href="db.html#retract/1">retract/1</a> 
operations, a transaction ensure either all are executed or the database 
remains unchanged. Notably unexpected exceptions or failures cannot 
leave the database in an inconsistent state.

<p>
<li>Other threads do not see the intermediate inconsistent states when a 
database update that consists of multiple assert and/or retract is 
performed in a transaction. This notably avoids the need to use locks 
(see <a id="idx:withmutex2:978"></a><a class="pred" href="threadsync.html#with_mutex/2">with_mutex/2</a>) 
in threads that read the data. A reading thread may still need to use <a id="idx:snapshot1:979"></a><a class="pred" href="db.html#snapshot/1">snapshot/1</a> 
if a goal depends on multiple calls to dynamic predicates. Unlike locks, 
transaction and snapshot based synchronization allows both readers and 
writers to make progress simultaneously.<sup class="fn">88<span class="fn-text"><em>Read-write</em> 
locks also provide readers and writers to make progress simultaneously, 
but readers see all intermediate states rather than a consistent state.</span></sup>

<p>Transactions on their own <b>do not guarantee consistency</b>. For 
example, when running the code below to update the temperature 
concurrently from multiple threads it is possible for the global state 
to have multiple temperature/1 clauses.

<pre class="code">
update_temperature(Temp) :-
    transaction(( retractall(temperature(_)),
                  asserta(temperature(Temp)))).
</pre>

<p>Global <em>consistency</em> can be achieved by wrapping the above 
transaction using <a id="idx:withmutex2:980"></a><a class="pred" href="threadsync.html#with_mutex/2">with_mutex/2</a> 
or by using <a id="idx:transaction3:981"></a><a class="pred" href="db.html#transaction/3">transaction/3</a> 
with a
<em>constraint</em> that demands a single clause for temperature/1

<p>
<li>Transactions allow for &ldquo;what if&rdquo; reasoning over the 
dynamic database. This is particularly useful when combined with the 
deductive database facilities provided by tabling (see <a class="sec" href="tabling.html#sec:7">section 
7</a>).
</ul>

<p>SWI-Prolog transactions only affect the <em>dynamic</em> database. 
Static predicates are globally visible and shared at all times. In 
particular, transactions do not affect loading source files and thus, 
source files loaded inside a transaction (e.g., due to <em>autoloading</em>) 
are immediately globally visible. This may pose problems if loading 
source files provide clauses for dynamic predicates.

<dl class="latex">
<dt class="pubdef"><a id="transaction/1"><strong>transaction</strong>(<var>:Goal</var>)</a></dt>
<dt class="pubdef"><a id="transaction/2"><strong>transaction</strong>(<var>:Goal, 
+Options</var>)</a></dt>
<dd class="defbody">
Run <var>Goal</var> as <a id="idx:once1:982"></a><a class="pred" href="metacall.html#once/1">once/1</a> 
in a transaction. This implies that access to dynamic predicates&lsquo;sees&rsquo;the 
dynamic predicates at the moment the transaction is started, together 
with the modifications issued by
<var>Goal</var>. Thus, <var>Goal</var> does not see changes to dynamic 
predicates from other threads and other threads do not see modifications 
by
<var>Goal</var> (<em>isolation</em>). If <var>Goal</var> succeeds, all 
modifications become <em>atomically</em> visible to the other threads. 
If <var>Goal</var> fails or raises an exception all local modifications 
are discarded and <a id="idx:transaction1:983"></a><a class="pred" href="db.html#transaction/1">transaction/1</a> 
fails or passes the exception.

<p>Currently the number of database changes inside a transaction (or 
snapshot, see <a id="idx:snapshot1:984"></a><a class="pred" href="db.html#snapshot/1">snapshot/1</a>) 
is limited to <var>2 ** 32 -1</var>. If this limit is exceeded a <code>representation_error(transaction_generations)</code> 
exception is raised.

<p>Transactions may be nested. The above mentioned limitation for the 
number of database changes applies to the combined number in nested 
transactions.

<p>If <var>Goal</var> succeeds, the transaction is <em>committed</em>. 
This implies that (1) any clause that is asserted in the transaction and 
not retracted in the same transaction is made <em>globally visible</em> 
and (2) and clause the existed before the transaction and is retracted 
in the transaction becomes <em>globally invisible</em>. Multiple 
transactions may retract the same clause and be committed, i.e., 
committing a retract that was already performed is a no-op. All 
modifications become
<em>atomically</em> visible to other threads. The <a id="idx:transaction3:985"></a><a class="pred" href="db.html#transaction/3">transaction/3</a> 
variation allows for verifying <em>constraints</em> just before the 
commit takes place.

<p><b>Clause ordering</b> Inside a transaction clauses can be added 
using <a id="idx:asserta1:986"></a><a class="pred" href="db.html#asserta/1">asserta/1</a> 
and <a id="idx:assertz1:987"></a><a class="pred" href="db.html#assertz/1">assertz/1</a>. 
If only a single transaction is active at any point in time transactions 
preserve the usual ordering of clauses. However, if multiple 
transactions manipulate the same predicate(s) concurrently (typically 
using <a id="idx:transaction3:988"></a><a class="pred" href="db.html#transaction/3">transaction/3</a>), 
the final order of the clauses is the order in which the transactions 
asserted the clauses and
<b>not</b> the order in which the transactions are committed.

<p>The <a id="idx:transaction1:989"></a><a class="pred" href="db.html#transaction/1">transaction/1</a> 
variant is equivalent to <code>transaction(Goal,[])</code>. The <a id="idx:transaction2:990"></a><a class="pred" href="db.html#transaction/2">transaction/2</a> 
variant processed the following options:

<dl class="latex">
<dt><strong>bulk</strong>(<var>+Boolean</var>)</dt>
<dd class="defbody">
When <code>true</code>, accumulate events from changes to dynamic 
predicates (see <a id="idx:prologlisten2:991"></a><a class="pred" href="prolog-event.html#prolog_listen/2">prolog_listen/2</a>) 
and trigger these events as part of the commit phase. This implies that 
if the transaction is not committed the events are never triggered. 
Failure to trigger the events causes the transaction to be discarded. 
Experimental.
</dd>
</dl>

</dd>
<dt class="pubdef"><a id="transaction/3"><strong>transaction</strong>(<var>:Goal, 
:Constraint, +Mutex</var>)</a></dt>
<dd class="defbody">
Similar to <a id="idx:transaction1:992"></a><a class="pred" href="db.html#transaction/1">transaction/1</a>, 
but allows verifying <var>Constraint</var> during the commit phase. This 
predicate follows the steps below. Any failure or exception during this 
process discards the transaction and releases
<var>Mutex</var> when applicable. <var>Constraint</var> may modify the 
database. Such modifications follow the semantics that apply for <var>Goal</var>.

<p>
<ul class="latex">
<li>Call <code>once(Goal)</code>
<li>Lock <var>Mutex</var>
<li>Change the visibility to the <em>current</em> global state combined 
with the changes made by <var>Goal</var>
<li>Call <code>once(Constraint)</code>
<li>Commit the changes
<li>Unlock <var>Mutex</var>.
</ul>

<p>This predicate is intended to execute multiple transactions with a 
time consuming <var>Goal</var> in part concurrently. For example, it can 
be used for a <em>Compare And Swap</em> (CAS) like design. We illustrate 
this using a simple counter in the code below. Note that the transaction 
fails if some other thread concurrently updated the counter. This is why 
we need the <a id="idx:repeat0:993"></a><a class="pred" href="control.html#repeat/0">repeat/0</a> 
and a final <a class="pred" href="control.html#!/0">!/0</a>. The 
CAS-style update is in general useful if <var>Goal</var> is expensive 
and conflicts are rare.

<pre class="code">
:- dynamic counter/1.

increment_counter(Delta) :-
    repeat,
      transaction(( counter(Value),
                    Value2 is Value+Delta,
                  ),
                  ( retract(counter(Value)),
                    asserta(counter(Value2))
                  ),
                  counter_lock),
    !.
</pre>

</dd>
<dt class="pubdef"><a id="snapshot/1"><strong>snapshot</strong>(<var>:Goal</var>)</a></dt>
<dd class="defbody">
Similar to <a id="idx:transaction1:994"></a><a class="pred" href="db.html#transaction/1">transaction/1</a>, 
but <em>always</em> discards the local modifications. In other words, <a id="idx:snapshot1:995"></a><a class="pred" href="db.html#snapshot/1">snapshot/1</a> 
allows a thread to examine a frozen state of the dynamic predicates 
and/or make isolated modifications without affecting other threads and 
without making permanent changes to the database. Where transactions 
allow the global state to be updated atomically from one consistent 
state to the next, a snapshot allows reasoning about a consistent state.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="current_transaction/1"><strong>current_transaction</strong>(<var>-Goal</var>)</a></dt>
<dd class="defbody">
True when called inside a transaction running <var>Goal</var>. This 
predicate generates candidates from the current (nested) transaction 
outward.
<var>Goal</var> is a plain goal if the calling context module is the 
same as matching <a id="idx:transaction1:996"></a><a class="pred" href="db.html#transaction/1">transaction/1</a> 
or <a id="idx:snapshot1:997"></a><a class="pred" href="db.html#snapshot/1">snapshot/1</a> 
and a qualified callable term otherwise. Note that this only enumerates 
transactions in the current thread.</dd>
<dt class="pubdef"><a id="transaction_updates/1"><strong>transaction_updates</strong>(<var>-Updates</var>)</a></dt>
<dd class="defbody">
Unify <var>Updates</var> with a list of database updates that would be 
effectuated if the transaction is going to be committed at this stage.
<var>Updates</var> is a list of terms defined below. The elements are 
sorted on the change generation, i.e., the order in which the operations 
were performed.

<dl class="latex">
<dt><strong>asserta</strong>(<var>+ClauseRef</var>)</dt>
<dt><strong>assertz</strong>(<var>+ClauseRef</var>)</dt>
<dd class="defbody">
The given clause will be asserted at the start or end. Note that due to 
competing transactions the clause may no longer be the first/last clause 
of the predicate.
</dd>
<dt><strong>erased</strong>(<var>+ClauseRef</var>)</dt>
<dd class="defbody">
The given clause will be removed. This may be due to <a id="idx:erase1:998"></a><a class="pred" href="db.html#erase/1">erase/1</a>,
<a id="idx:retract1:999"></a><a class="pred" href="db.html#retract/1">retract/1</a> 
or <a id="idx:retractall1:1000"></a><a class="pred" href="db.html#retractall/1">retractall/1</a>.
</dd>
</dl>

</dd>
</dl>

<p><h4 id="sec:transaction-impact"><a id="sec:4.14.1.2"><span class="sec-nr">4.14.1.2</span> <span class="sec-title">Impact 
of transactions</span></a></h4>

<a id="sec:transaction-impact"></a>

<p>Transactions interact with other facilities that depend on changing 
dynamic predicates. This section discusses these interactions.

<dl class="latex">
<dt><b> Last modified generation</b></dt>
<dd>
Using the <a id="idx:predicateproperty2:1001"></a><a class="pred" href="examineprog.html#predicate_property/2">predicate_property/2</a> 
property
<code>last_modified_generation(Generation)</code> we can determine 
whether a predicate was modified. When a predicate is changed inside a 
transaction this generation is not updated. The generation for dynamic 
predicates that are modified in the transaction is updated to the <em>commit 
generation</em> when the transaction is committed. Asking for the last 
modified generation <em>inside</em> the transaction examines the log of 
modified clauses and reports the generation as one of

<p>
<ul class="latex">
<li>The global modified generation if the predicate was not modified in 
the transaction and not modified outside the transaction to beyond the 
start generation of the transaction. If the modified generation is 
higher than the transaction start generation, this generation is 
reported.
<sup class="fn">bug<span class="fn-text">Note that the above implies 
that inside a transaction we observe a changing last modified generation 
for predicates that have only been modified outside the transaction 
while these changes are not visible.</span></sup>

<p>
<li>The transaction start generation plus the local generation of the 
last change if the predicate is modified inside the transaction.
</ul>
</dd>
<dt><b> Wait for database changes</b></dt>
<dd>
The predicate <a id="idx:threadwait2:1002"></a><a class="pred" href="threadcom.html#thread_wait/2">thread_wait/2</a> 
does not wakeup threads for changes inside a transaction. The wakeup is 
delayed until the transaction is committed. Note that <a id="idx:threadwait2:1003"></a><a class="pred" href="threadcom.html#thread_wait/2">thread_wait/2</a> 
cannot be meaningfully called from inside a transaction because no 
external entities can cause changes to the dynamic database inside the 
transaction.</dd>
<dt><b> Incremental tabling</b></dt>
<dd>
Consistency of tables must be restored if the transaction is rolled 
back. For local tables this is realised as follows:

<p>
<ul class="latex">
<li>Tables are either marked to be <em>invalidated</em> on rollback or, 
for <em>monotonic</em> tabling individual answers are marked to be 
removed on rollback.
<li>A table is marked to be <em>invalidated</em> if, while it is created 
or reevaluated, at least one dependent dynamic predicate has been 
modified inside the transaction.
<li>Answers are marked to be retracted when they result from monotonic 
reevaluation based on changes <em>inside</em> the transaction.
</ul>

<p>In other words: tables being reevaluated inside a transaction that do 
not depend on predicates modified inside the transaction remain valid. 
Monotonic tables that get new answers due to asserts inside the 
transaction have these answers removed during the rollback while the 
table remains valid. Monotonic tables that are for some reason 
invalidated inside the transaction are invalidated during the rollback.

<p>Correct interaction between tabling and transaction currently
<b>only deals with local tables</b>. <em>Shared</em> tables should not 
be combined with transactions. Future versions may improve on that. A 
possible route is to make a local copy from a shared table when 
(re)evaluation is performed inside a transaction.
</dd>
</dl>

<p><b>Status</b> SWI-Prolog transaction basics and API are stable. 
Interaction with other parts of the system that depend on dynamic 
predicates is still unsettled. Future versions may support 
non-determinism through transactions and snapshots.

<p><h3 id="sec:recdb"><a id="sec:4.14.2"><span class="sec-nr">4.14.2</span> <span class="sec-title">The 
recorded database</span></a></h3>

<a id="sec:recdb"></a>

<dl class="latex">
<dt class="pubdef"><a id="recorda/3"><strong>recorda</strong>(<var>+Key, 
+Term, -Reference</var>)</a></dt>
<dd class="defbody">
Assert <var>Term</var> in the recorded database under key <var>Key</var>.
<var>Key</var> is a small integer (range <a class="flag" href="flags.html#flag:min_tagged_integer">min_tagged_integer</a> 
...<a class="flag" href="flags.html#flag:max_tagged_integer">max_tagged_integer</a>, 
atom or compound term. If the key is a compound term, only the name and 
arity define the key.
<var>Reference</var> is unified with an opaque handle to the record (see
<a id="idx:erase1:1004"></a><a class="pred" href="db.html#erase/1">erase/1</a>).</dd>
<dt class="pubdef"><a id="recorda/2"><strong>recorda</strong>(<var>+Key, 
+Term</var>)</a></dt>
<dd class="defbody">
Equivalent to <code>recorda(<var>Key</var>, <var>Term</var>, _)</code>.</dd>
<dt class="pubdef"><a id="recordz/3"><strong>recordz</strong>(<var>+Key, 
+Term, -Reference</var>)</a></dt>
<dd class="defbody">
Equivalent to <a id="idx:recorda3:1005"></a><a class="pred" href="db.html#recorda/3">recorda/3</a>, 
but puts the <var>Term</var> at the tail of the terms recorded under <var>Key</var>.</dd>
<dt class="pubdef"><a id="recordz/2"><strong>recordz</strong>(<var>+Key, 
+Term</var>)</a></dt>
<dd class="defbody">
Equivalent to <code>recordz(<var>Key</var>, <var>Term</var>, _)</code>.</dd>
<dt class="pubdef"><a id="recorded/3"><strong>recorded</strong>(<var>?Key, 
?Value, ?Reference</var>)</a></dt>
<dd class="defbody">
True if <var>Value</var> is recorded under <var>Key</var> and has the 
given database <var>Reference</var>. If <var>Reference</var> is given, 
this predicate is semi-deterministic. Otherwise, it must be considered 
non-deterministic. If neither <var>Reference</var> nor <var>Key</var> is 
given, the triples are generated as in the code snippet below.<sup class="fn">89<span class="fn-text">Note 
that, without a given <var>Key</var>, some implementations return 
triples in the order defined by <a id="idx:recorda2:1006"></a><a class="pred" href="db.html#recorda/2">recorda/2</a> 
and <a id="idx:recordz2:1007"></a><a class="pred" href="db.html#recordz/2">recordz/2</a>.</span></sup> 
See also <a id="idx:currentkey1:1008"></a><a class="pred" href="examineprog.html#current_key/1">current_key/1</a>.

<pre class="code">
        current_key(Key),
        recorded(Key, Value, Reference)
</pre>

</dd>
<dt class="pubdef"><a id="recorded/2"><strong>recorded</strong>(<var>+Key, 
-Value</var>)</a></dt>
<dd class="defbody">
Equivalent to <code>recorded(<var>Key</var>, <var>Value</var>, _)</code>.</dd>
<dt class="pubdef"><a id="erase/1"><strong>erase</strong>(<var>+Reference</var>)</a></dt>
<dd class="defbody">
Erase a record or clause from the database. <var>Reference</var> is a 
db-reference returned by <a id="idx:recorda3:1009"></a><a class="pred" href="db.html#recorda/3">recorda/3</a>, <a id="idx:recordz3:1010"></a><a class="pred" href="db.html#recordz/3">recordz/3</a> 
or <a id="idx:recorded3:1011"></a><a class="pred" href="db.html#recorded/3">recorded/3</a>, <a id="idx:clause3:1012"></a><a class="pred" href="examineprog.html#clause/3">clause/3</a>,
<a id="idx:assert2:1013"></a><a class="pred" href="db.html#assert/2">assert/2</a>, <a id="idx:asserta2:1014"></a><a class="pred" href="db.html#asserta/2">asserta/2</a> 
or <a id="idx:assertz2:1015"></a><a class="pred" href="db.html#assertz/2">assertz/2</a>. 
Fail silently if the referenced object no longer exists. Notably, if 
multiple threads attempt to erase the same clause one will succeed and 
the others will fail.</dd>
<dt class="pubdef"><a id="instance/2"><strong>instance</strong>(<var>+Reference, 
-Term</var>)</a></dt>
<dd class="defbody">
Unify <var>Term</var> with the referenced clause or database record. 
Unit clauses are represented as <var>Head</var> :- <code>true</code>.
</dd>
</dl>

<p><h3 id="sec:flag"><a id="sec:4.14.3"><span class="sec-nr">4.14.3</span> <span class="sec-title">Flags</span></a></h3>

<a id="sec:flag"></a>

<p>The predicate <a id="idx:flag3:1016"></a><a class="pred" href="db.html#flag/3">flag/3</a> 
is the oldest way to store global non-backtrackable data in SWI-Prolog. 
Flags are global and shared by all threads. Their value is limited to 
atoms, small (64-bit) integers and floating point numbers. Flags are 
thread-safe. The flags described in this section must not be confused 
with <em>Prolog flags</em> described in
<a class="sec" href="flags.html#sec:2.12">section 2.12</a>.

<dl class="latex">
<dt class="pubdef"><a id="get_flag/2"><strong>get_flag</strong>(<var>+Key, 
-Value</var>)</a></dt>
<dd class="defbody">
True when <var>Value</var> is the value currently associated with <var>Key</var>. 
If <var>Key</var> does not exist, a new flag with value&lsquo;0&rsquo;(zero) 
is created.
</dd>
<dt class="pubdef"><a id="set_flag/2"><strong>set_flag</strong>(<var>+Key, 
Value</var>)</a></dt>
<dd class="defbody">
Set flag <var>Key</var> to <var>Value</var>. Value must be an atom, 
small (64-bit) integer or float.
</dd>
<dt class="pubdef"><a id="flag/3"><strong>flag</strong>(<var>+Key, -Old, 
+New</var>)</a></dt>
<dd class="defbody">
True when <var>Old</var> is the current value of the flag <var>Key</var> 
and the flag has been set to <var>New</var>. <var>New</var> can be an 
arithmetic expression. The update is <em>atomic</em>. This predicate can 
be used to create a <em>shared</em> global counter as illustrated in the 
example below.

<pre class="code">
next_id(Id) :-
    flag(my_id, Id, Id+1).
</pre>

<p></dd>
</dl>

<p><h3 id="sec:trie"><a id="sec:4.14.4"><span class="sec-nr">4.14.4</span> <span class="sec-title">Tries</span></a></h3>

<a id="sec:trie"></a>

<p>Tries (also called <em>digital tree</em>, <em>radix tree</em> or
<em>prefix tree</em> maintain a mapping between a variant of a term (see
<a class="pred" href="compare.html#=@=/2">=@=/2</a>) and a value. They 
have been introduced in SWI-Prolog 7.3.21 as part of the implementation 
of <em>tabling</em>. The current implementation is rather immature. In 
particular, the following limitations currently apply:

<p>
<ul class="compact">
<li>Tries are not thread-safe.
<li>Tries should not be modified while non-deterministic predicates such 
as <a id="idx:triegen3:1017"></a><a class="pred" href="db.html#trie_gen/3">trie_gen/3</a> 
are running on the trie.
<li>Terms cannot have <em>attributed variables</em>.
<li>Terms cannot be <em>cyclic</em>. Possibly this will not change 
because cyclic terms can only be supported after creating a canonical 
form of the term.
</ul>

<p><b>We give the definition of these predicates for reference and 
debugging tabled predicates. Future versions are likely to get a more 
stable and safer implementation. The API to tries should not be 
considered stable.</b>

<dl class="latex">
<dt class="pubdef"><a id="trie_new/1"><strong>trie_new</strong>(<var>-Trie</var>)</a></dt>
<dd class="defbody">
Create a new trie and unify <var>Trie</var> with a handle to the trie. 
The trie handle is a <em>blob</em>. Tries are subject to atom garbage 
collection.</dd>
<dt class="pubdef"><a id="trie_destroy/1"><strong>trie_destroy</strong>(<var>+Trie</var>)</a></dt>
<dd class="defbody">
Destroy <var>Trie</var>. This removes all nodes from the trie and causes 
further access to <var>Trie</var> to raise an existence_error exception. 
The handle itself is reclaimed by atom garbage collection.</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="is_trie/1"><strong>is_trie</strong>(<var>@Trie</var>)</a></dt>
<dd class="defbody">
True when <var>Trie</var> is a trie object. See also <a id="idx:currenttrie1:1018"></a><a class="pred" href="db.html#current_trie/1">current_trie/1</a>.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="current_trie/1"><strong>current_trie</strong>(<var>-Trie</var>)</a></dt>
<dd class="defbody">
True if <var>Trie</var> is a currently existing trie. As this enumerates 
and then filters all known atoms this predicate is slow and should only 
be used for debugging purposes. See also <a id="idx:istrie1:1019"></a><a class="pred" href="db.html#is_trie/1">is_trie/1</a>.</dd>
<dt class="pubdef"><a id="trie_insert/2"><strong>trie_insert</strong>(<var>+Trie, 
+Key</var>)</a></dt>
<dd class="defbody">
Insert the term <var>Key</var> into <var>Trie</var>. If <var>Key</var> 
is already part of <var>Trie</var> the predicates <em>fails</em> 
silently. This is the same as <a id="idx:trieinsert3:1020"></a><a class="pred" href="db.html#trie_insert/3">trie_insert/3</a>, 
but using a fixed reserved <var>Value</var>.</dd>
<dt class="pubdef"><a id="trie_insert/3"><strong>trie_insert</strong>(<var>+Trie, 
+Key, +Value</var>)</a></dt>
<dd class="defbody">
Insert the term <var>Key</var> into <var>Trie</var> and associate it 
with
<var>Value</var>. <var>Value</var> can be any term. If <var>Key</var>-<var>Value</var> 
is already part of <var>Trie</var>, the predicates <em>fails</em> 
silently. If <var>Key</var> is in <var>Trie</var> associated with a 
different value, a
<code>permission_error</code> is raised.</dd>
<dt class="pubdef"><a id="trie_update/3"><strong>trie_update</strong>(<var>+Trie, 
+Key, +Value</var>)</a></dt>
<dd class="defbody">
As <a id="idx:trieinsert3:1021"></a><a class="pred" href="db.html#trie_insert/3">trie_insert/3</a>, 
but if <var>Key</var> is in <var>Trie</var>, its associated value is <em>updated</em>.</dd>
<dt class="pubdef"><a id="trie_insert/4"><strong>trie_insert</strong>(<var>+Trie, 
+Term, +Value, -Handle</var>)</a></dt>
<dd class="defbody">
As <a id="idx:trieinsert3:1022"></a><a class="pred" href="db.html#trie_insert/3">trie_insert/3</a>, 
returning a handle to the trie node. This predicate is currently unsafe 
as <var>Handle</var> is an integer used to encode a pointer. It was used 
to implement a pure Prolog version of the <code>library(tabling)</code> 
library.</dd>
<dt class="pubdef"><a id="trie_delete/3"><strong>trie_delete</strong>(<var>+Trie, 
+Key, ?Value</var>)</a></dt>
<dd class="defbody">
Delete <var>Key</var> from <var>Trie</var> if the value associated with <var>Key</var> 
unifies with <var>Value</var>.</dd>
<dt class="pubdef"><a id="trie_lookup/3"><strong>trie_lookup</strong>(<var>+Trie, 
+Key, -Value</var>)</a></dt>
<dd class="defbody">
True if the term <var>Key</var> is in <var>Trie</var> and associated 
with
<var>Value</var>.</dd>
<dt class="pubdef"><a id="trie_term/2"><strong>trie_term</strong>(<var>+Handle, 
-Term</var>)</a></dt>
<dd class="defbody">
True when <var>Term</var> is a copy of the term associated with <var>Handle</var>. 
The result is undefined (including crashes) if <var>Handle</var> is not 
a handle returned by <a id="idx:trieinsertnew3:1023"></a><span class="pred-ext">trie_insert_new/3</span> 
or the node has been removed afterwards.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="trie_gen/2"><strong>trie_gen</strong>(<var>+Trie, 
?Key</var>)</a></dt>
<dd class="defbody">
True when <var>Key</var> is a member of <var>Trie</var>. See also
<a id="idx:triegencompiled2:1024"></a><a class="pred" href="db.html#trie_gen_compiled/2">trie_gen_compiled/2</a>.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="trie_gen/3"><strong>trie_gen</strong>(<var>+Trie, 
?Key, -Value</var>)</a></dt>
<dd class="defbody">
True when <var>Key</var> is associated with <var>Value</var> in <var>Trie</var>. 
Backtracking retrieves all pairs. Currently scans the entire trie, even 
if <var>Key</var> is partly known. Currently unsafe if <var>Trie</var> 
is modified while the values are being enumerated. See also
<a id="idx:triegencompiled3:1025"></a><a class="pred" href="db.html#trie_gen_compiled/3">trie_gen_compiled/3</a>.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="trie_gen_compiled/2"><strong>trie_gen_compiled</strong>(<var>+Trie, 
?Key</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="trie_gen_compiled/3"><strong>trie_gen_compiled</strong>(<var>+Trie, 
?Key, -Value</var>)</a></dt>
<dd class="defbody">
Similar to <a id="idx:triegen3:1026"></a><a class="pred" href="db.html#trie_gen/3">trie_gen/3</a>, 
but uses a <em>compiled</em> representation of
<var>Trie</var>. The compiled representation is created lazily and 
manipulations of the trie (insert, delete) invalidate the current 
compiled representation. The compiled representation generates answers 
faster and, as it runs on a snapshot of the trie, is immune to 
concurrent modifications of the trie. This predicate is used to generate 
answers from <em>answer tries</em> as used for tabled execution. See <a class="sec" href="tabling.html#sec:7">section 
7</a>.</dd>
<dt class="pubdef"><span class="pred-tag">[nondet]</span><a id="trie_property/2"><strong>trie_property</strong>(<var>?Trie, 
?Property</var>)</a></dt>
<dd class="defbody">
True if <var>Trie</var> exists with <var>Property</var>. Intended for 
debugging and statistical purposes. Retrieving some of these properties 
visit all nodes of the trie. Defined properties are

<dl class="latex">
<dt><strong>value_count</strong>(<var>-Count</var>)</dt>
<dd class="defbody">
Number of key-value pairs in the trie.
</dd>
<dt><strong>node_count</strong>(<var>-Count</var>)</dt>
<dd class="defbody">
Number of nodes in the trie.
</dd>
<dt><strong>size</strong>(<var>-Bytes</var>)</dt>
<dd class="defbody">
Required storage space of the trie.
</dd>
<dt><strong>compiled_size</strong>(<var>-Bytes</var>)</dt>
<dd class="defbody">
Required storage space for the compiled representation as used by <a id="idx:triegencompiled2:1027"></a><a class="pred" href="db.html#trie_gen_compiled/2">trie_gen_compiled/2</a>,3.
</dd>
<dt><strong>hashed</strong>(<var>-Count</var>)</dt>
<dd class="defbody">
Number of nodes that use a hashed index to its children.
</dd>
<dt><strong>lookup_count</strong>(<var>-Count</var>)</dt>
<dd class="defbody">
Number of <a id="idx:trielookup3:1028"></a><a class="pred" href="db.html#trie_lookup/3">trie_lookup/3</a> 
calls (only when compiled with
<code>O_TRIE_STATS</code>).
</dd>
<dt><strong>gen_call_count</strong>(<var>-Count</var>)</dt>
<dd class="defbody">
Number of <a id="idx:triegen3:1029"></a><a class="pred" href="db.html#trie_gen/3">trie_gen/3</a> 
calls (only when compiled with
<code>O_TRIE_STATS</code>).
</dd>
<dt><strong>wait</strong>(<var>-Count</var>)</dt>
<dd class="defbody">
Number of times a thread waited on this trie for another thread to 
complete it (shared tabling, only when compiled with
<code>O_TRIE_STATS</code>).
</dd>
<dt><strong>deadlock</strong>(<var>-Count</var>)</dt>
<dd class="defbody">
Number of times this trie was part of a deadlock and its completion was 
abandoned (shared tabling, only when compiled with
<code>O_TRIE_STATS</code>).
</dd>
</dl>

<p>In addition, a number of additional properties are defined on
<em>answer tries</em>.

<dl class="latex">
<dt><strong>invalidated</strong>(<var>-Count</var>)</dt>
<dd class="defbody">
Number of times the trie was invalidated (incremental tabling).
</dd>
<dt><strong>reevaluated</strong>(<var>-Count</var>)</dt>
<dd class="defbody">
Number of times the trie was re-evaluated (incremental tabling).
</dd>
<dt><strong>idg_affected_count</strong>(<var>-Count</var>)</dt>
<dd class="defbody">
Number of answer tries affected by this one (incremental tabling).
</dd>
<dt><strong>idg_dependent_count</strong>(<var>-Count</var>)</dt>
<dd class="defbody">
Number of answer tries this one depends on (incremental tabling).
</dd>
<dt><strong>idg_size</strong>(<var>-Bytes</var>)</dt>
<dd class="defbody">
Number of bytes in the IDG node representation.
</dd>
</dl>

</dd>
</dl>

<p><h3 id="sec:update"><a id="sec:4.14.5"><span class="sec-nr">4.14.5</span> <span class="sec-title">Update 
view</span></a></h3>

<a id="sec:update"></a>

<p><a id="idx:logicalupdateview:1030"></a><a id="idx:immediateupdateview:1031"></a><a id="idx:updateview:1032"></a>Traditionally, 
Prolog systems used the <em>immediate update view</em>: new clauses 
became visible to predicates backtracking over dynamic predicates 
immediately, and retracted clauses became invisible immediately.

<p>Starting with SWI-Prolog 3.3.0 we adhere to the <em>logical update 
view</em>, where backtrackable predicates that enter the definition of a 
predicate will not see any changes (either caused by <a id="idx:assert1:1033"></a><a class="pred" href="db.html#assert/1">assert/1</a> 
or
<a id="idx:retract1:1034"></a><a class="pred" href="db.html#retract/1">retract/1</a>) 
to the predicate. This view is the ISO standard, the most commonly used 
and the most&lsquo;safe&rsquo;.<sup class="fn">90<span class="fn-text">For 
example, using the immediate update view, no call to a dynamic predicate 
is deterministic.</span></sup> Logical updates are realised by keeping 
reference counts on predicates and <em>generation</em> information on 
clauses. Each change to the database causes an increment of the 
generation of the database. Each goal is tagged with the generation in 
which it was started. Each clause is flagged with the generation it was 
created in as well as the generation it was erased from. Only clauses 
with a&lsquo;created&rsquo; ...&lsquo;erased&rsquo;interval that 
encloses the generation of the current goal are considered visible.

<p><h3 id="sec:hashterm"><a id="sec:4.14.6"><span class="sec-nr">4.14.6</span> <span class="sec-title">Indexing 
databases</span></a></h3>

<a id="sec:hashterm"></a>

<p><a id="idx:indexingtermhashes:1035"></a>The indexing capabilities of 
SWI-Prolog are described in
<a class="sec" href="jitindex.html#sec:2.17">section 2.17</a>. 
Summarizing, SWI-Prolog creates indexes for any applicable argument, 
pairs of arguments and indexes on the arguments of compound terms when 
applicable. Extended JIT indexing is not widely supported among Prolog 
implementations. Programs that aim at portability should consider using <a id="idx:termhash2:1036"></a><a class="pred" href="db.html#term_hash/2">term_hash/2</a> 
and <a id="idx:termhash4:1037"></a><a class="pred" href="db.html#term_hash/4">term_hash/4</a> 
to design their database such that indexing on constant or functor 
(name/arity reference) on the first argument is sufficient. In some 
cases, using the predicates below to add one or more additional columns 
(arguments) to a database predicate may improve performance. The overall 
design of code using these predicates is given below. Note that as <a id="idx:termhash2:1038"></a><a class="pred" href="db.html#term_hash/2">term_hash/2</a> 
leaves the hash unbound if <var>Term</var> is not ground. This causes 
the lookup to be fast if <var>Term</var> is ground and correct (but 
slow) otherwise.

<pre class="code">
:- dynamic
    x/2.

assert_x(Term) :-
    term_hash(Term, Hash),
    assertz(x(Hash, Term)).

x(Term) :-
    term_hash(Term, Hash),
    x(Hash, Term).
</pre>

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="term_hash/2"><strong>term_hash</strong>(<var>+Term, 
-HashKey</var>)</a></dt>
<dd class="defbody">
If <var>Term</var> is a ground term (see <a id="idx:ground1:1039"></a><a class="pred" href="typetest.html#ground/1">ground/1</a>), <var>HashKey</var> 
is unified with a positive integer value that may be used as a hash key 
to the value. If <var>Term</var> is not ground, the predicate leaves <var>HashKey</var> 
an unbound variable. Hash keys are in the range <var>0 ... 16,777,215</var>, 
the maximal integer that can be stored efficiently on both 32 and 64 bit 
platforms.

<p>This predicate may be used to build hash tables as well as to exploit 
argument indexing to find complex terms more quickly.

<p>The hash key does not rely on temporary information like addresses of 
atoms and may be assumed constant over different invocations and 
versions of SWI-Prolog.<sup class="fn">91<span class="fn-text">Last 
change: version 5.10.4</span></sup> Hashes differ between big and little 
endian machines. The <a id="idx:termhash2:1040"></a><a class="pred" href="db.html#term_hash/2">term_hash/2</a> 
predicate is cycle-safe.<sup class="fn">bug<span class="fn-text">All 
arguments that (indirectly) lead to a cycle have the same hash key.</span></sup></dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="term_hash/4"><strong>term_hash</strong>(<var>+Term, 
+Depth, +Range, -HashKey</var>)</a></dt>
<dd class="defbody">
As <a id="idx:termhash2:1041"></a><a class="pred" href="db.html#term_hash/2">term_hash/2</a>, 
but only considers <var>Term</var> to the specified
<var>Depth</var>. The top-level term has depth 1, its arguments have 
depth 2, etc. That is, <var><var>Depth</var> = 0</var> hashes nothing; <var><var>Depth</var> 
= 1</var> hashes atomic values or the functor and arity of a compound 
term, not its arguments; <var><var>Depth</var> = 2</var> also indexes 
the immediate arguments, etc.

<p><var>HashKey</var> is in the range <var>[0 ...<var>Range</var>-1]</var>. <var>Range</var> 
must be in the range <var>[1 ... 2147483647]</var>.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="variant_sha1/2"><strong>variant_sha1</strong>(<var>+Term, 
-SHA1</var>)</a></dt>
<dd class="defbody">
Compute a SHA1-hash from <var>Term</var>. The hash is represented as a 
40-byte hexadecimal atom. Unlike <a id="idx:termhash2:1042"></a><a class="pred" href="db.html#term_hash/2">term_hash/2</a> 
and friends, this predicate produces a hash key for non-ground terms. 
The hash is invariant over variable-renaming (see <a class="pred" href="compare.html#=@=/2">=@=/2</a>) 
and constants over different invocations of Prolog.<sup class="fn">bug<span class="fn-text">The 
hash depends on word order (big/little-endian) and the wordsize (32/64 
bits).</span></sup>

<p>This predicate raises an exception when trying to compute the hash on 
a cyclic term or attributed term. Attributed terms are not handled 
because <a id="idx:subsumeschk2:1043"></a><a class="pred" href="terms.html#subsumes_chk/2">subsumes_chk/2</a> 
is not considered well defined for attributed terms. Cyclic terms are 
not supported because this would require establishing a canonical cycle. 
That is, given A=[a|A] and B=[a,a|B],
<var>A</var> and <var>B</var> should produce the same hash. This is not 
(yet) implemented.

<p>This hash was developed for lookup of solutions to a goal stored in a 
table. By using a cryptographic hash, heuristic algorithms can often 
ignore the possibility of hash collisions and thus avoid storing the 
goal term itself as well as testing using <a class="pred" href="compare.html#=@=/2">=@=/2</a>.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="variant_hash/2"><strong>variant_hash</strong>(<var>+Term, 
-HashKey</var>)</a></dt>
<dd class="defbody">
Similar to <a id="idx:variantsha12:1044"></a><a class="pred" href="db.html#variant_sha1/2">variant_sha1/2</a>, 
but using a non-cryptographic hash and produces an integer result like <a id="idx:termhash2:1045"></a><a class="pred" href="db.html#term_hash/2">term_hash/2</a>. 
This version does deal with attributed variables, processing them as 
normal variables. This hash is primarily intended to speedup finding 
variant terms in a set of terms.
<sup class="fn">bug<span class="fn-text">As <a id="idx:variantsha12:1046"></a><a class="pred" href="db.html#variant_sha1/2">variant_sha1/2</a>, 
cyclic terms result in an exception.</span></sup>
</dd>
</dl>

<p></body></html>