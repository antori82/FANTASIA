<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
<title>SWI-Prolog 9.2.9 Reference Manual: Section 12.4</title><link rel="home" href="index.html">
<link rel="contents" href="Contents.html">
<link rel="index" href="DocIndex.html">
<link rel="summary" href="summary.html">
<link rel="previous" href="foreigntypes.html">
<link rel="next" href="plld.html">

<style type="text/css">

/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef, dt.multidef
{ color: #fff;
padding: 2px 10px 0px 10px;
margin-bottom: 5px;
font-size: 18px;
vertical-align: middle;
overflow: hidden;
}

dt.pubdef { background-color: #0c3d6e; }
dt.multidef { background-color: #ef9439; }

.bib dd
{ margin-bottom: 1em;
}

.bib dt
{ float: left;
margin-right: 1.3ex;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{
}

span.sec-title
{
}

span.pred-ext
{ font-weight: bold;
}

span.pred-tag
{ float: right;
padding-top: 0.2em;
font-size: 80%;
font-style: italic;
color: #fff;
}

div.caption
{ width: 80%;
margin: auto;
text-align:center;
}

/* Footnotes */
.fn {
color: red;
font-size: 70%;
}

.fn-text, .fnp {
position: absolute;
top: auto;
left: 10%;
border: 1px solid #000;
box-shadow: 5px 5px 5px #888;
display: none;
background: #fff;
color: #000;
margin-top: 25px;
padding: 8px 12px;
font-size: larger;
}

sup:hover span.fn-text
{ display: block;
}

/* Lists */

dl.latex
{ margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.latex dl.latex dd.defbody
{ margin-bottom: 0.5ex;
}

/* PlDoc Tags */

dl.tags
{ font-size: 90%;
margin-left: 5ex;
margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.tags dt
{ margin-left: 0pt;
font-weight: bold;
}

dl.tags dd
{ margin-left: 3ex;
}

td.param
{ font-style: italic;
font-weight: bold;
}

/* Index */

dt.index-sep
{ font-weight: bold;
font-size: +1;
margin-top: 1ex;
}

/* Tables */

table.center
{ margin: auto;
}

table.latex
{ border-collapse:collapse;
}

table.latex tr
{ vertical-align: text-top;
}

table.latex td,th
{ padding: 2px 1em;
}

table.latex tr.hline td,th
{ border-top: 1px solid black;
}

table.frame-box
{ border: 2px solid black;
}

</style>
</head>
<body style="background:white">
<div class="navigate"><a class="nav" href="index.html"><img src="home.gif" alt="Home"></a>
<a class="nav" href="Contents.html"><img src="index.gif" alt="Contents"></a>
<a class="nav" href="DocIndex.html"><img src="yellow_pages.gif" alt="Index"></a>
<a class="nav" href="summary.html"><img src="info.gif" alt="Summary"></a>
<a class="nav" href="foreigntypes.html"><img src="prev.gif" alt="Previous"></a>
<a class="nav" href="plld.html"><img src="next.gif" alt="Next"></a>
</div>
<h2 id="sec:foreigninclude"><a id="sec:12.4"><span class="sec-nr">12.4</span> <span class="sec-title">The 
Foreign Include File</span></a></h2>

<a id="sec:foreigninclude"></a>

<p><h3 id="sec:foreign-control"><a id="sec:12.4.1"><span class="sec-nr">12.4.1</span> <span class="sec-title">Argument 
Passing and Control</span></a></h3>

<a id="sec:foreign-control"></a>

<p>If Prolog encounters a foreign predicate at run time it will call a 
function specified in the predicate definition of the foreign predicate. 
The arguments <var>1, ... , &lt;<var>arity</var>&gt;</var> pass the 
Prolog arguments to the goal as Prolog terms. Foreign functions should 
be declared of type
<code>foreign_t</code>.

<p>All the arguments to a foreign predicate must be of type
<code>term_t</code>. The only operation that is allowed with an argument 
to a foreign predicate is unification; for anything that might 
over-write the term, you must use a copy created by
<a class="func" href="foreigntypes.html#PL_copy_term_ref()">PL_copy_term_ref()</a>. 
For an example, see <a class="func" href="foreigninclude.html#PL_unify_list()">PL_unify_list()</a>.

<p>Deterministic foreign functions return with either <code>TRUE</code> 
(success) or <code>FALSE</code> (failure).<sup class="fn">214<span class="fn-text"><code>SWI-Prolog.h</code> 
defines the macros <code>PL_succeed</code> and <code>PL_fail</code> to 
return with success or failure. These macros should be considered 
deprecated.</span></sup> The foreign function may raise an exception 
using
<a class="func" href="foreigninclude.html#PL_raise_exception()">PL_raise_exception()</a> 
or one of the shorthands for commonly used exceptions such as <a class="func" href="foreigninclude.html#PL_type_error()">PL_type_error()</a>. 
Note that the C language does not provide exception handling and 
therefore the functions that raise an exception return (with the value <code>FALSE</code>). 
Functions that raise an exception <em>must</em> return <code>FALSE</code>.

<p><h4 id="sec:foreignnondet"><a id="sec:12.4.1.1"><span class="sec-nr">12.4.1.1</span> <span class="sec-title">Non-deterministic 
Foreign Predicates</span></a></h4>

<a id="sec:foreignnondet"></a>

<p>By default foreign predicates are deterministic. Using the
<code>PL_FA_NONDETERMINISTIC</code> attribute (see <a class="func" href="foreigninclude.html#PL_register_foreign()">PL_register_foreign()</a>) 
it is possible to register a predicate as a non-deterministic predicate. 
Writing non-deterministic foreign predicates is slightly more 
complicated as the foreign function needs context information for 
generating the next solution. Note that the same foreign function should 
be prepared to be simultaneously active in more than one goal. Suppose 
the natural_number_below_n/2 is a non-deterministic foreign predicate, 
backtracking over all natural numbers lower than the first argument. Now 
consider the following predicate:

<pre class="code">
quotient_below_n(Q, N) :-
        natural_number_below_n(N, N1),
        natural_number_below_n(N, N2),
        Q =:= N1 / N2, !.
</pre>

<p>In this predicate the function natural_number_below_n/2 
simultaneously generates solutions for both its invocations.

<p>Non-deterministic foreign functions should be prepared to handle 
three different calls from Prolog:

<p>
<ul class="latex">
<li><i>Initial call (<code>PL_FIRST_CALL</code>)</i><br>
Prolog has just created a frame for the foreign function and asks it to 
produce the first answer.
<li><i>Redo call (<code>PL_REDO</code>)</i><br>
The previous invocation of the foreign function associated with the 
current goal indicated it was possible to backtrack. The foreign 
function should produce the next solution.
<li><i>Terminate call (<code>PL_PRUNED</code>)</i><br>
The choice point left by the foreign function has been destroyed by a 
cut or exception. The foreign function is given the opportunity to clean 
the environment. The context handle is the only meaningful argument -- 
the term arguments to the call are <code>(term_t)0</code>.
</ul>

<p>Both the context information and the type of call is provided by an 
argument of type <code>control_t</code> appended to the argument list 
for deterministic foreign functions. The macro <a class="func" href="foreigninclude.html#PL_foreign_control()">PL_foreign_control()</a> 
extracts the type of call from the control argument. The foreign 
function can pass a context handle using the <code>PL_retry*()</code> 
macros and extract the handle from the extra argument using the
<code>PL_foreign_context*()</code> macro.

<dl class="latex">
<dt class="pubdef"><a id="PL_retry()"><var>(return) foreign_t</var> <strong>PL_retry</strong>(<var>intptr_t 
value</var>)</a></dt>
<dd class="defbody">
The foreign function succeeds while leaving a choice point. On 
backtracking over this goal the foreign function will be called again, 
but the control argument now indicates it is a&lsquo;Redo&rsquo;call and 
the macro <a class="func" href="foreigninclude.html#PL_foreign_context()">PL_foreign_context()</a> 
returns the handle passed via
<a class="func" href="foreigninclude.html#PL_retry()">PL_retry()</a>. 
This handle is a signed value two bits smaller than a pointer, i.e., 30 
or 62 bits (two bits are used for status indication). Defined as <code>return 
_<a class="func" href="foreigninclude.html#PL_retry()">PL_retry(n)</a></code>. 
See also <b>PL_succeed()</b>.</dd>
<dt class="pubdef"><a id="PL_retry_address()"><var>(return) foreign_t</var> <strong>PL_retry_address</strong>(<var>void 
*</var>)</a></dt>
<dd class="defbody">
As <a class="func" href="foreigninclude.html#PL_retry()">PL_retry()</a>, 
but ensures an address as returned by <b>malloc()</b> is correctly 
recovered by <a class="func" href="foreigninclude.html#PL_foreign_context_address()">PL_foreign_context_address()</a>. 
Defined as <code>return _<a class="func" href="foreigninclude.html#PL_retry_address()">PL_retry_address(n)</a></code>. 
See also
<b>PL_succeed()</b>.</dd>
<dt class="pubdef"><a id="PL_foreign_control()"><var>int</var> <strong>PL_foreign_control</strong>(<var>control_t</var>)</a></dt>
<dd class="defbody">
Extracts the type of call from the control argument. The return values 
are described above. Note that the function should be prepared to handle 
the <code>PL_PRUNED</code> case and should be aware that the other 
arguments are not valid in this case.</dd>
<dt class="pubdef"><a id="PL_foreign_context()"><var>intptr_t</var> <strong>PL_foreign_context</strong>(<var>control_t</var>)</a></dt>
<dd class="defbody">
Extracts the context from the context argument. If the call type is
<code>PL_FIRST_CALL</code> the context value is 0L. Otherwise it is the 
value returned by the last <a class="func" href="foreigninclude.html#PL_retry()">PL_retry()</a> 
associated with this goal (both if the call type is <code>PL_REDO</code> 
or <code>PL_PRUNED</code>).</dd>
<dt class="pubdef"><a id="PL_foreign_context_address()"><var>void *</var> <strong>PL_foreign_context_address</strong>(<var>control_t</var>)</a></dt>
<dd class="defbody">
Extracts an address as passed in by <a class="func" href="foreigninclude.html#PL_retry_address()">PL_retry_address()</a>.</dd>
<dt class="pubdef"><a id="PL_foreign_context_predicate()"><var>predicate_t</var> <strong>PL_foreign_context_predicate</strong>(<var>control_t</var>)</a></dt>
<dd class="defbody">

<p>Fetch the Prolog predicate that is executing this function. Note that 
if the predicate is imported, the returned predicate refers to the final 
definition rather than the imported predicate; i.e., the module reported 
by <a class="func" href="foreigninclude.html#PL_predicate_info()">PL_predicate_info()</a> 
is the module in which the predicate is defined rather than the module 
where it was called. See also
<a class="func" href="foreigninclude.html#PL_predicate_info()">PL_predicate_info()</a>.
</dd>
</dl>

<p>Note: If a non-deterministic foreign function returns using <b>PL_succeed()</b> 
or <b>PL_fail()</b>, Prolog assumes the foreign function has cleaned its 
environment. <b>No</b> call with control argument <code>PL_PRUNED</code> 
will follow.

<p>The code of <a class="fig" href="foreigninclude.html#fig:nondetermf">figure 
5</a> shows a skeleton for a non-deterministic foreign predicate 
definition.

<pre class="code">
typedef struct                  /* define a context structure */
{ ...
} context;

foreign_t
my_function(term_t a0, term_t a1, control_t handle)
{ struct context * ctxt;

  switch( PL_foreign_control(handle) )
  { case PL_FIRST_CALL:
        if ( !(ctxt = malloc(sizeof *ctxt)) )
          return PL_resource_error("memory");
        &lt;initialize ctxt&gt;
        break;
    case PL_REDO:
        ctxt = PL_foreign_context_address(handle);
        break;
    case PL_PRUNED:
        ctxt = PL_foreign_context_address(handle);
        ...
        free(ctxt);
        return TRUE;
  }

  &lt;find first/next solution from ctxt&gt;
  ...
  // We fail */
  if ( &lt;no_solution&gt; )
  { free(ctx);
    return FALSE;
  }
  // We succeed without a choice point */
  if ( &lt;last_solution&gt; )
  { free(ctx);
    return TRUE;
  }
  // We succeed with a choice point */
  PL_retry_address(ctxt);
}
</pre>

<div class="caption"><b>Figure 5 : </b>Skeleton for non-deterministic 
foreign functions</div>
<a id="fig:nondetermf"></a>

<p><h4 id="sec:foreign-yield"><a id="sec:12.4.1.2"><span class="sec-nr">12.4.1.2</span> <span class="sec-title">Yielding 
from foreign predicates</span></a></h4>

<a id="sec:foreign-yield"></a>

<p>Starting with SWI-Prolog 8.5.5 we provide an experimental interface 
that allows using a SWI-Prolog engine for asynchronous processing. The 
idea is that an engine that calls a foreign predicate which would need 
to block may be suspended and later resumed. For example, consider an 
application that listens to a large number of network connections 
(sockets). SWI-Prolog offers three scenarios to deal with this:

<p>
<ol class="latex">
<li>Using a thread per connection. This model fits Prolog well as it 
allows to keep state in e.g. a DCG using <a id="idx:phrasefromstream2:2517"></a><a class="pred" href="pio.html#phrase_from_stream/2">phrase_from_stream/2</a>. 
Maintaining an operating system thread per connection uses a significant 
amount of resources though.

<p>
<li>Using <a id="idx:waitforinput3:2518"></a><a class="pred" href="streamstat.html#wait_for_input/3">wait_for_input/3</a> 
a single thread can wait for many connections. Each time input arrives 
we must associate this with a <em>state engine</em> and advance this 
engine using a chunk of input of unknown size. Programming a state 
engine in Prolog is typically a tedious job. Although we can use <em>delimited 
continuations</em> (see <a class="sec" href="delcont.html#sec:4.9">section 
4.9</a>) in some scenarios this is not a universal solution.

<p>
<li>Using the primitives from this section we can create an
<em>engine</em> (see <b>PL_engine_create()</b>) to handle a connection 
with the same benefits as using threads. When the engine calls a foreign 
predicate that would need to block it calls
<a class="func" href="foreigninclude.html#PL_yield_address()">PL_yield_address()</a> 
to suspend the engine. An overall scheduler watches for ready 
connections and calls <a class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</a> 
to resume the suspended engine. This approach allows processing many 
connections on the same operating system thread.
</ol>

<p>As is, these features can only used through the foreign language 
interface. It was added after discussion with with Mattijs van Otterdijk 
aiming for using SWI-Prolog together with Rust's
<a class="url" href="https://rust-lang.github.io/async-book/01_getting_started/01_chapter.html">asynchronous 
programming</a> support. Note that this feature is related to the engine 
API as described in <a class="sec" href="engines.html#sec:11">section 11</a>. 
It uis different though. Where the Prolog engine API allows for 
communicating with a Prolog engine, the facilities of this section 
merely allow an engine to suspend, to be resumed later.

<p>To prepare a query for asynchronous usage we first create an engine 
using <a class="func" href="foreignthread.html#PL_create_engine()">PL_create_engine()</a>. 
Next, we create a query in the engine using
<a class="func" href="foreigninclude.html#PL_open_query()">PL_open_query()</a> 
with the flags <code>PL_Q_ALLOW_YIELD</code> and
<code>PL_Q_EXT_STATUS</code>. A foreign predicate that needs to be 
capable of suspending must be registered using <a class="func" href="foreigninclude.html#PL_register_foreign()">PL_register_foreign()</a> 
and the flags
<code>PL_FA_VARARGS</code> and <code>PL_FA_NONDETERMINISTIC</code>; 
i.e., only non-det predicates can yield. This is no restriction as 
non-det predicate can always return <code>TRUE</code> to indicate 
deterministic success. Finally, <a class="func" href="foreigninclude.html#PL_yield_address()">PL_yield_address()</a> 
allows the predicate to yield control, preparing to resume similar to <a class="func" href="foreigninclude.html#PL_retry_address()">PL_retry_address()</a> 
does for non-deterministic results. <a class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</a> 
returns <code>PL_S_YIELD</code> if a predicate calls <a class="func" href="foreigninclude.html#PL_yield_address()">PL_yield_address()</a> 
and may be resumed by calling
<a class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</a> 
using the same query id (<var>qid</var>). We illustrate the above using 
some example fragments.

<p>First, let us create a predicate that can read the available input 
from a Prolog stream and yield if it would block. Note that our 
predicate
<em>must</em> the <code>PL_FA_VARARGS</code> interface, which implies 
the first argument is in <var>a0</var>, the second in <code>a0+1</code>, 
etc.<sup class="fn">215<span class="fn-text">the other foreign 
interfaces do not support the yield API.</span></sup>

<pre class="code">
/** read_or_block(+Stream, -String) is det.
*/

#define BUFSIZE 4096

static foreign_t
read_or_block(term_t a0, int arity, void *context)
{ IOSTREAM *s;

  switch(PL_foreign_control(context))
  { case PL_FIRST_CALL:
      if ( PL_get_stream(a0, &amp;s, SIO_INPUT) )
      { Sset_timeout(s, 0);
        break;
      }
      return FALSE;
    case PL_RESUME:
      s = PL_foreign_context_address(context);
      break;
    case PL_PRUNED:
      return PL_release_stream(s);
    default:
      assert(0);
      return FALSE;
  }

  char buf[BUFSIZE];

  size_t n = Sfread(buf, sizeof buf[0], sizeof buf / sizeof buf[0], s);
  if ( n == 0 )                     // timeout or error
  { if ( (s-&gt;flags&amp;SIO_TIMEOUT) )
      PL_yield_address(s);        // timeout: yield
    else
      return PL_release_stream(s);  // raise error
  } else
  { return ( PL_release_stream(s) &amp;&amp;
             PL_unify_chars(a0+1, PL_STRING|REP_ISO_LATIN_1, n, buf) );
  }
}
</pre>

<p>This function must be registered using <a class="func" href="foreigninclude.html#PL_register_foreign()">PL_register_foreign()</a>:

<pre class="code">
  PL_register_foreign("read_or_block", 2, read_or_block,
                      PL_FA_VARARGS|PL_FA_NONDETERMINISTIC);
</pre>

<p>Next, create an engine to run handle_connection/1 on a Prolog stream. 
Note that we omitted most of the error checking for readability. Also 
note that we must make our engine <em>current</em> using
<a class="func" href="foreignthread.html#PL_set_engine()">PL_set_engine()</a> 
before we can interact with it.

<pre class="code">
qid_t
start_connection(IOSTREAM *c)
{ predicate_t p = PL_predicate("handle_connection", 1, "user");

  PL_engine_t e = PL_create_engine(NULL);
  PL_engine_t old;
  if ( PL_set_engine(e, &amp;old) )
  { term_t av = PL_new_term_refs(1);
    PL_unify_stream(av+0, c);
    qid_t q = PL_open_query(e, NULL,
                            PL_Q_CATCH_EXCEPTION|
                                PL_Q_ALLOW_YIELD|
                                 PL_Q_EXT_STATUS,
                            p, av);
    PL_set_engine(old, NULL);
    return q;
  } /* else error */
}
</pre>

<p>Finally, our foreign code must manage this engine. Normally it will 
do so together with many other engines. First, we write a function that 
runs a query in the engine to which it belongs.<sup class="fn">216<span class="fn-text">Possibly, 
future versions of <a class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</a> 
may do that although the value is in general limited because interacting 
with the arguments of the query requires the query's engine to be 
current anyway.</span></sup>

<pre class="code">
int
PL_engine_next_solution(qid_t qid)
{ PL_engine_t old;
  int rc;

  if ( PL_set_engine(PL_query_engine(qid), &amp;old) == PL_ENGINE_SET )
  { rc = PL_next_solution(qid);

    PL_set_engine(old, NULL);
  } else
    rc = FALSE;

  return rc;
}
</pre>

<p>Now we can simply handle a connection using the loop below which 
restarts the query as long as it yields. Realistic code manages multiple 
queries and will (in this case) use the POSIX <b>poll()</b> or <b>select()</b> 
interfaces to activate the next query that can continue without 
blocking.

<pre class="code">
  int rc;
  do
  { rc = PL_engine_next_solution(qid);
  } while( rc == PL_S_YIELD );
</pre>

<p>After the query completes it must be closed using <a class="func" href="foreigninclude.html#PL_close_query()">PL_close_query()</a> 
or
<a class="func" href="foreigninclude.html#PL_cut_query()">PL_cut_query()</a>. 
The engine may be destroyed using <b>PL_engine_destroy()</b> or reused 
for a new query.

<dl class="latex">
<dt class="pubdef"><a id="PL_yield_address()"><var>(return) foreign_t</var> <strong>PL_yield_address</strong>(<var>void 
*</var>)</a></dt>
<dd class="defbody">
Cause <a class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</a> 
of the active query to return with
<code>PL_S_YIELD</code>. A subsequent call to <a class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</a> 
on the same query calls the foreign predicate again with the control 
status set to
<code>PL_RESUME</code>, after which <a class="func" href="foreigninclude.html#PL_foreign_context_address()">PL_foreign_context_address()</a> 
retrieves the address passed to this function. The state of the Prolog 
engine is maintained, including <code>term_t</code> handles. If the 
passed address needs to be invalidated the predicate must do so when 
returning either
<code>TRUE</code> or <code>FALSE</code>. If the engine terminates the 
predicate the predicate is called with status <code>PL_PRUNED</code>, in 
which case the predicate must cleanup.</dd>
<dt class="pubdef"><a id="PL_can_yield()"><var>int</var> <strong>PL_can_yield</strong>(<var>void</var>)</a></dt>
<dd class="defbody">
Returns <code>TRUE</code> when called from inside a foreign predicate if 
the query that (indirectly) calls this foreign predicate can yield using <a class="func" href="foreigninclude.html#PL_yield_address()">PL_yield_address()</a>. 
Returns <code>FALSE</code> when either there is no current query or the 
query cannot yield.
</dd>
</dl>

<p><b>Discussion</b> 

<p>Asynchronous processing has become popular with modern programming 
languages, especially those aiming at network communication. 
Asynchronous processing uses fewer resources than threads while avoiding 
most of the complications associated with thread synchronization if only 
a single thread is used to manage the various states. The lack of good 
support for destructive state updates in Prolog makes it attractive to 
use threads for dealing with multiple inputs. The fact that Prolog 
discourages using shared global data such as dynamic predicates 
typically makes multithreaded code easy to manage.

<p>It is not clear how much scalability we gain using Prolog engines 
instead of Prolog threads. The only difference between the two is the 
operating system task. Prolog engines are still rather memory intensive, 
mainly depending on the stack sizes. Global garbage collection (atoms 
and clauses) need to process all the stacks of all the engines and thus 
limit scalability.

<p>One possible future direction is to allow all (possibly) blocking 
Prolog predicates to use the yield facility and provide a Prolog API to 
manage sets of engines that use this type of yielding. As is, these 
features are designed to allow SWI-Prolog for cooperating with languages 
that provide asynchronous functions.

<p><h3 id="sec:foreign-atoms"><a id="sec:12.4.2"><span class="sec-nr">12.4.2</span> <span class="sec-title">Atoms 
and functors</span></a></h3>

<a id="sec:foreign-atoms"></a>

<p>The following functions provide for communication using atoms and 
functors.

<dl class="latex">
<dt class="pubdef"><a id="PL_new_atom()"><var>atom_t</var> <strong>PL_new_atom</strong>(<var>const 
char *</var>)</a></dt>
<dd class="defbody">
Return an atom handle for the given C-string. This function always 
succeeds. The returned handle is valid as long as the atom is referenced 
(see <a class="sec" href="foreigninclude.html#sec:12.4.2.1">section 
12.4.2.1</a>). Currently aborts the process with a <em>fatal error</em> 
on failure. Future versions may raise a resource exception and return <code>(atom_t)0</code>.

<p>The following atoms are provided as macros, giving access to the 
empty list symbol and the name of the list constructor. Prior to version&nbsp;7,
<code>ATOM_nil</code> is the same as <code><a class="func" href="foreigninclude.html#PL_new_atom()">PL_new_atom("[]")</a></code> 
and
<code>ATOM_dot</code> is the same as <code><a class="func" href="foreigninclude.html#PL_new_atom()">PL_new_atom(".")</a></code>. 
This is no longer the case in SWI-Prolog version&nbsp;7.

<dl class="latex">
<dt class="pubdef"><a id="ATOM_nil()"><var>atom_t</var> <strong>ATOM_nil</strong>(<var>A</var>)</a></dt>
<dd class="defbody">
tomic constant that represents the empty list. It is advised to use <a class="func" href="foreigninclude.html#PL_get_nil()">PL_get_nil()</a>, <a class="func" href="foreigninclude.html#PL_put_nil()">PL_put_nil()</a> 
or <a class="func" href="foreigninclude.html#PL_unify_nil()">PL_unify_nil()</a> 
where applicable.</dd>
<dt class="pubdef"><a id="ATOM_dot()"><var>atom_t</var> <strong>ATOM_dot</strong>(<var>A</var>)</a></dt>
<dd class="defbody">
tomic constant that represents the name of the list constructor. The 
list constructor itself is created using
<code><a class="func" href="foreigninclude.html#PL_new_functor()">PL_new_functor(ATOM_dot,2)</a></code>. 
It is advised to use
<a class="func" href="foreigninclude.html#PL_get_list()">PL_get_list()</a>, <a class="func" href="foreigninclude.html#PL_put_list()">PL_put_list()</a> 
or <a class="func" href="foreigninclude.html#PL_unify_list()">PL_unify_list()</a> 
where applicable.
</dd>
</dl>

</dd>
<dt class="pubdef"><a id="PL_new_atom_mbchars()"><var>atom_t</var> <strong>PL_new_atom_mbchars</strong>(<var>int 
rep, size_t len, const char *s</var>)</a></dt>
<dd class="defbody">
This function generalizes <a class="func" href="foreigninclude.html#PL_new_atom()">PL_new_atom()</a> 
and <a class="func" href="foreigninclude.html#PL_new_atom_nchars()">PL_new_atom_nchars()</a> 
while allowing for multiple encodings. The <var>rep</var> argument is 
one of
<code>REP_ISO_LATIN_1</code>, <code>REP_UTF8</code> or <code>REP_MB</code>. 
If
<var>len</var> is <code>(size_t)-1</code>, it is computed from <var>s</var> 
using
<b>strlen()</b>. Raises an exception if <var>s</var> violates <var>rep</var> 
and returns <code>(atom_t)0</code>. For other error conditions, see <a class="func" href="foreigninclude.html#PL_new_atom()">PL_new_atom()</a>.</dd>
<dt class="pubdef"><a id="PL_atom_mbchars()"><var>int</var> <strong>PL_atom_mbchars</strong>(<var>atom_t 
atom, size_t len, char *s, unsigned int flags</var>)</a></dt>
<dd class="defbody">
This function generalizes fetching the text associated with an atom. The 
encoding depends on the flags <code>REP_UTF8</code>, <code>REP_MB</code> 
or <code>REP_ISO_LATIN_1</code>. Storage is defined by the <code>BUF_*</code> 
flags as described with <a class="func" href="foreigninclude.html#PL_get_chars()">PL_get_chars()</a>. 
The flag <code>CVT_EXCEPTION</code> defines whether or not the function 
fails silently or raises a Prolog exception. This function may fail 
because <var>atom</var> is not a text atom but a <em>blob</em> (see <a class="sec" href="foreigninclude.html#sec:12.4.10">section 
12.4.10</a>), conversion to the requested encoding is not possible or a 
resource error occurs.</dd>
<dt class="pubdef"><a id="PL_atom_chars()"><var>const char*</var> <strong>PL_atom_chars</strong>(<var>atom_t 
atom</var>)</a></dt>
<dd class="defbody">
Deprecated. This function returns a pointer to the content represented 
by the atom or blob regardless of its type. New code that uses blobs 
should use the blob functions such as <a class="func" href="foreigninclude.html#PL_blob_data()">PL_blob_data()</a> 
to get a pointer to the content, the size of the content, and the type 
of the content. Most applications that need to get text from a <code>term_t</code> 
handle should use <a class="func" href="foreigninclude.html#PL_atom_nchars()">PL_atom_nchars()</a>, <a class="func" href="foreigninclude.html#PL_atom_wchars()">PL_atom_wchars()</a>, 
or <a class="func" href="foreigninclude.html#PL_atom_mbchars()">PL_atom_mbchars()</a>. 
If it is
<em>known</em> that <var>atom</var> is a classical Prolog text atom, one 
can use <a class="func" href="foreigninclude.html#PL_atom_nchars()">PL_atom_nchars()</a> 
to obtain the C string and its length (for ISO-Latin-1 atoms) or <a class="func" href="foreigninclude.html#PL_atom_wchars()">PL_atom_wchars()</a> 
to obtain a C wide string (<code>wchar_t</code>).</dd>
<dt class="pubdef"><a id="PL_new_functor()"><var>functor_t</var> <strong>PL_new_functor</strong>(<var>atom_t 
name, int arity</var>)</a></dt>
<dd class="defbody">
Returns a <em>functor identifier</em>, a handle for the name/arity pair. 
The returned handle is valid for the entire Prolog session. Future 
versions may garbage collect functors as part of atom garbage 
collection. Currently aborts the process with a <em>fatal error</em> on 
failure. Future versions may raise a resource exception and return
<code>(atom_t)0</code>.</dd>
<dt class="pubdef"><a id="PL_functor_name()"><var>atom_t</var> <strong>PL_functor_name</strong>(<var>functor_t 
f</var>)</a></dt>
<dd class="defbody">
Return an atom representing the name of the given functor.
</dd>
<dt class="pubdef"><a id="PL_functor_arity()"><var>size_t</var> <strong>PL_functor_arity</strong>(<var>functor_t 
f</var>)</a></dt>
<dd class="defbody">
Return the arity of the given functor.
</dd>
</dl>

<p><h4 id="sec:atomgc"><a id="sec:12.4.2.1"><span class="sec-nr">12.4.2.1</span> <span class="sec-title">Atoms 
and atom garbage collection</span></a></h4>

<a id="sec:atomgc"></a>

<p>With the introduction of atom garbage collection in version 3.3.0, 
atoms no longer live as long as the process. Instead, their lifetime is 
guaranteed only as long as they are referenced. In the single-threaded 
version, atom garbage collections are only invoked at the
<em>call-port</em>. In the multithreaded version (see <a class="sec" href="threads.html#sec:10">chapter 
10</a>), they appear asynchronously, except for the invoking thread.

<p>For dealing with atom garbage collection, two additional functions 
are provided:

<dl class="latex">
<dt class="pubdef"><a id="PL_register_atom()"><var>void</var> <strong>PL_register_atom</strong>(<var>atom_t 
atom</var>)</a></dt>
<dd class="defbody">
Increment the reference count of the atom by one. <a class="func" href="foreigninclude.html#PL_new_atom()">PL_new_atom()</a> 
performs this automatically, returning an atom with a reference count of 
at least one.<sup class="fn">217<span class="fn-text">Otherwise 
asynchronous atom garbage collection might destroy the atom before it is 
used.</span></sup></dd>
<dt class="pubdef"><a id="PL_unregister_atom()"><var>void</var> <strong>PL_unregister_atom</strong>(<var>atom_t 
atom</var>)</a></dt>
<dd class="defbody">
Decrement the reference count of the atom. If the reference count drops 
below zero, an assertion error is raised.
</dd>
</dl>

<p>Please note that the following two calls are different with respect 
to atom garbage collection:

<pre class="code">
PL_unify_atom_chars(t, "text");
PL_unify_atom(t, PL_new_atom("text"));
</pre>

<p>The latter increments the reference count of the atom <code>text</code>, 
which effectively ensures the atom will never be collected. It is 
advised to use the *<b>_chars()</b> or *<b>_nchars()</b> functions 
whenever applicable.

<p><h3 id="sec:input-and-output"><a id="sec:12.4.3"><span class="sec-nr">12.4.3</span> <span class="sec-title">Input 
and output</span></a></h3>

<a id="sec:input-and-output"></a>

<p>For input and output, <code>SWI-Stream.h</code> defines a set of 
functions that are similar to the C library functions, except prefixed 
by <b>S</b>, e.g. <a class="func" href="foreign-streams.html#Sfprintf()">Sfprintf()</a>. 
They differ from the C functions in following ways:
<ul class="latex">
<li>Instead of returning the number of bytes written and a negative 
value for error, they return the number of characters written and a 
negative value for error.
<li>Instead of a <code>FILE</code>, they access the Prolog streams, 
using <code>IOSTREAM*</code>. In particular, <code>Scurrent_output</code> 
accesses the current output stream and works well with
<a id="idx:withoutputto2:2519"></a><a class="pred" href="IO.html#with_output_to/2">with_output_to/2</a>. 
Similarly, there are
<code>Scurrent_intput</code>, <code>Suser_output</code>,
<code>Suser_error</code>, and <code>Suser_input</code>.
<li>If you wish to directly use the operating system's
<code>stdin</code>, <code>stdout</code>, <code>stderr</code>, you can 
use
<code>Sinput</code>, <code>Soutput</code>, <code>Serror</code>. These 
are not affected by predicates such as <a id="idx:withoutputto2:2520"></a><a class="pred" href="IO.html#with_output_to/2">with_output_to/2</a>.
</ul>

<p>In general, if a stream is acquired via <a class="func" href="foreign-streams.html#PL_acquire_stream()">PL_acquire_stream()</a>, 
an error is raised when <a class="func" href="foreign-streams.html#PL_release_stream()">PL_release_stream()</a> 
is called, so in that situation, there's no need to check the return 
codes from the IO functions. Blob write callbacks are also called in the 
context of an acquired stream, so there is no need to check the return 
codes from its IO function calls. However, if you use one of the 
standard streams such as
<code>Scurrent_output</code>, you should check the return code and 
return
<code>FALSE</code> from the foreign predicate, at which point an error 
will be raised. Not all IO functions follow this, because they need to 
return other information, so you should check the details with each one 
(e.g., <a class="func" href="foreign-streams.html#Sputcode()">Sputcode()</a> 
returns -1 on error).

<p>For more details, including formatting extensions for printing terms, 
see <a class="sec" href="foreign-streams.html#sec:12.9">section 12.9</a>.

<p><h3 id="sec:foreign-term-analysis"><a id="sec:12.4.4"><span class="sec-nr">12.4.4</span> <span class="sec-title">Analysing 
Terms via the Foreign Interface</span></a></h3>

<a id="sec:foreign-term-analysis"></a>

<p>Each argument of a foreign function (except for the control argument) 
is of type <code>term_t</code>, an opaque handle to a Prolog term. Three 
groups of functions are available for the analysis of terms. The first 
just validates the type, like the Prolog predicates <a id="idx:var1:2521"></a><a class="pred" href="typetest.html#var/1">var/1</a>, <a id="idx:atom1:2522"></a><a class="pred" href="typetest.html#atom/1">atom/1</a>, 
etc., and are called <code>PL_is_*()</code>. The second group attempts 
to translate the argument into a C primitive type. These predicates take 
a <code>term_t</code> and a pointer to the appropriate C type and return <code>TRUE</code> 
or
<code>FALSE</code> depending on successful or unsuccessful translation. 
If the translation fails, the pointed-to data is never modified.

<p><h4 id="sec:foreign-term-type"><a id="sec:12.4.4.1"><span class="sec-nr">12.4.4.1</span> <span class="sec-title">Testing 
the type of a term</span></a></h4>

<a id="sec:foreign-term-type"></a>

<dl class="latex">
<dt class="pubdef"><a id="PL_term_type()"><var>int</var> <strong>PL_term_type</strong>(<var>term_t</var>)</a></dt>
<dd class="defbody">
Obtain the type of a term, which should be a term returned by one of the 
other interface predicates or passed as an argument. The function 
returns the type of the Prolog term. The type identifiers are listed 
below. Note that the extraction functions <code>PL_get_*()</code> also 
validate the type and thus the two sections below are equivalent.

<pre class="code">
        if ( PL_is_atom(t) )
        { char *s;

          PL_get_atom_chars(t, &amp;s);
          ...;
        }

or

        char *s;
        if ( PL_get_atom_chars(t, &amp;s) )
        { ...;
        }
</pre>

<p><b>Version&nbsp;7</b> added <code>PL_NIL</code>, <code>PL_BLOB</code>,
<code>PL_LIST_PAIR</code> and <code>PL_DICT</code>. Older versions 
classify <code>PL_NIL</code> and <code>PL_BLOB</code> as <code>PL_ATOM</code>,
<code>PL_LIST_PAIR</code> as <code>PL_TERM</code> and do not have dicts.

<p><table class="latex frame-box">
<tr><td><code>PL_VARIABLE</code> </td><td>A variable or attributed 
variable </td></tr>
<tr><td><code>PL_ATOM</code> </td><td>A Prolog atom </td></tr>
<tr><td><code>PL_NIL</code> </td><td>The constant <code>[]</code> </td></tr>
<tr><td><code>PL_BLOB</code> </td><td>A blob (see <a class="sec" href="foreigninclude.html#sec:12.4.10.2">section 
12.4.10.2</a>) </td></tr>
<tr><td><code>PL_STRING</code> </td><td>A string (see <a class="sec" href="string.html#sec:5.2">section 
5.2</a>) </td></tr>
<tr><td><code>PL_INTEGER</code> </td><td>A integer </td></tr>
<tr><td><code>PL_RATIONAL</code> </td><td>A rational number </td></tr>
<tr><td><code>PL_FLOAT</code> </td><td>A floating point number </td></tr>
<tr><td><code>PL_TERM</code> </td><td>A compound term </td></tr>
<tr><td><code>PL_LIST_PAIR</code> </td><td>A list cell (<code>[H|T]</code>) </td></tr>
<tr><td><code>PL_DICT</code> </td><td>A dict (see <a class="sec" href="bidicts.html#sec:5.4">section 
5.4</a>)) </td></tr>
</table>
</dd>
</dl>

<p>The functions PL_is_&lt;<var>type</var>&gt; are an alternative to <a class="func" href="foreigninclude.html#PL_term_type()">PL_term_type()</a>. 
The test <code><a class="func" href="foreigninclude.html#PL_is_variable()">PL_is_variable(term)</a></code> 
is equivalent to
<code><a class="func" href="foreigninclude.html#PL_term_type()">PL_term_type(term)</a> 
== PL_VARIABLE</code>, but the first is considerably faster. On the 
other hand, using a switch over <a class="func" href="foreigninclude.html#PL_term_type()">PL_term_type()</a> 
is faster and more readable then using an if-then-else using the 
functions below. All these functions return either <code>TRUE</code> or <code>FALSE</code>.

<dl class="latex">
<dt class="pubdef"><a id="PL_is_variable()"><var>int</var> <strong>PL_is_variable</strong>(<var>term_t</var>)</a></dt>
<dd class="defbody">
Returns non-zero if <var>term</var> is a variable.</dd>
<dt class="pubdef"><a id="PL_is_ground()"><var>int</var> <strong>PL_is_ground</strong>(<var>term_t</var>)</a></dt>
<dd class="defbody">
Returns non-zero if <var>term</var> is a ground term. See also <a id="idx:ground1:2523"></a><a class="pred" href="typetest.html#ground/1">ground/1</a>. 
This function is cycle-safe.</dd>
<dt class="pubdef"><a id="PL_is_atom()"><var>int</var> <strong>PL_is_atom</strong>(<var>term_t</var>)</a></dt>
<dd class="defbody">
Returns non-zero if <var>term</var> is an atom.</dd>
<dt class="pubdef"><a id="PL_is_string()"><var>int</var> <strong>PL_is_string</strong>(<var>term_t</var>)</a></dt>
<dd class="defbody">
Returns non-zero if <var>term</var> is a string.</dd>
<dt class="pubdef"><a id="PL_is_integer()"><var>int</var> <strong>PL_is_integer</strong>(<var>term_t</var>)</a></dt>
<dd class="defbody">
Returns non-zero if <var>term</var> is an integer.</dd>
<dt class="pubdef"><a id="PL_is_rational()"><var>int</var> <strong>PL_is_rational</strong>(<var>term_t</var>)</a></dt>
<dd class="defbody">
Returns non-zero if <var>term</var> is a rational number (<var>P/Q</var>). 
Note that all integers are considered rational and this test thus 
succeeds for any term for which <a class="func" href="foreigninclude.html#PL_is_integer()">PL_is_integer()</a> 
succeeds. See also
<a class="func" href="foreigninclude.html#PL_get_mpq()">PL_get_mpq()</a> 
and <a class="func" href="foreigninclude.html#PL_unify_mpq()">PL_unify_mpq()</a>.</dd>
<dt class="pubdef"><a id="PL_is_float()"><var>int</var> <strong>PL_is_float</strong>(<var>term_t</var>)</a></dt>
<dd class="defbody">
Returns non-zero if <var>term</var> is a float. Note that the 
corresponding
<a class="func" href="foreigninclude.html#PL_get_float()">PL_get_float()</a> 
converts rationals (and thus integers).</dd>
<dt class="pubdef"><a id="PL_is_callable()"><var>int</var> <strong>PL_is_callable</strong>(<var>term_t</var>)</a></dt>
<dd class="defbody">
Returns non-zero if <var>term</var> is a callable term. See <a id="idx:callable1:2524"></a><a class="pred" href="typetest.html#callable/1">callable/1</a> 
for details.</dd>
<dt class="pubdef"><a id="PL_is_compound()"><var>int</var> <strong>PL_is_compound</strong>(<var>term_t</var>)</a></dt>
<dd class="defbody">
Returns non-zero if <var>term</var> is a compound term.</dd>
<dt class="pubdef"><a id="PL_is_functor()"><var>int</var> <strong>PL_is_functor</strong>(<var>term_t, 
functor_t</var>)</a></dt>
<dd class="defbody">
Returns non-zero if <var>term</var> is compound and its functor is <var>functor</var>. 
This test is equivalent to <a class="func" href="foreigninclude.html#PL_get_functor()">PL_get_functor()</a>, 
followed by testing the functor, but easier to write and faster.</dd>
<dt class="pubdef"><a id="PL_is_list()"><var>int</var> <strong>PL_is_list</strong>(<var>term_t</var>)</a></dt>
<dd class="defbody">
Returns non-zero if <var>term</var> is a compound term using the list 
constructor or the list terminator. See also <a class="func" href="foreigninclude.html#PL_is_pair()">PL_is_pair()</a> 
and
<a class="func" href="foreigninclude.html#PL_skip_list()">PL_skip_list()</a>.</dd>
<dt class="pubdef"><a id="PL_is_pair()"><var>int</var> <strong>PL_is_pair</strong>(<var>term_t</var>)</a></dt>
<dd class="defbody">
Returns non-zero if <var>term</var> is a compound term using the list 
constructor. See also <a class="func" href="foreigninclude.html#PL_is_list()">PL_is_list()</a> 
and <a class="func" href="foreigninclude.html#PL_skip_list()">PL_skip_list()</a>.</dd>
<dt class="pubdef"><a id="PL_is_dict()"><var>int</var> <strong>PL_is_dict</strong>(<var>term_t</var>)</a></dt>
<dd class="defbody">
Returns non-zero if <var>term</var> is a dict. See also <a class="func" href="foreigninclude.html#PL_put_dict()">PL_put_dict()</a> 
and <a class="func" href="foreigninclude.html#PL_get_dict_key()">PL_get_dict_key()</a>.</dd>
<dt class="pubdef"><a id="PL_is_atomic()"><var>int</var> <strong>PL_is_atomic</strong>(<var>term_t</var>)</a></dt>
<dd class="defbody">
Returns non-zero if <var>term</var> is atomic (not a variable or 
compound).</dd>
<dt class="pubdef"><a id="PL_is_number()"><var>int</var> <strong>PL_is_number</strong>(<var>term_t</var>)</a></dt>
<dd class="defbody">
Returns non-zero if <var>term</var> is an rational (including integers) 
or float.</dd>
<dt class="pubdef"><a id="PL_is_acyclic()"><var>int</var> <strong>PL_is_acyclic</strong>(<var>term_t</var>)</a></dt>
<dd class="defbody">
Returns non-zero if <var>term</var> is acyclic (i.e. a finite tree).
</dd>
</dl>

<p><h4 id="sec:foreign-extract-from-term"><a id="sec:12.4.4.2"><span class="sec-nr">12.4.4.2</span> <span class="sec-title">Reading 
data from a term</span></a></h4>

<a id="sec:foreign-extract-from-term"></a>

<p>The functions <code>PL_get_*()</code> read information from a Prolog 
term. Most of them take two arguments. The first is the input term and 
the second is a pointer to the output value or a term reference. The 
return value is <code>TRUE</code> or <code>FALSE</code>, indicating the 
success of the "get" operation. Most functions have a related "_ex" 
function that raises an error if the argument is the operation cannot be 
completed. If the Prolog term is not suitable, this is a type, domain or 
instantiation error. If the receiving C type cannot represent the value 
this is a representation error.

<p>For integers an alternative interface exists, which helps deal with 
the various integer types in C and C++. They are convenient for use with
<code>_Generic</code> selection or C++ overloading.

<dl class="latex">
<dt class="pubdef"><a id="PL_get_atom()"><var>int</var> <strong>PL_get_atom</strong>(<var>term_t 
+t, atom_t *a</var>)</a></dt>
<dd class="defbody">
If <var>t</var> is an atom, store the unique atom identifier over <var>a</var>. 
See also <a class="func" href="foreigninclude.html#PL_atom_chars()">PL_atom_chars()</a> 
and <a class="func" href="foreigninclude.html#PL_new_atom()">PL_new_atom()</a>. 
If there is no need to access the data (characters) of an atom, it is 
advised to manipulate atoms using their handle. As the atom is 
referenced by <var>t</var>, it will live at least as long as <var>t</var> 
does. If longer lifetime is required, the atom should be locked using <a class="func" href="foreigninclude.html#PL_register_atom()">PL_register_atom()</a>.</dd>
<dt class="pubdef"><a id="PL_get_atom_chars()"><var>int</var> <strong>PL_get_atom_chars</strong>(<var>term_t 
+t, char **s</var>)</a></dt>
<dd class="defbody">
If <var>t</var> is an atom, store a pointer to a 0-terminated C-string 
in
<var>s</var>. It is explicitly <strong>not</strong> allowed to modify 
the contents of this string. Some built-in atoms may have the string 
allocated in read-only memory, so&lsquo;temporary manipulation&rsquo;can 
cause an error.</dd>
<dt class="pubdef"><a id="PL_get_string_chars()"><var>int</var> <strong>PL_get_string_chars</strong>(<var>term_t 
+t, char **s, size_t *len</var>)</a></dt>
<dd class="defbody">
If <var>t</var> is a string object, store a pointer to a 0-terminated 
C-string in <var>s</var> and the length of the string in <var>len</var>. 
Note that this pointer is invalidated by backtracking, garbage 
collection and stack-shifts, so generally the only safe operations are 
to pass it immediately to a C function that doesn't involve Prolog.</dd>
<dt class="pubdef"><a id="PL_get_chars()"><var>int</var> <strong>PL_get_chars</strong>(<var>term_t 
+t, char **s, unsigned flags</var>)</a></dt>
<dd class="defbody">
Convert the argument term <var>t</var> to a 0-terminated C-string.
<var>flags</var> is a bitwise disjunction from two groups of constants. 
The first specifies which term types should be converted and the second 
how the argument is stored. Below is a specification of these constants.
<code>BUF_STACK</code> implies, if the data is not static (as from an 
atom), that the data is pushed on a stack. If <code>BUF_MALLOC</code> is 
used, the data must be freed using <a class="func" href="foreignnotes.html#PL_free()">PL_free()</a> 
when no longer needed.

<p>With the introduction of wide characters (see <a class="sec" href="widechars.html#sec:2.18.1">section 
2.18.1</a>), not all atoms can be converted into a <code>char*</code>. 
This function fails if <var>t</var> is of the wrong type, but also if 
the text cannot be represented. See the <code>REP_*</code> flags below 
for details. See also <a class="func" href="foreigninclude.html#PL_get_wchars()">PL_get_wchars()</a> 
and <a class="func" href="foreigninclude.html#PL_get_nchars()">PL_get_nchars()</a>.

<p>The first set of flags (<code>CVT_ATOM</code> through <code>CVT_VARIABLE</code>, 
if set, are tested in order, using the first that matches. If none of 
these match, then a check is made for one of <code>CVT_WRITE</code>,
<code>CVT_WRITE_CANONICAL</code>, <code>CVT_WRITEQ</code> being set. If 
none of the &ldquo;CVT_WRITE*&rdquo; flags are set, then a <code>type_error</code> 
is raised.

<dl class="latex">
<dt><strong>CVT_ATOM</strong></dt>
<dd class="defbody">
Convert if term is an atom.</dd>
<dt><strong>CVT_STRING</strong></dt>
<dd class="defbody">
Convert if term is a string.</dd>
<dt><strong>CVT_LIST</strong></dt>
<dd class="defbody">
Convert if term is a list of characters (atoms of length 1) or character 
codes (integers representing Unicode code points).</dd>
<dt><strong>CVT_INTEGER</strong></dt>
<dd class="defbody">
Convert if term is an integer.</dd>
<dt><strong>CVT_RATIONAL</strong></dt>
<dd class="defbody">
Convert if term is a rational number (including integers). Non-integral 
numbers are written as &lt;<var>num</var>&gt;r&lt;<var>den</var>&gt;.</dd>
<dt><strong>CVT_XINTEGER</strong></dt>
<dd class="defbody">
Convert if term is an integer to hexadecimal notation. May be combined 
with <code>CVT_RATIONAL</code> to represent rational numbers using 
hexadecimal notation. Hexadecimal notation is notably useful for 
transferring big integers to other programming environments if the 
target system can read hexadecimal notation because the result is both 
more compact and faster to write and read.</dd>
<dt><strong>CVT_FLOAT</strong></dt>
<dd class="defbody">
Convert if term is a float. The characters returned are the same as
<a id="idx:write1:2525"></a><a class="pred" href="termrw.html#write/1">write/1</a> 
would write for the floating point number.</dd>
<dt><strong>CVT_NUMBER</strong></dt>
<dd class="defbody">
Convert if term is an integer, rational number or float. Equivalent to <code>CVT_RATIONAL</code><code>|</code><code>CVT_FLOAT</code>. 
Note that
<code>CVT_INTEGER</code> is implied by <code>CVT_RATIONAL</code>.</dd>
<dt><strong>CVT_ATOMIC</strong></dt>
<dd class="defbody">
Convert if term is atomic. Equivalent to <code>CVT_NUMBER</code><code>|</code><code>CVT_ATOM</code><code>|</code><code>CVT_STRING</code>.</dd>
<dt><strong>CVT_ALL</strong></dt>
<dd class="defbody">
Convert if term is any of the above. Integers and rational numbers are 
written as decimal (i.e., <code>CVT_XINTEGER</code> is <em>not</em> 
implied). Note that this does not include variables or terms (with the 
exception of a list of characters/codes). Equivalent to
<code>CVT_ATOMIC</code><code>|</code><code>CVT_LIST</code>.</dd>
<dt><strong>CVT_VARIABLE</strong></dt>
<dd class="defbody">
Convert variable to print-name (e.g., <code>_3290</code>).</dd>
<dt><strong>CVT_WRITE</strong></dt>
<dd class="defbody">
Convert any term that is not converted by any of the other flags using
<a id="idx:write1:2526"></a><a class="pred" href="termrw.html#write/1">write/1</a>. 
If no <code>BUF_*</code> is provided, <code>BUF_STACK</code> is implied.</dd>
<dt><strong>CVT_WRITEQ</strong></dt>
<dd class="defbody">
As <code>CVT_WRITE</code>, but using <a id="idx:writeq2:2527"></a><a class="pred" href="termrw.html#writeq/2">writeq/2</a>.</dd>
<dt><strong>CVT_WRITE_CANONICAL</strong></dt>
<dd class="defbody">
As <code>CVT_WRITE</code>, but using <a id="idx:writecanonical2:2528"></a><a class="pred" href="termrw.html#write_canonical/2">write_canonical/2</a>.</dd>
<dt><strong>CVT_EXCEPTION</strong></dt>
<dd class="defbody">
If conversion fails due to a type error, raise a Prolog type error 
exception in addition to failure.</dd>
<dt><strong>BUF_DISCARDABLE</strong></dt>
<dd class="defbody">
Data must copied immediately.</dd>
<dt><strong>BUF_STACK</strong></dt>
<dd class="defbody">
Data is stored on a stack. The older <code>BUF_RING</code> is an alias 
for <code>BUF_STACK</code>. See <a class="sec" href="foreigninclude.html#sec:12.4.14">section 
12.4.14</a>.</dd>
<dt><strong>BUF_MALLOC</strong></dt>
<dd class="defbody">
Data is copied to a new buffer returned by <strong>PL_malloc</strong>(3). 
When no longer needed the user must call <a class="func" href="foreignnotes.html#PL_free()">PL_free()</a> 
on the data.</dd>
<dt><strong>REP_ISO_LATIN_1</strong></dt>
<dd class="defbody">
Text is in ISO Latin-1 encoding and the call fails if text cannot be 
represented. This flag has the value 0 and is thus the default.</dd>
<dt><strong>REP_UTF8</strong></dt>
<dd class="defbody">
Convert the text to a UTF-8 string. This works for all text.</dd>
<dt><strong>REP_MB</strong></dt>
<dd class="defbody">
Convert to default locale-defined 8-bit string. Success depends on the 
locale. Conversion is done using the <b>wcrtomb()</b> C library 
function.
</dd>
</dl>

</dd>
<dt class="pubdef"><a id="PL_get_list_chars()"><var>int</var> <strong>PL_get_list_chars</strong>(<var>+term_t 
l, char **s, unsigned flags</var>)</a></dt>
<dd class="defbody">
Same as <code><a class="func" href="foreigninclude.html#PL_get_chars()">PL_get_chars(<var>l</var>, <var>s</var>, 
CVT_LIST|<var>flags</var>)</a></code>, provided <var>flags</var> 
contains none of the <code>CVT_*</code> flags.</dd>
<dt class="pubdef"><a id="PL_get_integer()"><var>int</var> <strong>PL_get_integer</strong>(<var>+term_t 
t, int *i</var>)</a></dt>
<dd class="defbody">
If <var>t</var> is a Prolog integer, assign its value over <var>i</var>. 
On 32-bit machines, this is the same as <a class="func" href="foreigninclude.html#PL_get_long()">PL_get_long()</a>, 
but avoids a warning from the compiler. See also <a class="func" href="foreigninclude.html#PL_get_long()">PL_get_long()</a> 
and
<a class="func" href="foreigninclude.html#PL_get_integer_ex()">PL_get_integer_ex()</a>.</dd>
<dt class="pubdef"><a id="PL_get_long()"><var>int</var> <strong>PL_get_long</strong>(<var>term_t 
+t, long *i</var>)</a></dt>
<dd class="defbody">
If <var>t</var> is a Prolog integer that can be represented as a long, 
assign its value over <var>i</var>. If <var>t</var> is an integer that 
cannot be represented by a C long, this function returns <code>FALSE</code>. 
If <var>t</var> is a floating point number that can be represented as a 
long, this function succeeds as well. See also <a class="func" href="foreigninclude.html#PL_get_int64()">PL_get_int64()</a> 
and <a class="func" href="foreigninclude.html#PL_get_long_ex()">PL_get_long_ex()</a>.</dd>
<dt class="pubdef"><a id="PL_get_int64()"><var>int</var> <strong>PL_get_int64</strong>(<var>term_t 
+t, int64_t *i</var>)</a></dt>
<dd class="defbody">
If <var>t</var> is a Prolog integer or float that can be represented as 
a
<code>int64_t</code>, assign its value over <var>i</var>. See also <a class="func" href="foreigninclude.html#PL_get_int64_ex()">PL_get_int64_ex()</a>.</dd>
<dt class="pubdef"><a id="PL_get_uint64()"><var>int</var> <strong>PL_get_uint64</strong>(<var>term_t 
+t, uint64_t *i</var>)</a></dt>
<dd class="defbody">
If <var>t</var> is a Prolog integer that can be represented as a
<code>uint64_t</code>, assign its value over <var>i</var>. Note that 
this requires GMP support for representing <code>uint64_t</code> values 
with the high bit set. See also <a class="func" href="foreigninclude.html#PL_get_uint64_ex()">PL_get_uint64_ex()</a>.</dd>
<dt class="pubdef"><a id="PL_get_intptr()"><var>int</var> <strong>PL_get_intptr</strong>(<var>term_t 
+t, intptr_t *i</var>)</a></dt>
<dd class="defbody">
Get an integer that is at least as wide as a pointer. On most platforms 
this is the same as <a class="func" href="foreigninclude.html#PL_get_long()">PL_get_long()</a>, 
but on Win64 pointers are 8 bytes and longs only 4. Unlike <a class="func" href="foreigninclude.html#PL_get_pointer()">PL_get_pointer()</a>, 
the value is not modified.</dd>
<dt class="pubdef"><a id="PL_get_bool()"><var>int</var> <strong>PL_get_bool</strong>(<var>term_t 
+t, int *val</var>)</a></dt>
<dd class="defbody">
If <var>t</var> has the value <code>true</code>, <code>false</code>, set <var>val</var> 
to the C constant <code>TRUE</code> or <code>FALSE</code> and return 
success, otherwise return failure. The values <code>on</code>, <code>1</code>, <code>off</code>, 
const0 and are also accepted.</dd>
<dt class="pubdef"><a id="PL_get_pointer()"><var>int</var> <strong>PL_get_pointer</strong>(<var>term_t 
+t, void **ptr</var>)</a></dt>
<dd class="defbody">
Together with <a class="func" href="foreigninclude.html#PL_put_pointer()">PL_put_pointer()</a> 
and <a class="func" href="foreigninclude.html#PL_unify_pointer()">PL_unify_pointer()</a>, 
these functions allow representing a C pointer as a Prolog integer. The 
integer value is derived from the pointer, but not equivalent. The 
translation aims at producing smaller integers that fit more often in 
the <em>tagged</em> integer range. Representing C pointers as integers 
is <em>unsafe</em>. The <em>blob</em> API described in <a class="sec" href="foreigninclude.html#sec:12.4.10">section 
12.4.10</a> provides a safe way for handling foreign resources that 
cooperates with Prolog garbage collection.</dd>
<dt class="pubdef"><a id="PL_get_float()"><var>int</var> <strong>PL_get_float</strong>(<var>term_t 
+t, double *f</var>)</a></dt>
<dd class="defbody">
If <var>t</var> is a float, integer or rational number, its value is 
assigned over <var>f</var>. Note that if <var>t</var> is an integer or 
rational conversion may fail because the number cannot be represented as 
a float.</dd>
<dt class="pubdef"><a id="PL_get_functor()"><var>int</var> <strong>PL_get_functor</strong>(<var>term_t 
+t, functor_t *f</var>)</a></dt>
<dd class="defbody">
If <var>t</var> is compound or an atom, the Prolog representation of the 
name-arity pair will be assigned over <var>f</var>. See also
<a class="func" href="foreigninclude.html#PL_get_name_arity()">PL_get_name_arity()</a> 
and <a class="func" href="foreigninclude.html#PL_is_functor()">PL_is_functor()</a>.</dd>
<dt class="pubdef"><a id="PL_get_name_arity()"><var>int</var> <strong>PL_get_name_arity</strong>(<var>term_t 
+t, atom_t *name, size_t *arity</var>)</a></dt>
<dd class="defbody">
If <var>t</var> is compound or an atom, the functor name will be 
assigned over <var>name</var> and the arity over <var>arity</var> 
(either or both may be NULL). See also <a class="func" href="foreigninclude.html#PL_get_compound_name_arity()">PL_get_compound_name_arity()</a>, <a class="func" href="foreigninclude.html#PL_get_functor()">PL_get_functor()</a> 
and <a class="func" href="foreigninclude.html#PL_is_functor()">PL_is_functor()</a>.</dd>
<dt class="pubdef"><a id="PL_get_compound_name_arity()"><var>int</var> <strong>PL_get_compound_name_arity</strong>(<var>term_t 
+t, atom_t *name, size_t *arity</var>)</a></dt>
<dd class="defbody">
If <var>t</var> is compound term, the functor name will be assigned over
<var>name</var> and the arity over <var>arity</var> (either or both may 
be
<code>NULL</code>). This is the same as <a class="func" href="foreigninclude.html#PL_get_name_arity()">PL_get_name_arity()</a>, 
but this function fails if <var>t</var> is an atom.</dd>
<dt class="pubdef"><a id="PL_get_module()"><var>int</var> <strong>PL_get_module</strong>(<var>term_t 
+t, module_t *module</var>)</a></dt>
<dd class="defbody">
If <var>t</var> is an atom, the system will look up or create the 
corresponding module and assign an opaque pointer to it over <em>module</em>.</dd>
<dt class="pubdef"><a id="PL_get_arg()"><var>int</var> <strong>PL_get_arg</strong>(<var>size_t 
index, term_t +t, term_t -a</var>)</a></dt>
<dd class="defbody">
If <var>t</var> is compound and index is between 1 and arity 
(inclusive), assign <var>a</var> with a term reference to the argument.</dd>
<dt class="pubdef"><a id="_PL_get_arg()"><var>int</var> <strong>_PL_get_arg</strong>(<var>size_t 
index, term_t +t, term_t -a</var>)</a></dt>
<dd class="defbody">
Same as <a class="func" href="foreigninclude.html#PL_get_arg()">PL_get_arg()</a>, 
but no checking is performed, neither whether <var>t</var> is actually a 
term nor whether <var>index</var> is a valid argument index.</dd>
<dt class="pubdef"><a id="PL_get_dict_key()"><var>int</var> <strong>PL_get_dict_key</strong>(<var>atom_t 
key, term_t +dict, term_t -value</var>)</a></dt>
<dd class="defbody">
If <var>dict</var> is a dict, get the associated value in <var>value</var>. 
Fails silently if <var>key</var> does not appear in <var>dict</var> or 
if if <var>dict</var> is not a dict.
</dd>
</dl>

<p><h4 id="sec:foreign-text-with-length"><a id="sec:12.4.4.3"><span class="sec-nr">12.4.4.3</span> <span class="sec-title">Exchanging 
text using length and string</span></a></h4>

<a id="sec:foreign-text-with-length"></a>

<p>All internal text representation in SWI-Prolog is represented using
<code>char *</code> plus length and allow for <em>0-bytes</em> in them. 
The foreign library supports this by implementing a *<b>_nchars()</b> 
function for each applicable *<b>_chars()</b> function. Below we briefly 
present the signatures of these functions. For full documentation 
consult the *<b>_chars()</b> function.

<dl class="latex">
<dt class="pubdef"><a id="PL_get_atom_nchars()"><var>int</var> <strong>PL_get_atom_nchars</strong>(<var>term_t 
t, size_t *len, char **s</var>)</a></dt>
<dd class="defbody">
See <a class="func" href="foreigninclude.html#PL_get_atom_chars()">PL_get_atom_chars()</a>.
</dd>
<dt class="pubdef"><a id="PL_get_list_nchars()"><var>int</var> <strong>PL_get_list_nchars</strong>(<var>term_t 
t, size_t *len, char **s</var>)</a></dt>
<dd class="defbody">
See <a class="func" href="foreigninclude.html#PL_get_list_chars()">PL_get_list_chars()</a>.
</dd>
<dt class="pubdef"><a id="PL_get_nchars()"><var>int</var> <strong>PL_get_nchars</strong>(<var>term_t 
t, size_t *len, char **s, unsigned int flags</var>)</a></dt>
<dd class="defbody">
See <a class="func" href="foreigninclude.html#PL_get_chars()">PL_get_chars()</a>. 
The <var>len</var> pointer may be <code>NULL</code>.
</dd>
<dt class="pubdef"><a id="PL_put_atom_nchars()"><var>int</var> <strong>PL_put_atom_nchars</strong>(<var>term_t 
t, size_t len, const char *s</var>)</a></dt>
<dd class="defbody">
See <a class="func" href="foreigninclude.html#PL_put_atom_chars()">PL_put_atom_chars()</a>.
</dd>
<dt class="pubdef"><a id="PL_put_string_nchars()"><var>int</var> <strong>PL_put_string_nchars</strong>(<var>term_t 
t, size_t len, const char *s</var>)</a></dt>
<dd class="defbody">
See <a class="func" href="foreigninclude.html#PL_put_string_chars()">PL_put_string_chars()</a>.
</dd>
<dt class="pubdef"><a id="PL_put_list_ncodes()"><var>int</var> <strong>PL_put_list_ncodes</strong>(<var>term_t 
t, size_t len, const char *s</var>)</a></dt>
<dd class="defbody">
See <b>PL_put_list_codes()</b>.
</dd>
<dt class="pubdef"><a id="PL_put_list_nchars()"><var>int</var> <strong>PL_put_list_nchars</strong>(<var>term_t 
t, size_t len, const char *s</var>)</a></dt>
<dd class="defbody">
See <a class="func" href="foreigninclude.html#PL_put_list_chars()">PL_put_list_chars()</a>.
</dd>
<dt class="pubdef"><a id="PL_unify_atom_nchars()"><var>int</var> <strong>PL_unify_atom_nchars</strong>(<var>term_t 
t, size_t len, const char *s</var>)</a></dt>
<dd class="defbody">
See <a class="func" href="foreigninclude.html#PL_unify_atom_chars()">PL_unify_atom_chars()</a>.
</dd>
<dt class="pubdef"><a id="PL_unify_string_nchars()"><var>int</var> <strong>PL_unify_string_nchars</strong>(<var>term_t 
t, size_t len, const char *s</var>)</a></dt>
<dd class="defbody">
See <a class="func" href="foreigninclude.html#PL_unify_string_chars()">PL_unify_string_chars()</a>.
</dd>
<dt class="pubdef"><a id="PL_unify_list_ncodes()"><var>int</var> <strong>PL_unify_list_ncodes</strong>(<var>term_t 
t, size_t len, const char *s</var>)</a></dt>
<dd class="defbody">
See <b>PL_unify_codes()</b>.
</dd>
<dt class="pubdef"><a id="PL_unify_list_nchars()"><var>int</var> <strong>PL_unify_list_nchars</strong>(<var>term_t 
t, size_t len, const char *s</var>)</a></dt>
<dd class="defbody">
See <a class="func" href="foreigninclude.html#PL_unify_list_chars()">PL_unify_list_chars()</a>.
</dd>
</dl>

<p>In addition, the following functions are available for creating and 
inspecting atoms:

<dl class="latex">
<dt class="pubdef"><a id="PL_new_atom_nchars()"><var>atom_t</var> <strong>PL_new_atom_nchars</strong>(<var>size_t 
len, const char *s</var>)</a></dt>
<dd class="defbody">
Create a new atom as <a class="func" href="foreigninclude.html#PL_new_atom()">PL_new_atom()</a>, 
but using the given length and characters. If <var>len</var> is <code>(size_t)-1</code>, 
it is computed from <var>s</var> using
<b>strlen()</b>. See <a class="func" href="foreigninclude.html#PL_new_atom()">PL_new_atom()</a> 
for error handling.</dd>
<dt class="pubdef"><a id="PL_atom_nchars()"><var>const char *</var> <strong>PL_atom_nchars</strong>(<var>atom_t 
a, size_t *len</var>)</a></dt>
<dd class="defbody">
Extract the text and length of an atom. If you do not need the length, 
pass NULL as the value of <var>len</var>. If <a class="func" href="foreigninclude.html#PL_atom_nchars()">PL_atom_nchars()</a> 
is called for a blob, NULL is returned.
</dd>
</dl>

<p><h4 id="sec:foreign-unicode"><a id="sec:12.4.4.4"><span class="sec-nr">12.4.4.4</span> <span class="sec-title">Wide-character 
versions</span></a></h4>

<a id="sec:foreign-unicode"></a>

<p>Support for exchange of wide-character strings is still under 
consideration. The functions dealing with 8-bit character strings return 
failure when operating on a wide-character atom or Prolog string object. 
The functions below can extract and unify both 8-bit and wide atoms and 
string objects. Wide character strings are represented as C arrays of 
objects of the type <code>pl_wchar_t</code>, which is guaranteed to be 
the same as <code>wchar_t</code> on platforms supporting this type. For 
example, on MS-Windows, this represents a 16-bit UTF-16 string, while 
using the GNU C library (glibc) this represents 32-bit UCS4 characters.

<dl class="latex">
<dt class="pubdef"><a id="PL_new_atom_wchars()"><var>atom_t</var> <strong>PL_new_atom_wchars</strong>(<var>size_t 
len, const pl_wchar_t *s</var>)</a></dt>
<dd class="defbody">
Create atom from wide-character string as <a class="func" href="foreigninclude.html#PL_new_atom_nchars()">PL_new_atom_nchars()</a> 
does for ISO-Latin-1 strings. If <var>s</var> only contains ISO-Latin-1 
characters a normal byte-array atom is created. If <var>len</var> is <code>(size_t)-1</code>, 
it is computed from <var>s</var> using <b>wcslen()</b>. See <a class="func" href="foreigninclude.html#PL_new_atom()">PL_new_atom()</a> 
for error handling.</dd>
<dt class="pubdef"><a id="PL_atom_wchars()"><var>const pl_wchar_t*</var> <strong>PL_atom_wchars</strong>(<var>atom_t 
atom, size_t *len</var>)</a></dt>
<dd class="defbody">
Extract characters from a wide-character atom. Succeeds on any atom 
marked as&lsquo;text&rsquo;. If the underlying atom is a wide-character 
atom, the returned pointer is a pointer into the atom structure. If the 
atom is represented as an ISO-Latin-1 string, the returned pointer comes 
from Prolog's&lsquo;buffer stack&rsquo;(see <a class="sec" href="foreigninclude.html#sec:12.4.14">section 
12.4.14</a>).</dd>
<dt class="pubdef"><a id="PL_get_wchars()"><var>int</var> <strong>PL_get_wchars</strong>(<var>term_t 
t, size_t *len, pl_wchar_t **s, unsigned flags</var>)</a></dt>
<dd class="defbody">
Wide-character version of <a class="func" href="foreigninclude.html#PL_get_chars()">PL_get_chars()</a>. 
The <var>flags</var> argument is the same as for <a class="func" href="foreigninclude.html#PL_get_chars()">PL_get_chars()</a>. 
Note that this operation may return a pointer into Prolog's&lsquo;buffer 
stack&rsquo;(see <a class="sec" href="foreigninclude.html#sec:12.4.14">section 
12.4.14</a>).</dd>
<dt class="pubdef"><a id="PL_put_wchars()"><var>int</var> <strong>PL_put_wchars</strong>(<var>term_t 
-t, int type, size_t len, const pl_wchar_t *s</var>)</a></dt>
<dd class="defbody">
<i>Put</i> text from a wide character array in <var>t</var>. Arguments 
are the same as <a class="func" href="foreigninclude.html#PL_unify_wchars()">PL_unify_wchars()</a>.<sup class="fn">218<span class="fn-text">The 
current implemention uses <a class="func" href="foreigninclude.html#PL_put_variable()">PL_put_variable()</a> 
followed by <a class="func" href="foreigninclude.html#PL_unify_wchars()">PL_unify_wchars()</a>.</span></sup></dd>
<dt class="pubdef"><a id="PL_unify_wchars()"><var>int</var> <strong>PL_unify_wchars</strong>(<var>term_t 
+t, int type, size_t len, const pl_wchar_t *s</var>)</a></dt>
<dd class="defbody">
Unify <var>t</var> with a textual representation of the C wide-character 
array <var>s</var>. The <var>type</var> argument defines the Prolog 
representation and is one of <code>PL_ATOM</code>, <code>PL_STRING</code>,
<code>PL_CODE_LIST</code> or <code>PL_CHAR_LIST</code>.</dd>
<dt class="pubdef"><a id="PL_unify_wchars_diff()"><var>int</var> <strong>PL_unify_wchars_diff</strong>(<var>term_t 
+t, term_t -tail, int type, size_t len, const pl_wchar_t *s</var>)</a></dt>
<dd class="defbody">
Difference list version of <a class="func" href="foreigninclude.html#PL_unify_wchars()">PL_unify_wchars()</a>, 
only supporting the types <code>PL_CODE_LIST</code> and <code>PL_CHAR_LIST</code>. 
It serves two purposes. It allows for returning very long lists from 
data read from a stream without the need for a resizing buffer in C. 
Also, the use of difference lists is often practical for further 
processing in Prolog. Examples can be found in <code>packages/clib/readutil.c</code> 
from the source distribution.
</dd>
</dl>

<p><h4 id="sec:foreign-read-list"><a id="sec:12.4.4.5"><span class="sec-nr">12.4.4.5</span> <span class="sec-title">Reading 
a list</span></a></h4>

<a id="sec:foreign-read-list"></a>

<p>The functions from this section are intended to read a Prolog list 
from C. Suppose we expect a list of atoms; the code below will print the 
atoms, each on a line. Please note the following:

<p>
<ul class="latex">
<li>We need a <code>term_t</code> <em>term reference</em> for the 
elements (<var>head</var>). This reference is reused for each element.
<li>We walk over the list using <a class="func" href="foreigninclude.html#PL_get_list_ex()">PL_get_list_ex()</a> 
which overwrites the list <code>term_t</code>. As it is not allowed to 
overwrite the <code>term_t</code> passed in as arguments to a predicate, 
we must
<em>copy</em> the argument <code>term_t</code>.
<li>SWI-Prolog atoms are Unicode objects. The <a class="func" href="foreigninclude.html#PL_get_chars()">PL_get_chars()</a> 
returns a <code>char*</code>. We want it to convert atoms, return the 
result as a <em>multibyte</em> string (<code>REP_UTF8</code> may also be 
used) and finally we want an exception on type, instantiation or 
representation errors (if the system's default encoding cannot represent 
some characters of the Unicode atom). This may create temporary copies 
of the atom text - <a class="func" href="foreigninclude.html#PL_STRINGS_MARK()">PL_STRINGS_MARK()</a> <var>...</var> <a class="func" href="foreigninclude.html#PL_STRINGS_RELEASE()">PL_STRINGS_RELEASE()</a> 
handles that.
<li>The *<b>_ex()</b> API functions are functionally the same as the 
ones without the <code>_ex</code> suffix, but they raise type, domain, 
or instantiation errors when the input is invalid; whereas the plain 
version may only raise resource exceptions if the request cannot be 
fullfilled due to resource exhaustion.
<li><a class="func" href="foreigninclude.html#PL_get_nil_ex()">PL_get_nil_ex()</a> 
is designed to propagate an already raised exception.
</ul>

<pre class="code">
foreign_t
pl_write_atoms(term_t l)
{ term_t head = PL_new_term_ref();   /* the elements */
  term_t tail = PL_copy_term_ref(l); /* copy (we modify tail) */
  int rc = TRUE;

  while( rc &amp;&amp; PL_get_list_ex(tail, head, tail) )
  { PL_STRINGS_MARK();
      char *s;
      if (rc=PL_get_chars(head, &amp;s, CVT_ATOM|REP_MB|CVT_EXCEPTION)) )
        rc = Sfprintf(Scurrent_output, "%s\n", s);
    PL_STRINGS_RELEASE();
  }

  return rc &amp;&amp; PL_get_nil_ex(tail); /* test end for [] */
}
</pre>

<p>Note that as of version&nbsp;7, lists have a new representation 
unless the option <strong>--traditional</strong> is used. see <a class="sec" href="ext-lists.html#sec:5.1">section 
5.1</a>.

<dl class="latex">
<dt class="pubdef"><a id="PL_get_list()"><var>int</var> <strong>PL_get_list</strong>(<var>term_t 
+l, term_t -h, term_t -t</var>)</a></dt>
<dd class="defbody">
If <var>l</var> is a list and not the empty list, assign a term 
reference to the head to <var>h</var> and to the tail to <var>t</var>.</dd>
<dt class="pubdef"><a id="PL_get_head()"><var>int</var> <strong>PL_get_head</strong>(<var>term_t 
+l, term_t -h</var>)</a></dt>
<dd class="defbody">
If <var>l</var> is a list and not the empty list, assign a term 
reference to the head to <var>h</var>.</dd>
<dt class="pubdef"><a id="PL_get_tail()"><var>int</var> <strong>PL_get_tail</strong>(<var>term_t 
+l, term_t -t</var>)</a></dt>
<dd class="defbody">
If <var>l</var> is a list and not the empty list, assign a term 
reference to the tail to <var>t</var>.</dd>
<dt class="pubdef"><a id="PL_get_nil()"><var>int</var> <strong>PL_get_nil</strong>(<var>term_t 
+l</var>)</a></dt>
<dd class="defbody">
Succeeds if <var>l</var> represents the list termination constant.</dd>
<dt class="pubdef"><a id="PL_skip_list()"><var>int</var> <strong>PL_skip_list</strong>(<var>term_t 
+list, term_t -tail, size_t *len</var>)</a></dt>
<dd class="defbody">
This is a multi-purpose function to deal with lists. It allows for 
finding the length of a list, checking whether something is a list, etc. 
The reference <var>tail</var> is set to point to the end of the list,
<var>len</var> is filled with the number of list-cells skipped, and the 
return value indicates the status of the list:

<dl class="latex">
<dt><a id="PL_LIST"><strong>PL_LIST</strong></a></dt>
<dd class="defbody">
The list is a&lsquo;proper&rsquo;list: one that ends in the list 
terminator constant and <var>tail</var> is filled with the terminator 
constant.</dd>
<dt><a id="PL_PARTIAL_LIST"><strong>PL_PARTIAL_LIST</strong></a></dt>
<dd class="defbody">
The list is a&lsquo;partial&rsquo;list: one that ends in a variable and
<var>tail</var> is a reference to this variable.</dd>
<dt><a id="PL_CYCLIC_TERM"><strong>PL_CYCLIC_TERM</strong></a></dt>
<dd class="defbody">
The list is cyclic (e.g. X = [a|X]). <var>tail</var> points to an 
arbitrary cell of the list and <var>len</var> is at most twice the cycle 
length of the list.</dd>
<dt><a id="PL_NOT_A_LIST"><strong>PL_NOT_A_LIST</strong></a></dt>
<dd class="defbody">
The term <var>list</var> is not a list at all. <var>tail</var> is bound 
to the non-list term and <var>len</var> is set to the number of 
list-cells skipped.
</dd>
</dl>

<p>It is allowed to pass 0 for <var>tail</var> and <code>NULL</code> for <var>len</var>.
</dd>
</dl>

<p><h4 id="sec:foreign-options"><a id="sec:12.4.4.6"><span class="sec-nr">12.4.4.6</span> <span class="sec-title">Processing 
option lists and dicts</span></a></h4>

<a id="sec:foreign-options"></a>

<dl class="latex">
<dt class="pubdef"><a id="PL_scan_options()"><var>int</var> <strong>PL_scan_options</strong>(<var>term_t 
options, int flags, const char* opttype, PL_option_t specs[], ...</var>)</a></dt>
<dd class="defbody">
Process an <em>option list</em> as we find with, e.g., <a id="idx:writeterm2:2529"></a><a class="pred" href="termrw.html#write_term/2">write_term/2</a> 
and many other builtin predicates. This function takes an option list 
(or dict) and in the variadic argument list pointers that receive the 
option values. <a class="func" href="foreigninclude.html#PL_scan_options()">PL_scan_options()</a> 
takes care of validating the list, ensuring the list is not cyclic, 
validating the option type and storing the converted values using the 
supplied pointers.

<p>Below is an example. While <code>PL_option_t</code> is a struct, its 
members are initialised using the <b>PL_OPTION()</b> macro. The data 
structure is not constant because <a class="func" href="foreigninclude.html#PL_scan_options()">PL_scan_options()</a> 
adds the option names as
<em>atoms</em> to speed up option processing. The macro PL_OPTIONS_END 
terminates the option list.

<pre class="code">
static PL_option_t mypred_options[] =
{ PL_OPTION("quoted",   OPT_BOOL),
  PL_OPTION("length",   OPT_SIZE),
  PL_OPTION("callback", OPT_TERM),
  PL_OPTIONS_END
};

static foreign_t
mypred(term_t a1, term_t options)
{ int    quoted   = FALSE;
  size_t length   = 10;
  term_t callback = 0;

  if ( !PL_scan_options(options, 0, "mypred_options", mypred_options,
                        &amp;quoted, &amp;length, &amp;callback) )
    return FALSE;

  &lt;implement mypred&gt;
}
</pre>

<p>The only defined value for <var>flags</var> is currently <code>OPT_ALL</code>, 
which causes this function to raise a domain error if an option is 
passed that is not in <var>specs</var>. Default in SWI-Prolog is to 
silently ignore unknown options, unless the Prolog flag <a class="flag" href="flags.html#flag:iso">iso</a> 
is <code>true</code>. The <var>opttype</var> argument defines the type 
(group) of the options, e.g., <code>"write_option"</code>. Option <em>types</em> 
are defined by the ISO standard. SWI-Prolog only uses this if <code>OPT_ALL</code> 
is specified, to raise a <code>domain_error</code> of the indicated type 
if some option is unused. The type name is normally the name of the 
predicate followed by
<code>_option</code> or the name of a representative of a group of 
predicates to which the options apply.

<p>Defined option types and their corresponding pointer type are 
described below.

<dl class="latex">
<dt><b><code>OPT_BOOL</code> <code>int</code></b></dt>
<dd class="defbody">
Convert the option value to a bool. This converts the values described 
by <a class="func" href="foreigninclude.html#PL_get_bool()">PL_get_bool()</a>. 
In addition, an option without a value (i.e., a plain atom that denotes 
the option name) can act as a boolean
<code>TRUE</code>.
</dd>
<dt><b><code>OPT_INT</code> <code>int</code></b></dt>
<dt><b><code>OPT_INT64</code> <code>int64_t</code></b></dt>
<dt><b><code>OPT_UINT64</code> <code>uint64_t</code></b></dt>
<dt><b><code>OPT_SIZE</code> <code>size_t</code></b></dt>
<dt><b><code>OPT_DOUBLE</code> <code>double</code></b></dt>
<dd class="defbody">
Numeric values of various types. Raises an error if the Prolog value 
cannot be represented by the C type.
</dd>
<dt><b><code>OPT_STRING</code> <code>char*</code></b></dt>
<dd class="defbody">
Uses <a class="func" href="foreigninclude.html#PL_get_chars()">PL_get_chars()</a> 
using the flags
<code>CVT_ALL|REP_UTF8|BUF_STACK|CVT_EXCEPTION</code>. The buffered 
string must be guarded using <a class="func" href="foreigninclude.html#PL_STRINGS_MARK()">PL_STRINGS_MARK()</a> 
and <a class="func" href="foreigninclude.html#PL_STRINGS_RELEASE()">PL_STRINGS_RELEASE()</a>.
</dd>
<dt><b><code>OPT_ATOM</code> <code>atom_t</code></b></dt>
<dd class="defbody">
Accepts an atom. Note that if the C function that implements the 
predicate wishes to keep hold of the atom after it returns it must use <a class="func" href="foreigninclude.html#PL_register_atom()">PL_register_atom()</a>.
</dd>
<dt><b><code>OPT_TERM</code> <code>term_t</code></b></dt>
<dd class="defbody">
Accepts an arbitrary Prolog term. The term handle is scoped by the 
foreign predicate invocation. Terms can be preserved using
<a class="func" href="foreigninclude.html#PL_record()">PL_record()</a>.
</dd>
</dl>

<p>The ISO standard demands that if an option is repeated the <em>last</em> 
occurance holds. This implies that <a class="func" href="foreigninclude.html#PL_scan_options()">PL_scan_options()</a> 
must scan the option list to the end.
</dd>
</dl>

<p><h4 id="sec:foreign-write"><a id="sec:12.4.4.7"><span class="sec-nr">12.4.4.7</span> <span class="sec-title">An 
example: defining write/1 in C</span></a></h4>

<a id="sec:foreign-write"></a>

<p><a class="fig" href="foreigninclude.html#fig:pl-display">Figure 6</a> 
shows a simplified definition of <a id="idx:write1:2531"></a><a class="pred" href="termrw.html#write/1">write/1</a> 
to illustrate the described functions. This simplified version does not 
deal with operators. It is called <a id="idx:display1:2532"></a><span class="pred-ext">display/1</span>, 
because it mimics closely the behaviour of this Edinburgh predicate.

<pre class="code">
foreign_t
pl_display(term_t t)
{ functor_t functor;
  int arity, len, n;
  char *s;

  switch( PL_term_type(t) )
  { case PL_VARIABLE:
    case PL_ATOM:
    case PL_INTEGER:
    case PL_FLOAT:
      PL_get_chars(t, &amp;s, CVT_ALL);
      if (! Sfprintf(Scurrent_output, "%s", s) )
        PL_fail;
      break;
    case PL_STRING:
      if ( !PL_get_string_chars(t, &amp;s, &amp;len) &amp;&amp;
           !Sfprintf(Scurrent_output, "\"%s\"", s) )
        PL_fail;
      break;
    case PL_TERM:
    { term_t a = PL_new_term_ref();

      if ( !PL_get_name_arity(t, &amp;name, &amp;arity) &amp;&amp;
           !Sfprintf(Scurrent_output, "%s(", PL_atom_chars(name)) )
        PL_fail
      for(n=1; n&lt;=arity; n++)
      { if ( ! PL_get_arg(n, t, a) )
          PL_fail;
        if ( n &gt; 1 )
          if ( ! Sfprintf(Scurrent_output, ", ") )
            PL_fail;
        if ( !pl_display(a) )
          PL_fail;
      }
      if ( !Sfprintf(Scurrent_output, ")") )
        PL_fail;
      break;
    default:
      PL_fail;                          /* should not happen */
    }
  }

  PL_succeed;
}
</pre>

<div class="caption"><b>Figure 6 : </b>A Foreign definition of <a id="idx:display1:2533"></a><span class="pred-ext">display/1</span></div>
<a id="fig:pl-display"></a>

<p><h3 id="sec:foreign-term-construct"><a id="sec:12.4.5"><span class="sec-nr">12.4.5</span> <span class="sec-title">Constructing 
Terms</span></a></h3>

<a id="sec:foreign-term-construct"></a>

<p>Terms can be constructed using functions from the <code>PL_put_*()</code> 
and
<code>PL_cons_*()</code> families. This approach builds the term&lsquo;inside-out&rsquo;, 
starting at the leaves and subsequently creating compound terms. 
Alternatively, terms may be created&lsquo;top-down&rsquo;, first 
creating a compound holding only variables and subsequently unifying the 
arguments. This section discusses functions for the first approach. This 
approach is generally used for creating arguments for <a class="func" href="foreigninclude.html#PL_call()">PL_call()</a> 
and
<a class="func" href="foreigninclude.html#PL_open_query()">PL_open_query()</a>.

<dl class="latex">
<dt class="pubdef"><a id="PL_put_variable()"><var>int</var> <strong>PL_put_variable</strong>(<var>term_t 
-t</var>)</a></dt>
<dd class="defbody">
Put a fresh variable in the term, resetting the term reference to its 
initial state.<sup class="fn">219<span class="fn-text">Older versions 
created a variable on the global stack.</span></sup>
</dd>
<dt class="pubdef"><a id="PL_put_atom()"><var>int</var> <strong>PL_put_atom</strong>(<var>term_t 
-t, atom_t a</var>)</a></dt>
<dd class="defbody">
Put an atom in the term reference from a handle. See also
<a class="func" href="foreigninclude.html#PL_new_atom()">PL_new_atom()</a> 
and <a class="func" href="foreigninclude.html#PL_atom_chars()">PL_atom_chars()</a>.
</dd>
<dt class="pubdef"><a id="PL_put_bool()"><var>int</var> <strong>PL_put_bool</strong>(<var>term_t 
-t, int val</var>)</a></dt>
<dd class="defbody">
Put one of the atoms <code>true</code> or <code>false</code> in the term 
reference See also <a class="func" href="foreigninclude.html#PL_put_atom()">PL_put_atom()</a>, <a class="func" href="foreigninclude.html#PL_unify_bool()">PL_unify_bool()</a> 
and <a class="func" href="foreigninclude.html#PL_get_bool()">PL_get_bool()</a>.
</dd>
<dt class="pubdef"><a id="PL_put_chars()"><var>int</var> <strong>PL_put_chars</strong>(<var>term_t 
-t, int flags, size_t len, const char *chars</var>)</a></dt>
<dd class="defbody">
New function to deal with setting a term from a <code>char*</code> with 
various encodings. The <var>flags</var> argument is a bitwise <em>or</em> 
specifying the Prolog target type and the encoding of <var>chars</var>. 
A Prolog type is one of <code>PL_ATOM</code>, <code>PL_STRING</code>,
<code>PL_CODE_LIST</code> or <code>PL_CHAR_LIST</code>. A representation 
is one of
<code>REP_ISO_LATIN_1</code>, <code>REP_UTF8</code> or <code>REP_MB</code>. 
See
<a class="func" href="foreigninclude.html#PL_get_chars()">PL_get_chars()</a> 
for a definition of the representation types. If
<var>len</var> is <code>-1</code> <var>chars</var> must be 
zero-terminated and the length is computed from <var>chars</var> using <b>strlen()</b>.
</dd>
<dt class="pubdef"><a id="PL_put_atom_chars()"><var>int</var> <strong>PL_put_atom_chars</strong>(<var>term_t 
-t, const char *chars</var>)</a></dt>
<dd class="defbody">
Put an atom in the term reference constructed from the zero-terminated 
string. The string itself will never be referenced by Prolog after this 
function.
</dd>
<dt class="pubdef"><a id="PL_put_string_chars()"><var>int</var> <strong>PL_put_string_chars</strong>(<var>term_t 
-t, const char *chars</var>)</a></dt>
<dd class="defbody">
Put a zero-terminated string in the term reference. The data will be 
copied. See also <a class="func" href="foreigninclude.html#PL_put_string_nchars()">PL_put_string_nchars()</a>.
</dd>
<dt class="pubdef"><a id="PL_put_string_nchars()"><var>int</var> <strong>PL_put_string_nchars</strong>(<var>term_t 
-t, size_t len, const char *chars</var>)</a></dt>
<dd class="defbody">

<p>Put a string, represented by a length/start pointer pair in the term 
reference. The data will be copied. This interface can deal with 0-bytes 
in the string. See also <a class="sec" href="foreigninclude.html#sec:12.4.24">section 
12.4.24</a>.
</dd>
<dt class="pubdef"><a id="PL_put_list_chars()"><var>int</var> <strong>PL_put_list_chars</strong>(<var>term_t 
-t, const char *chars</var>)</a></dt>
<dd class="defbody">
Put a list of ASCII values in the term reference.
</dd>
<dt class="pubdef"><a id="PL_put_integer()"><var>int</var> <strong>PL_put_integer</strong>(<var>term_t 
-t, long i</var>)</a></dt>
<dd class="defbody">
Put a Prolog integer in the term reference.
</dd>
<dt class="pubdef"><a id="PL_put_int64()"><var>int</var> <strong>PL_put_int64</strong>(<var>term_t 
-t, int64_t i</var>)</a></dt>
<dd class="defbody">
Put a Prolog integer in the term reference.
</dd>
<dt class="pubdef"><a id="PL_put_uint64()"><var>int</var> <strong>PL_put_uint64</strong>(<var>term_t 
-t, uint64_t i</var>)</a></dt>
<dd class="defbody">
Put a Prolog integer in the term reference. Note that unbounded integer 
support is required for <code>uint64_t</code> values with the highest 
bit set to 1. Without unbounded integer support, too large values raise 
a
<code>representation_error</code> exception.
</dd>
<dt class="pubdef"><a id="PL_put_pointer()"><var>int</var> <strong>PL_put_pointer</strong>(<var>term_t 
-t, void *ptr</var>)</a></dt>
<dd class="defbody">
Put a Prolog integer in the term reference. Provided <var>ptr</var> is 
in the&lsquo;<b>malloc()</b>-area&rsquo;, <a class="func" href="foreigninclude.html#PL_get_pointer()">PL_get_pointer()</a> 
will get the pointer back.
</dd>
<dt class="pubdef"><a id="PL_put_float()"><var>int</var> <strong>PL_put_float</strong>(<var>term_t 
-t, double f</var>)</a></dt>
<dd class="defbody">
Put a floating-point value in the term reference.</dd>
<dt class="pubdef"><a id="PL_put_functor()"><var>int</var> <strong>PL_put_functor</strong>(<var>term_t 
-t, functor_t functor</var>)</a></dt>
<dd class="defbody">
Create a new compound term from <var>functor</var> and bind <var>t</var> 
to this term. All arguments of the term will be variables. To create a 
term with instantiated arguments, either instantiate the arguments using 
the <code>PL_unify_*()</code> functions or use <a class="func" href="foreigninclude.html#PL_cons_functor()">PL_cons_functor()</a>.</dd>
<dt class="pubdef"><a id="PL_put_list()"><var>int</var> <strong>PL_put_list</strong>(<var>term_t 
-l</var>)</a></dt>
<dd class="defbody">
As <a class="func" href="foreigninclude.html#PL_put_functor()">PL_put_functor()</a>, 
using the list-cell functor. Note that on classical Prolog systems or in 
SWI-Prolog using the option
<strong>--traditional</strong>, this is <code><code>.</code>/2</code>, 
while on SWI-Prolog version&nbsp;7 this is <code><code>[|]</code>/2</code>.</dd>
<dt class="pubdef"><a id="PL_put_nil()"><var>int</var> <strong>PL_put_nil</strong>(<var>term_t 
-l</var>)</a></dt>
<dd class="defbody">
Put the list terminator constant in <var>l</var>. Always returns
<code>TRUE</code>. Note that in classical Prolog systems or in 
SWI-Prolog using the option <strong>--traditional</strong>, this is the 
same as
<code><a class="func" href="foreigninclude.html#PL_put_atom_chars()">PL_put_atom_chars("[]")</a></code>. 
See <a class="sec" href="ext-lists.html#sec:5.1">section 5.1</a>.</dd>
<dt class="pubdef"><a id="PL_put_term()"><var>int</var> <strong>PL_put_term</strong>(<var>term_t 
-t1, term_t +t2</var>)</a></dt>
<dd class="defbody">
Make <var>t1</var> point to the same term as <var>t2</var>. Under the 
unusual condition that <var>t2</var> is a fresh term reference this 
function requires a global stack cell and may thus return <var>FALSE</var> 
and leave a resource exception in the environment.</dd>
<dt class="pubdef"><a id="PL_cons_functor()"><var>int</var> <strong>PL_cons_functor</strong>(<var>term_t 
-h, functor_t f, ...</var>)</a></dt>
<dd class="defbody">
Create a term whose arguments are filled from a variable argument list 
holding the same number of <code>term_t</code> objects as the arity of 
the functor. To create the term <code>animal(gnu, 50)</code>, use:

<pre class="code">
{ term_t a1 = PL_new_term_ref();
  term_t a2 = PL_new_term_ref();
  term_t t  = PL_new_term_ref();
  functor_t animal2;

  /* animal2 is a constant that may be bound to a global
     variable and re-used
  */
  animal2 = PL_new_functor(PL_new_atom("animal"), 2);

  PL_put_atom_chars(a1, "gnu");
  PL_put_integer(a2, 50);
  PL_cons_functor(t, animal2, a1, a2);
}
</pre>

<p>After this sequence, the term references <var>a1</var> and <var>a2</var> 
may be used for other purposes.
</dd>
<dt class="pubdef"><a id="PL_cons_functor_v()"><var>int</var> <strong>PL_cons_functor_v</strong>(<var>term_t 
-h, functor_t f, term_t a0</var>)</a></dt>
<dd class="defbody">
Create a compound term like <a class="func" href="foreigninclude.html#PL_cons_functor()">PL_cons_functor()</a>, 
but <var>a0</var> is an array of term references as returned by <a class="func" href="foreigntypes.html#PL_new_term_refs()">PL_new_term_refs()</a>. 
The length of this array should match the number of arguments required 
by the functor.
</dd>
<dt class="pubdef"><a id="PL_cons_list()"><var>int</var> <strong>PL_cons_list</strong>(<var>term_t 
-l, term_t +h, term_t +t</var>)</a></dt>
<dd class="defbody">
Create a list (cons-) cell in <var>l</var> from the head <var>h</var> 
and tail <var>t</var>. As with <a class="func" href="foreigninclude.html#PL_cons_functor()">PL_cons_functor()</a>, 
the term references <var>h</var> and <var>t</var> may be used for other 
purposes after the call to <a class="func" href="foreigninclude.html#PL_cons_list()">PL_cons_list()</a>. 
The code below creates a list of atoms from a <code>char **</code>. The 
list is built tail-to-head. The <code>PL_unify_*()</code> functions can 
be used instead to build a list head-to-tail.

<pre class="code">
void
put_list(term_t l, int n, char **words)
{ term_t a = PL_new_term_ref();

  PL_put_nil(l);
  while( --n &gt;= 0 )
  { PL_put_atom_chars(a, words[n]);
    PL_cons_list(l, a, l);
  }
}
</pre>

</dd>
<dt class="pubdef"><a id="PL_put_dict()"><var>int</var> <strong>PL_put_dict</strong>(<var>term_t 
-h, atom_t tag, size_t len, const atom_t *keys, term_t values</var>)</a></dt>
<dd class="defbody">
Create a dict from a <var>tag</var> and vector of atom-value pairs and 
put the result in <var>h</var>. The dict's key is set by <var>tag</var>, 
which may be <code>0</code> to leave the tag unbound. The <var>keys</var> 
vector is a vector of atoms of at least <var>len</var> long. The <var>values</var> 
is a term vector allocated using <a class="func" href="foreigntypes.html#PL_new_term_refs()">PL_new_term_refs()</a> 
of at least <var>len</var> long. This function returns <code>TRUE</code> 
on success, <code>FALSE</code> on a resource error (leaving a resource 
error exception in the environment),
<code>-1</code> if some key or the <var>tag</var> is invalid and <code>-2</code> 
if there are duplicate keys.
</dd>
</dl>

<p><h3 id="sec:foreign-unify"><a id="sec:12.4.6"><span class="sec-nr">12.4.6</span> <span class="sec-title">Unifying 
data</span></a></h3>

<a id="sec:foreign-unify"></a>

<p>The functions of this section <em>unify</em> terms with other terms 
or translated C data structures. Except for <a class="func" href="foreigninclude.html#PL_unify()">PL_unify()</a>, 
these functions are specific to SWI-Prolog. They have been introduced 
because they shorten the code for returning data to Prolog and at the 
same time make this more efficient by avoiding the need to allocate 
temporary term references and reduce the number of calls to the Prolog 
API. Consider the case where we want a foreign function to return the 
host name of the machine Prolog is running on. Using the <code>PL_get_*()</code> 
and <code>PL_put_*()</code> functions, the code becomes:

<pre class="code">
foreign_t
pl_hostname(term_t name)
{ char buf[100];

  if ( gethostname(buf, sizeof buf) )
  { term_t tmp = PL_new_term_ref();

    PL_put_atom_chars(tmp, buf);
    return PL_unify(name, tmp);
  }

  PL_fail;
}
</pre>

<p>Using <a class="func" href="foreigninclude.html#PL_unify_atom_chars()">PL_unify_atom_chars()</a>, 
this becomes:

<pre class="code">
foreign_t
pl_hostname(term_t name)
{ char buf[100];

  if ( gethostname(buf, sizeof buf) )
    return PL_unify_atom_chars(name, buf);

  PL_fail;
}
</pre>

<p>Note that unification functions that perform multiple bindings may 
leave part of the bindings in case of failure. See <a class="func" href="foreigninclude.html#PL_unify()">PL_unify()</a> 
for details.

<dl class="latex">
<dt class="pubdef"><a id="PL_unify()"><var>int</var> <strong>PL_unify</strong>(<var>term_t 
?t1, term_t ?t2</var>)</a></dt>
<dd class="defbody">
Unify two Prolog terms and return <code>TRUE</code> on success. <a class="func" href="foreigninclude.html#PL_unify()">PL_unify()</a> 
does not evaluate <em>attributed variables</em> (see <a class="sec" href="attvar.html#sec:8.1">section 
8.1</a>), it merely schedules the goals associated with the attributes 
to be executed <em>after</em> the foreign predicate succeeds.<sup class="fn">220<span class="fn-text">Goal 
associated with attributes may be non-deterministic, which we cannot 
handle from a callback. A callback could also result in deeply nested 
mutual recursion between C and Prolog and eventually trigger a C stack 
overflow.</span></sup>

<p>Care is needed if <a class="func" href="foreigninclude.html#PL_unify()">PL_unify()</a> 
returns <code>FALSE</code> and the foreign function does not <em>immediately</em> 
return to Prolog with
<code>FALSE</code>. Unification may perform multiple changes to either
<var>t1</var> or <var>t2</var>. A failing unification may have created 
bindings before failure is detected. <em>Already created bindings are 
not undone</em>. For example, calling <a class="func" href="foreigninclude.html#PL_unify()">PL_unify()</a> 
on <code>a(X, a)</code> and
<code>a(c,b)</code> binds <var>X</var> to <code>c</code> and fails when 
trying to unify
<code>a</code> to <code>b</code>. If control remains in C or if we want 
to return success to Prolog, we <em>must</em> undo such bindings. In 
addition, <a class="func" href="foreigninclude.html#PL_unify()">PL_unify()</a> 
may have failed on an <b>exception</b>, typically a resource (stack) 
overflow. This can be tested using <a class="func" href="foreigninclude.html#PL_exception()">PL_exception()</a>, 
passing 0 (zero) for the query-id argument. Foreign functions that 
encounter an exception must return <code>FALSE</code> to Prolog as soon 
as possible or call <a class="func" href="foreigninclude.html#PL_clear_exception()">PL_clear_exception()</a> 
if they wish to ignore the exception. Note that there can only be an 
exception if <a class="func" href="foreigninclude.html#PL_unify()">PL_unify()</a> 
returned <code>FALSE</code>.

<p>In some scenarios we need to undo <em>partial unifications</em>. 
Suppose we have a database that contains Prolog terms and we run a query 
over this database. We must succeed on the first successful unification. 
If a unification is not successful, we must stop if there is an 
exception or undo the partial unification and try again. Suppose our 
database contains <code>f(a,1)</code> and <code>f(b,2)</code> and our 
query is <code>f(A,2)</code>. This should succeed with <var>A</var> =
<code>b</code>, but the first unification binds <var>A</var> to <code>a</code> 
before failing to unify 1 with&nbsp;2.

<pre class="code">
static foreign_t
find_in_db(term_t target)
{ fid_t fid = PL_open_foreign_frame();
  term_t candidate = PL_new_term_ref();

  while(get_from_my_database(candidate))
  { if ( PL_unify(candidate, target) ) /* found */
    { PL_close_foreign_frame(fid);
      return TRUE;
    } else if ( PL_exception(0) )      /* error */
    { PL_close_foreign_frame(fid);
      return FALSE;
    }

    PL_rewind_foreign_frame(fid);      /* try next */
  }
  PL_close_foreign_frame(fid);         /* not found */
  return FALSE;
}
</pre>

<p>This code is only needed if the foreign predicate does not return 
immediately to Prolog when <a class="func" href="foreigninclude.html#PL_unify()">PL_unify()</a> 
fails - there is an implicit frame around the entire predicate, and 
returning <code>FALSE</code> undoes all bindings when that frame is 
closed.</dd>
<dt class="pubdef"><a id="PL_unify_atom()"><var>int</var> <strong>PL_unify_atom</strong>(<var>term_t 
?t, atom_t a</var>)</a></dt>
<dd class="defbody">
Unify <var>t</var> with the atom <var>a</var> and return non-zero on 
success.</dd>
<dt class="pubdef"><a id="PL_unify_bool()"><var>int</var> <strong>PL_unify_bool</strong>(<var>term_t 
?t, int a</var>)</a></dt>
<dd class="defbody">
Unify <var>t</var> with either <code>false</code> or <code>true</code>, 
according to whether <var>a</var> is zero or non-zero. If <var>t</var> 
is instantiated, <code>off</code> and <code>on</code> are also accepted.</dd>
<dt class="pubdef"><a id="PL_unify_chars()"><var>int</var> <strong>PL_unify_chars</strong>(<var>term_t 
?t, int flags, size_t len, const char *chars</var>)</a></dt>
<dd class="defbody">
New function to deal with unification of <code>char*</code> with various 
encodings to a Prolog representation. The <var>flags</var> argument is a 
bitwise <em>or</em> specifying the Prolog target type and the encoding 
of
<var>chars</var>. A Prolog type is one of <code>PL_ATOM</code>, <code>PL_STRING</code>,
<code>PL_CODE_LIST</code> or <code>PL_CHAR_LIST</code>. A representation 
is one of
<code>REP_ISO_LATIN_1</code>, <code>REP_UTF8</code> or <code>REP_MB</code>. 
See
<a class="func" href="foreigninclude.html#PL_get_chars()">PL_get_chars()</a> 
for a definition of the representation types. If
<var>len</var> is <code>-1</code> <var>chars</var> must be 
zero-terminated and the length is computed from <var>chars</var> using <b>strlen()</b>.

<p>If <var>flags</var> includes <code>PL_DIFF_LIST</code> and type is 
one of
<code>PL_CODE_LIST</code> or <code>PL_CHAR_LIST</code>, the text is 
converted to a <em>difference list</em>. The tail of the difference list 
is
<var>t+1</var>.</dd>
<dt class="pubdef"><a id="PL_unify_atom_chars()"><var>int</var> <strong>PL_unify_atom_chars</strong>(<var>term_t 
?t, const char *chars</var>)</a></dt>
<dd class="defbody">
Unify <var>t</var> with an atom created from <var>chars</var> and return 
non-zero on success.</dd>
<dt class="pubdef"><a id="PL_unify_list_chars()"><var>int</var> <strong>PL_unify_list_chars</strong>(<var>term_t 
?t, const char *chars</var>)</a></dt>
<dd class="defbody">
Unify <var>t</var> with a list of ASCII characters constructed from
<var>chars</var>.</dd>
<dt class="pubdef"><a id="PL_unify_string_chars()"><var>void</var> <strong>PL_unify_string_chars</strong>(<var>term_t 
?t, const char *chars</var>)</a></dt>
<dd class="defbody">
Unify <var>t</var> with a Prolog string object created from the 
zero-terminated string <var>chars</var>. The data will be copied. See 
also <a class="func" href="foreigninclude.html#PL_unify_string_nchars()">PL_unify_string_nchars()</a>.
</dd>
<dt class="pubdef"><a id="PL_unify_integer()"><var>int</var> <strong>PL_unify_integer</strong>(<var>term_t 
?t, intptr_t n</var>)</a></dt>
<dd class="defbody">
Unify <var>t</var> with a Prolog integer from <var>n</var>.
</dd>
<dt class="pubdef"><a id="PL_unify_int64()"><var>int</var> <strong>PL_unify_int64</strong>(<var>term_t 
?t, int64_t n</var>)</a></dt>
<dd class="defbody">
Unify <var>t</var> with a Prolog integer from <var>n</var>.
</dd>
<dt class="pubdef"><a id="PL_unify_uint64()"><var>int</var> <strong>PL_unify_uint64</strong>(<var>term_t 
?t, uint64_t n</var>)</a></dt>
<dd class="defbody">
Unify <var>t</var> with a Prolog integer from <var>n</var>. Note that 
unbounded integer support is required if <var>n</var> does not fit in a <em>signed</em>
<code>int64_t</code>. If unbounded integers are not supported a
<code>representation_error</code> is raised.
</dd>
<dt class="pubdef"><a id="PL_unify_float()"><var>int</var> <strong>PL_unify_float</strong>(<var>term_t 
?t, double f</var>)</a></dt>
<dd class="defbody">
Unify <var>t</var> with a Prolog float from <var>f</var>.
</dd>
<dt class="pubdef"><a id="PL_unify_pointer()"><var>int</var> <strong>PL_unify_pointer</strong>(<var>term_t 
?t, void *ptr</var>)</a></dt>
<dd class="defbody">
Unify <var>t</var> with a Prolog integer describing the pointer. See 
also
<a class="func" href="foreigninclude.html#PL_put_pointer()">PL_put_pointer()</a> 
and <a class="func" href="foreigninclude.html#PL_get_pointer()">PL_get_pointer()</a>.</dd>
<dt class="pubdef"><a id="PL_unify_functor()"><var>int</var> <strong>PL_unify_functor</strong>(<var>term_t 
?t, functor_t f</var>)</a></dt>
<dd class="defbody">
If <var>t</var> is a compound term with the given functor, just succeed. 
If it is unbound, create a term and bind the variable, else fail. Note 
that this function does not create a term if the argument is already 
instantiated. If <var>f</var> is a functor with arity 0, <var>t</var> is 
unified with an atom. See also <a class="func" href="foreigninclude.html#PL_unify_compound()">PL_unify_compound()</a>.</dd>
<dt class="pubdef"><a id="PL_unify_compound()"><var>int</var> <strong>PL_unify_compound</strong>(<var>term_t 
?t, functor_t f</var>)</a></dt>
<dd class="defbody">
If <var>t</var> is a compound term with the given functor, just succeed. 
If it is unbound, create a term and bind the variable, else fail. Note 
that this function does not create a term if the argument is already 
instantiated. If <var>f</var> is a functor with arity 0, <var>t</var> is 
unified with compound without arguments. See also
<a class="func" href="foreigninclude.html#PL_unify_functor()">PL_unify_functor()</a>.</dd>
<dt class="pubdef"><a id="PL_unify_list()"><var>int</var> <strong>PL_unify_list</strong>(<var>term_t 
?l, term_t -h, term_t -t</var>)</a></dt>
<dd class="defbody">
Unify <var>l</var> with a list-cell (<code>./2</code>). If successful, 
write a reference to the head of the list into <var>h</var> and a 
reference to the tail of the list into <var>t</var>. This reference to <var>h</var> 
may be used for subsequent calls to this function. Suppose we want to 
return a list of atoms from a <code>char **</code>. We could use the 
example described by
<a class="func" href="foreigninclude.html#PL_cons_list()">PL_cons_list()</a>, 
followed by a call to <a class="func" href="foreigninclude.html#PL_unify()">PL_unify()</a>, 
or we can use the code below. If the predicate argument is unbound, the 
difference is minimal (the code based on <a class="func" href="foreigninclude.html#PL_cons_list()">PL_cons_list()</a> 
is probably slightly faster). If the argument is bound, the code below 
may fail before reaching the end of the word list, but even if the 
unification succeeds, this code avoids a duplicate (garbage) list and a 
deep unification.

<p>Note that <a class="func" href="foreigninclude.html#PL_unify_list()">PL_unify_list()</a> 
is not used with <var>env</var> but with
<code>tail</code>, which is a copy of <var>env</var>. <a class="func" href="foreigntypes.html#PL_copy_term_ref()">PL_copy_term_ref()</a> 
creates a copy <code>term_t</code> holding the same Prolog term, i.e., <em>not</em> 
a copy of the Prolog term. The only thing that is allowed to be done 
with an argument to a foreign predicate (such as <var>env</var>) is 
unification; for anything that might over-write the term, you must use a 
copy created by <a class="func" href="foreigntypes.html#PL_copy_term_ref()">PL_copy_term_ref()</a>. 
The name <a class="func" href="foreigninclude.html#PL_unify_list()">PL_unify_list()</a> 
is slightly misleading - it unifies the first argumment (<var>l</var> 
but
<em>overwrites</em> the second (<var>h</var>) and third (<var>t</var>) 
arguments.

<pre class="code">
foreign_t
pl_get_environ(term_t env)
{ term_t tail = PL_copy_term_ref(env);
  term_t item = PL_new_term_ref();
  extern char **environ;

  for(const char **e = environ; *e; e++)
  { if ( !PL_unify_list(tail, item, tail) ||
         !PL_unify_atom_chars(item, *e) )
      PL_fail;
  }

  return PL_unify_nil(tail);
}
</pre>

<p>In this example, <code>item</code> is initialized outside the loop. 
This allocates a single new reference to a term, which is used as a 
temporary inside the loop - there is no need to allocate a new reference 
each time around the loop because the <code>item</code> term reference 
can be reused and the call to <a class="func" href="foreigninclude.html#PL_unify_list()">PL_unify_list()</a> 
copies a reference to the new list cell's head into the the term 
referenced by
<code>item</code>.</dd>
<dt class="pubdef"><a id="PL_unify_nil()"><var>int</var> <strong>PL_unify_nil</strong>(<var>term_t 
?l</var>)</a></dt>
<dd class="defbody">
Unify <var>l</var> with the atom <code><code>[]</code></code>.
</dd>
<dt class="pubdef"><a id="PL_unify_arg()"><var>int</var> <strong>PL_unify_arg</strong>(<var>int 
index, term_t ?t, term_t ?a</var>)</a></dt>
<dd class="defbody">
Unifies the <em>index-th</em> argument (1-based) of <var>t</var> with
<var>a</var>.
</dd>
<dt class="pubdef"><a id="PL_unify_term()"><var>int</var> <strong>PL_unify_term</strong>(<var>term_t 
?t, ...</var>)</a></dt>
<dd class="defbody">
Unify <var>t</var> with a (normally) compound term. The remaining 
arguments are a sequence of a type identifier followed by the required 
arguments. This predicate is an extension to the Quintus and SICStus 
foreign interface from which the SWI-Prolog foreign interface has been 
derived, but has proved to be a powerful and comfortable way to create 
compound terms from C. Due to the vararg packing/unpacking and the 
required type-switching this interface is slightly slower than using the 
primitives. Please note that some bad C compilers have fairly low limits 
on the number of arguments that may be passed to a function.

<p>Special attention is required when passing numbers. C&lsquo;promotes&rsquo;any 
integral smaller than <code>int</code> to <code>int</code>. That is, the 
types
<code>char</code>, <code>short</code> and <code>int</code> are all 
passed as <code>int</code>. In addition, on most 32-bit platforms <code>int</code> 
and <code>long</code> are the same. Up to version 4.0.5, only <code>PL_INTEGER</code> 
could be specified, which was taken from the stack as <code>long</code>. 
Such code fails when passing small integral types on machines where <code>int</code> 
is smaller than <code>long</code>. It is advised to use <code>PL_SHORT</code>, <code>PL_INT</code> 
or <code>PL_LONG</code> as appropriate. Similarly, C compilers promote
<code>float</code> to <code>double</code> and therefore <code>PL_FLOAT</code> 
and
<code>PL_DOUBLE</code> are synonyms.

<p>The type identifiers are:

<dl class="latex">
<dt><b><code>PL_VARIABLE</code> <var>none</var></b></dt>
<dd class="defbody">
No op. Used in arguments of <code>PL_FUNCTOR</code>.
</dd>
<dt><b><code>PL_BOOL</code> <var>int</var></b></dt>
<dd class="defbody">
Unify the argument with <code>true</code> or <code>false</code>.
</dd>
<dt><b><code>PL_ATOM</code> <var>atom_t</var></b></dt>
<dd class="defbody">
Unify the argument with an atom, as in <a class="func" href="foreigninclude.html#PL_unify_atom()">PL_unify_atom()</a>.
</dd>
<dt><b><code>PL_CHARS</code> <var>const char *</var></b></dt>
<dd class="defbody">
Unify the argument with an atom constructed from the C <code>char *</code>, 
as in <a class="func" href="foreigninclude.html#PL_unify_atom_chars()">PL_unify_atom_chars()</a>.
</dd>
<dt><b><code>PL_NCHARS</code> <var>size_t, const char *</var></b></dt>
<dd class="defbody">
Unify the argument with an atom constructed from length and
<code>char*</code> as in <a class="func" href="foreigninclude.html#PL_unify_atom_nchars()">PL_unify_atom_nchars()</a>.
</dd>
<dt><b><code>PL_UTF8_CHARS</code> <var>const char *</var></b></dt>
<dd class="defbody">
Create an atom from a UTF-8 string.
</dd>
<dt><b><code>PL_UTF8_STRING</code> <var>const char *</var></b></dt>
<dd class="defbody">
Create a packed string object from a UTF-8 string.
</dd>
<dt><b><code>PL_MBCHARS</code> <var>const char *</var></b></dt>
<dd class="defbody">
Create an atom from a multi-byte string in the current locale.
</dd>
<dt><b><code>PL_MBCODES</code> <var>const char *</var></b></dt>
<dd class="defbody">
Create a list of character codes from a multi-byte string in the current 
locale.
</dd>
<dt><b><code>PL_MBSTRING</code> <var>const char *</var></b></dt>
<dd class="defbody">
Create a packed string object from a multi-byte string in the current 
locale.
</dd>
<dt><b><code>PL_NWCHARS</code> <var>size_t, const wchar_t *</var></b></dt>
<dd class="defbody">
Create an atom from a length and a wide character pointer.
</dd>
<dt><b><code>PL_NWCODES</code> <var>size_t, const wchar_t *</var></b></dt>
<dd class="defbody">
Create a list of character codes from a length and a wide character 
pointer.
</dd>
<dt><b><code>PL_NWSTRING</code> <var>size_t, const wchar_t *</var></b></dt>
<dd class="defbody">
Create a packed string object from a length and a wide character 
pointer.
</dd>
<dt><b><code>PL_SHORT</code> <var>short</var></b></dt>
<dd class="defbody">
Unify the argument with an integer, as in <a class="func" href="foreigninclude.html#PL_unify_integer()">PL_unify_integer()</a>. 
As
<code>short</code> is promoted to <code>int</code>, <code>PL_SHORT</code> 
is a synonym for <code>PL_INT</code>.
</dd>
<dt><b><code>PL_INTEGER</code> <var>long</var></b></dt>
<dd class="defbody">
Unify the argument with an integer, as in <a class="func" href="foreigninclude.html#PL_unify_integer()">PL_unify_integer()</a>.
</dd>
<dt><b><code>PL_INT</code> <var>int</var></b></dt>
<dd class="defbody">
Unify the argument with an integer, as in <a class="func" href="foreigninclude.html#PL_unify_integer()">PL_unify_integer()</a>.
</dd>
<dt><b><code>PL_LONG</code> <var>long</var></b></dt>
<dd class="defbody">
Unify the argument with an integer, as in <a class="func" href="foreigninclude.html#PL_unify_integer()">PL_unify_integer()</a>.
</dd>
<dt><b><code>PL_INT64</code> <var>int64_t</var></b></dt>
<dd class="defbody">
Unify the argument with a 64-bit integer, as in <a class="func" href="foreigninclude.html#PL_unify_int64()">PL_unify_int64()</a>.
</dd>
<dt><b><code>PL_INTPTR</code> <var>intptr_t</var></b></dt>
<dd class="defbody">
Unify the argument with an integer with the same width as a pointer. On 
most machines this is the same as <code>PL_LONG</code>. but on 64-bit 
MS-Windows pointers are 64 bits while longs are only 32 bits.
</dd>
<dt><b><code>PL_DOUBLE</code> <var>double</var></b></dt>
<dd class="defbody">
Unify the argument with a float, as in <a class="func" href="foreigninclude.html#PL_unify_float()">PL_unify_float()</a>. 
Note that, as the argument is passed using the C vararg conventions, a 
float must be casted to a double explicitly.
</dd>
<dt><b><code>PL_FLOAT</code> <var>double</var></b></dt>
<dd class="defbody">
Unify the argument with a float, as in <a class="func" href="foreigninclude.html#PL_unify_float()">PL_unify_float()</a>.
</dd>
<dt><b><code>PL_POINTER</code> <var>void *</var></b></dt>
<dd class="defbody">
Unify the argument with a pointer, as in <a class="func" href="foreigninclude.html#PL_unify_pointer()">PL_unify_pointer()</a>.
</dd>
<dt><b><code>PL_STRING</code> <var>const char *</var></b></dt>
<dd class="defbody">
Unify the argument with a string object, as in <a class="func" href="foreigninclude.html#PL_unify_string_chars()">PL_unify_string_chars()</a>.
</dd>
<dt><b><code>PL_TERM</code> <var>term_t</var></b></dt>
<dd class="defbody">
Unify a subterm. Note this may be the return value of a <a class="func" href="foreigntypes.html#PL_new_term_ref()">PL_new_term_ref()</a> 
call to get access to a variable.
</dd>
<dt><b><code>PL_FUNCTOR</code> <var>functor_t, ...</var></b></dt>
<dd class="defbody">
Unify the argument with a compound term. This specification should be 
followed by exactly as many specifications as the number of arguments of 
the compound term.
</dd>
<dt><b><code>PL_FUNCTOR_CHARS</code> <var>const char *name, int arity, 
...</var></b></dt>
<dd class="defbody">
Create a functor from the given name and arity and then behave as
<code>PL_FUNCTOR</code>.
</dd>
<dt><b><code>PL_LIST</code> <var>int length, ...</var></b></dt>
<dd class="defbody">
Create a list of the indicated length. The remaining arguments contain 
the elements of the list.
</dd>
</dl>

<p>For example, to unify an argument with the term <code>language(dutch)</code>, 
the following skeleton may be used:

<pre class="code">
static functor_t FUNCTOR_language1;

static void
init_constants()
{ FUNCTOR_language1 = PL_new_functor(PL_new_atom("language"),1);
}

foreign_t
pl_get_lang(term_t r)
{ return PL_unify_term(r,
                       PL_FUNCTOR, FUNCTOR_language1,
                           PL_CHARS, "dutch");
}

install_t
install()
{ PL_register_foreign("get_lang", 1, pl_get_lang, 0);
  init_constants();
}
</pre>

</dd>
<dt class="pubdef"><a id="PL_chars_to_term()"><var>int</var> <strong>PL_chars_to_term</strong>(<var>const 
char *chars, term_t -t</var>)</a></dt>
<dd class="defbody">
Parse the string <var>chars</var> and put the resulting Prolog term into
<var>t</var>. <var>chars</var> may or may not be closed using a Prolog 
full-stop (i.e., a dot followed by a blank). Returns <code>FALSE</code> 
if a syntax error was encountered and <code>TRUE</code> after successful 
completion. In addition to returning <code>FALSE</code>, the 
exception-term is returned in <var>t</var> on a syntax error. See also <a id="idx:termtoatom2:2534"></a><a class="pred" href="manipatom.html#term_to_atom/2">term_to_atom/2</a>.

<p>The following example builds a goal term from a string and calls it.

<pre class="code">
int
call_chars(const char *goal)
{ fid_t fid = PL_open_foreign_frame();
  term_t g = PL_new_term_ref();
  BOOL rval;

  if ( PL_chars_to_term(goal, g) )
    rval = PL_call(goal, NULL);
  else
    rval = FALSE;

  PL_discard_foreign_frame(fid);
  return rval;
}
  ...
  call_chars("consult(load)");
  ...
</pre>

<p><a class="func" href="foreigninclude.html#PL_chars_to_term()">PL_chars_to_term()</a> 
is defined using <a class="func" href="foreigninclude.html#PL_put_term_from_chars()">PL_put_term_from_chars()</a> 
which can deal with not null-terminated strings as well as strings using 
different encodings:

<pre class="code">
int
PL_chars_to_term(const char *s, term_t t)
{ return PL_put_term_from_chars(t, REP_ISO_LATIN_1, (size_t)-1, s);
}
</pre>

</dd>
<dt class="pubdef"><a id="PL_wchars_to_term()"><var>int</var> <strong>PL_wchars_to_term</strong>(<var>const 
pl_wchar_t *chars, term_t -t</var>)</a></dt>
<dd class="defbody">
Wide character version of <a class="func" href="foreigninclude.html#PL_chars_to_term()">PL_chars_to_term()</a>.</dd>
<dt class="pubdef"><a id="PL_quote()"><var>char *</var> <strong>PL_quote</strong>(<var>int 
chr, const char *string</var>)</a></dt>
<dd class="defbody">
Return a quoted version of <var>string</var>. If <var>chr</var> is
<code>'\''</code>, the result is a quoted atom. If <var>chr</var> is
<code>'"'</code>, the result is a string. The result string is stored in 
the same ring of buffers as described with the <code>BUF_STACK</code> 
argument of <a class="func" href="foreigninclude.html#PL_get_chars()">PL_get_chars()</a>;

<p>In the current implementation, the string is surrounded by
<var>chr</var> and any occurrence of <var>chr</var> is doubled. In the 
future the behaviour will depend on the
<a class="flag" href="flags.html#flag:character_escapes">character_escapes</a> 
Prolog flag.</dd>
<dt class="pubdef"><a id="PL_for_dict()"><var>int</var> <strong>PL_for_dict</strong>(<var>term_t 
dict, int (*func)(term_t key, term_t value, void *closure), void 
*closure, int flags</var>)</a></dt>
<dd class="defbody">
Iterates over <var>dict</var>, calling <var>func</var> for each item. In 
each call, <var>key</var> and <var>value</var> are the processed item's 
key-value pair and the <var>closure</var> argument is passed from the 
call to
<a class="func" href="foreigninclude.html#PL_for_dict()">PL_for_dict()</a>. 
If <var>func</var> returns a non-<code>0</code> value, the iteration 
stops and <a class="func" href="foreigninclude.html#PL_for_dict()">PL_for_dict()</a> 
returns that value; otherwise, all pairs are processed and <a class="func" href="foreigninclude.html#PL_for_dict()">PL_for_dict()</a> 
returns <code>0</code>. If
<var>flags</var> contains <code>PL_FOR_DICT_SORTED</code>, the key-value 
pairs are processed in the standard order of terms; otherwise the 
processing order is unspecified.
</dd>
</dl>

<p><h3 id="sec:cerror"><a id="sec:12.4.7"><span class="sec-nr">12.4.7</span> <span class="sec-title">Convenient 
functions to generate Prolog exceptions</span></a></h3>

<a id="sec:cerror"></a>

<p>The typical implementation of a foreign predicate first uses the 
PL_get_*() functions to extract C data types from the Prolog terms. 
Failure of any of these functions is normally because the Prolog term is 
of the wrong type. The *<b>_ex()</b> family of functions are wrappers 
around (mostly) the PL_get_*() functions, such that we can write code in 
the style below and get proper exceptions if an argument is 
uninstantiated or of the wrong type. <a class="sec" href="foreigninclude.html#sec:12.4.8">Section 
12.4.8</a> documents an alternative API to fetch values for the C basic 
types.

<pre class="code">
/** set_size(+Name:atom, +Width:int, +Height:int) is det.

static foreign_t
set_size(term_t name, term_t width, term_t height)
{ char *n;
  int w, h;

  if ( !PL_get_chars(name, &amp;n, CVT_ATOM|CVT_EXCEPTION) ||
       !PL_get_integer_ex(with, &amp;w) ||
       !PL_get_integer_ex(height, &amp;h) )
    return FALSE;

  ...

}
</pre>

<dl class="latex">
<dt class="pubdef"><a id="PL_get_atom_ex()"><var>int</var> <strong>PL_get_atom_ex</strong>(<var>term_t 
t, atom_t *a</var>)</a></dt>
<dd class="defbody">
As <a class="func" href="foreigninclude.html#PL_get_atom()">PL_get_atom()</a>, 
but raises a type or instantiation error if
<var>t</var> is not an atom.</dd>
<dt class="pubdef"><a id="PL_get_integer_ex()"><var>int</var> <strong>PL_get_integer_ex</strong>(<var>term_t 
t, int *i</var>)</a></dt>
<dd class="defbody">
As <a class="func" href="foreigninclude.html#PL_get_integer()">PL_get_integer()</a>, 
but raises a type or instantiation error if
<var>t</var> is not an integer, or a representation error if the Prolog 
integer does not fit in a C <code>int</code>.</dd>
<dt class="pubdef"><a id="PL_get_long_ex()"><var>int</var> <strong>PL_get_long_ex</strong>(<var>term_t 
t, long *i</var>)</a></dt>
<dd class="defbody">
As <a class="func" href="foreigninclude.html#PL_get_long()">PL_get_long()</a>, 
but raises a type or instantiation error if
<var>t</var> is not an atom, or a representation error if the Prolog 
integer does not fit in a C <code>long</code>.</dd>
<dt class="pubdef"><a id="PL_get_int64_ex()"><var>int</var> <strong>PL_get_int64_ex</strong>(<var>term_t 
t, int64_t *i</var>)</a></dt>
<dd class="defbody">
As <a class="func" href="foreigninclude.html#PL_get_int64()">PL_get_int64()</a>, 
but raises a type or instantiation error if
<var>t</var> is not an integer, or a representation error if the Prolog 
integer does not fit in a C <code>int64_t</code>.</dd>
<dt class="pubdef"><a id="PL_get_uint64_ex()"><var>int</var> <strong>PL_get_uint64_ex</strong>(<var>term_t 
t, uint64_t *i</var>)</a></dt>
<dd class="defbody">
As <a class="func" href="foreigninclude.html#PL_get_uint64()">PL_get_uint64()</a>, 
but raises a type, domain or instantiation error if
<var>t</var> is not an integer or <var>t</var> is less than zero, or a 
representation error if the Prolog integer does not fit in a C
<code>int64_t</code>.</dd>
<dt class="pubdef"><a id="PL_get_intptr_ex()"><var>int</var> <strong>PL_get_intptr_ex</strong>(<var>term_t 
t, intptr_t *i</var>)</a></dt>
<dd class="defbody">
As <a class="func" href="foreigninclude.html#PL_get_intptr()">PL_get_intptr()</a>, 
but raises a type or instantiation error if
<var>t</var> is not an atom, or a representation error if the Prolog 
integer does not fit in a C <code>intptr_t</code>.</dd>
<dt class="pubdef"><a id="PL_get_size_ex()"><var>int</var> <strong>PL_get_size_ex</strong>(<var>term_t 
t, size_t *i</var>)</a></dt>
<dd class="defbody">
As <a class="func" href="foreigninclude.html#PL_get_intptr()">PL_get_intptr()</a>, 
but raises a type or instantiation error if
<var>t</var> is not an integer, or a representation error if the Prolog 
integer does not fit in a C <code>size_t</code>.</dd>
<dt class="pubdef"><a id="PL_get_bool_ex()"><var>int</var> <strong>PL_get_bool_ex</strong>(<var>term_t 
t, int *i</var>)</a></dt>
<dd class="defbody">
As <a class="func" href="foreigninclude.html#PL_get_bool()">PL_get_bool()</a>, 
but raises a type or instantiation error if <var>t</var> is not a valid 
boolean value (<code>true</code>, <code>false</code>, <code>on</code>, 
constoff, <code>1</code> or <code>0</code>). Note that the pointer is to 
an
<code>int</code> because C has no <code>bool</code> type.</dd>
<dt class="pubdef"><a id="PL_get_float_ex()"><var>int</var> <strong>PL_get_float_ex</strong>(<var>term_t 
t, double *f</var>)</a></dt>
<dd class="defbody">
As <a class="func" href="foreigninclude.html#PL_get_float()">PL_get_float()</a>, 
but raises a type or instantiation error if
<var>t</var> is not a float.</dd>
<dt class="pubdef"><a id="PL_get_char_ex()"><var>int</var> <strong>PL_get_char_ex</strong>(<var>term_t 
t, int *p, int eof</var>)</a></dt>
<dd class="defbody">
Get a character code from <var>t</var>, where <var>t</var> is either an 
integer or an atom with length one. If <var>eof</var> is <code>TRUE</code> 
and <var>t</var> is -1, <var>p</var> is filled with -1. Raises an 
appropriate error if the conversion is not possible.</dd>
<dt class="pubdef"><a id="PL_get_pointer_ex()"><var>int</var> <strong>PL_get_pointer_ex</strong>(<var>term_t 
t, void **addrp</var>)</a></dt>
<dd class="defbody">
As <a class="func" href="foreigninclude.html#PL_get_pointer()">PL_get_pointer()</a>, 
but raises a type or instantiation error if
<var>t</var> is not a pointer.</dd>
<dt class="pubdef"><a id="PL_get_list_ex()"><var>int</var> <strong>PL_get_list_ex</strong>(<var>term_t 
l, term_t h, term_t t</var>)</a></dt>
<dd class="defbody">
As <a class="func" href="foreigninclude.html#PL_get_list()">PL_get_list()</a>, 
but raises a type or instantiation error if
<var>t</var> is not a list.</dd>
<dt class="pubdef"><a id="PL_get_nil_ex()"><var>int</var> <strong>PL_get_nil_ex</strong>(<var>term_t 
l</var>)</a></dt>
<dd class="defbody">
As <a class="func" href="foreigninclude.html#PL_get_nil()">PL_get_nil()</a>, 
but raises a type or instantiation error if
<var>t</var> is not the empty list. Because <a class="func" href="foreigninclude.html#PL_get_nil_ex()">PL_get_nil_ex()</a> 
is commonly used after a <code>while</code> loop over <a class="func" href="foreigninclude.html#PL_get_list_ex()">PL_get_list_ex()</a>, 
it fails immediately if there is an exception pending (from <a class="func" href="foreigninclude.html#PL_get_list_ex()">PL_get_list_ex()</a>).</dd>
<dt class="pubdef"><a id="PL_unify_list_ex()"><var>int</var> <strong>PL_unify_list_ex</strong>(<var>term_t 
l, term_t h, term_t t</var>)</a></dt>
<dd class="defbody">
As <a class="func" href="foreigninclude.html#PL_unify_list()">PL_unify_list()</a>, 
but raises a type error if <var>t</var> is not a variable, list-cell or 
the empty list.</dd>
<dt class="pubdef"><a id="PL_unify_nil_ex()"><var>int</var> <strong>PL_unify_nil_ex</strong>(<var>term_t 
l</var>)</a></dt>
<dd class="defbody">
As <a class="func" href="foreigninclude.html#PL_unify_nil()">PL_unify_nil()</a>, 
but raises a type error if <var>t</var> is not a variable, list-cell or 
the empty list.</dd>
<dt class="pubdef"><a id="PL_unify_bool_ex()"><var>int</var> <strong>PL_unify_bool_ex</strong>(<var>term_t 
t, int val</var>)</a></dt>
<dd class="defbody">
As <a class="func" href="foreigninclude.html#PL_unify_bool()">PL_unify_bool()</a>, 
but raises a type error if <var>t</var> is not a variable or a boolean.
</dd>
</dl>

<p>The second family of functions in this section simplifies the 
generation of ISO compatible error terms. Any foreign function that 
calls this function must return to Prolog with the return code of the 
error function or the constant <code>FALSE</code>. If available, these 
error functions add the name of the calling predicate to the error 
context. See also <a class="func" href="foreigninclude.html#PL_raise_exception()">PL_raise_exception()</a>.

<dl class="latex">
<dt class="pubdef"><a id="PL_instantiation_error()"><var>int</var> <strong>PL_instantiation_error</strong>(<var>term_t 
culprit</var>)</a></dt>
<dd class="defbody">
Raise <code>instantiation_error</code>. <var>Culprit</var> is ignored, 
but should be bound to the term that is insufficiently instantiated. See
<a id="idx:instantiationerror1:2535"></a><a class="pred" href="error.html#instantiation_error/1">instantiation_error/1</a>.</dd>
<dt class="pubdef"><a id="PL_uninstantiation_error()"><var>int</var> <strong>PL_uninstantiation_error</strong>(<var>term_t 
culprit</var>)</a></dt>
<dd class="defbody">
Raise <code>uninstantiation_error(culprit)</code>. This should be called 
if an argument that must be unbound at entry is bound to <var>culprit</var>. 
This error is typically raised for a pure output arguments such as a 
newly created stream handle (e.g., the third argument of <a id="idx:open3:2536"></a><a class="pred" href="IO.html#open/3">open/3</a>).</dd>
<dt class="pubdef"><a id="PL_representation_error()"><var>int</var> <strong>PL_representation_error</strong>(<var>const 
char *resource</var>)</a></dt>
<dd class="defbody">
Raise <code>representation_error(resource)</code>. See <a id="idx:representationerror1:2537"></a><a class="pred" href="error.html#representation_error/1">representation_error/1</a>.</dd>
<dt class="pubdef"><a id="PL_type_error()"><var>int</var> <strong>PL_type_error</strong>(<var>const 
char *expected, term_t culprit</var>)</a></dt>
<dd class="defbody">
Raise <code>type_error(expected, culprit)</code>. See <a id="idx:typeerror2:2538"></a><a class="pred" href="error.html#type_error/2">type_error/2</a>.</dd>
<dt class="pubdef"><a id="PL_domain_error()"><var>int</var> <strong>PL_domain_error</strong>(<var>const 
char *expected, term_t culprit</var>)</a></dt>
<dd class="defbody">
Raise <code>domain_error(expected, culprit)</code>. See <a id="idx:domainerror2:2539"></a><a class="pred" href="error.html#domain_error/2">domain_error/2</a>.</dd>
<dt class="pubdef"><a id="PL_existence_error()"><var>int</var> <strong>PL_existence_error</strong>(<var>const 
char *type, term_t culprit</var>)</a></dt>
<dd class="defbody">
Raise <code>existence_error(type, culprit)</code>. See <a id="idx:existenceerror2:2540"></a><a class="pred" href="error.html#existence_error/2">existence_error/2</a>.</dd>
<dt class="pubdef"><a id="PL_permission_error()"><var>int</var> <strong>PL_permission_error</strong>(<var>const 
char *operation, const char *type, term_t culprit</var>)</a></dt>
<dd class="defbody">
Raise <code>permission_error(operation, type, culprit)</code>. See
<a id="idx:permissionerror3:2541"></a><a class="pred" href="error.html#permission_error/3">permission_error/3</a>.
</dd>
<dt class="pubdef"><a id="PL_resource_error()"><var>int</var> <strong>PL_resource_error</strong>(<var>const 
char *resource</var>)</a></dt>
<dd class="defbody">
Raise <code>resource_error(resource)</code>. See <a id="idx:resourceerror1:2542"></a><a class="pred" href="error.html#resource_error/1">resource_error/1</a>.
</dd>
<dt class="pubdef"><a id="PL_syntax_error()"><var>int</var> <strong>PL_syntax_error</strong>(<var>const 
char *message, IOSTREAM *in</var>)</a></dt>
<dd class="defbody">
Raise <code>syntax_error(message)</code>. If <var>arg</var> is not <code>NULL</code>, 
add information about the current position of the input stream.
</dd>
</dl>

<p><h3 id="sec:pl-cvt-functions"><a id="sec:12.4.8"><span class="sec-nr">12.4.8</span> <span class="sec-title">Foreign 
language wrapper support functions</span></a></h3>

<a id="sec:pl-cvt-functions"></a>

<p>In addition to the functions described in
<a class="sec" href="foreigninclude.html#sec:12.4.4.2">section 12.4.4.2</a>, 
there is a family of functions that is used for automatic generation of 
wrapper functions, for example using the Prolog library <code>library(qpforeign)</code> 
that provides a Quintus/SICStus compatible foreign language interface.

<p>The PL_cvt_i_*() family of functions is suitable for use with a
<code>_Generic</code> selector or C++ overloading.<sup class="fn">221<span class="fn-text"><code>_Generic</code> 
needs to take into account that there's no <code>bool</code> type in C 
but there is in C++. An overloaded <b>integer()</b> method is provided 
in the C++ interface.</span></sup>

<p>Note that the documentation on this API is incomplete. Also note that 
many of these functions are equivalent to the PL_get_*<b>_ex()</b> 
functions described in <a class="sec" href="foreigninclude.html#sec:12.4.7">section 
12.4.7</a>.

<dl class="latex">
<dt class="pubdef"><a id="PL_cvt_i_bool()"><var>int</var> <strong>PL_cvt_i_bool</strong>(<var>term_t 
p, int *c</var>)</a></dt>
<dd class="defbody">
Equivalent to <a class="func" href="foreigninclude.html#PL_get_bool_ex()">PL_get_bool_ex()</a>. 
Note that the pointer is to an
<code>int</code> because C has no <code>bool</code> type. The return 
value is either <code>0</code> or <code>1</code>.</dd>
<dt class="pubdef"><a id="PL_cvt_i_char()"><var>int</var> <strong>PL_cvt_i_char</strong>(<var>term_t 
p, char *c</var>)</a></dt>
<dt class="pubdef"><a id="PL_cvt_i_schar()"><var>int</var> <strong>PL_cvt_i_schar</strong>(<var>term_t 
p, signed char *c</var>)</a></dt>
<dt class="pubdef"><a id="PL_cvt_i_uchar()"><var>int</var> <strong>PL_cvt_i_uchar</strong>(<var>term_t 
p, unsigned char *c</var>)</a></dt>
<dt class="pubdef"><a id="PL_cvt_i_short()"><var>int</var> <strong>PL_cvt_i_short</strong>(<var>term_t 
p, short *s</var>)</a></dt>
<dt class="pubdef"><a id="PL_cvt_i_ushort()"><var>int</var> <strong>PL_cvt_i_ushort</strong>(<var>term_t 
p, unsigned short *s</var>)</a></dt>
<dt class="pubdef"><a id="PL_cvt_i_int()"><var>int</var> <strong>PL_cvt_i_int</strong>(<var>term_t 
p, int *c</var>)</a></dt>
<dt class="pubdef"><a id="PL_cvt_i_uint()"><var>int</var> <strong>PL_cvt_i_uint</strong>(<var>term_t 
p, unsigned int *c</var>)</a></dt>
<dt class="pubdef"><a id="PL_cvt_i_long()"><var>int</var> <strong>PL_cvt_i_long</strong>(<var>term_t 
p, long *c</var>)</a></dt>
<dt class="pubdef"><a id="PL_cvt_i_ulong()"><var>int</var> <strong>PL_cvt_i_ulong</strong>(<var>term_t 
p, unsigned long *c</var>)</a></dt>
<dt class="pubdef"><a id="PL_cvt_i_llong()"><var>int</var> <strong>PL_cvt_i_llong</strong>(<var>term_t 
p, long long *c</var>)</a></dt>
<dt class="pubdef"><a id="PL_cvt_i_ullong()"><var>int</var> <strong>PL_cvt_i_ullong</strong>(<var>term_t 
p, unsigned long long *c</var>)</a></dt>
<dt class="pubdef"><a id="PL_cvt_i_int32()"><var>int</var> <strong>PL_cvt_i_int32</strong>(<var>term_t 
p, int32_t *c</var>)</a></dt>
<dt class="pubdef"><a id="PL_cvt_i_uint32()"><var>int</var> <strong>PL_cvt_i_uint32</strong>(<var>term_t 
p, uint32_t *c</var>)</a></dt>
<dt class="pubdef"><a id="PL_cvt_i_int64()"><var>int</var> <strong>PL_cvt_i_int64</strong>(<var>term_t 
p, int64_t *c</var>)</a></dt>
<dt class="pubdef"><a id="PL_cvt_i_uint64()"><var>int</var> <strong>PL_cvt_i_uint64</strong>(<var>term_t 
p, uint64_t *c</var>)</a></dt>
<dt class="pubdef"><a id="PL_cvt_i_size_t()"><var>int</var> <strong>PL_cvt_i_size_t</strong>(<var>term_t 
p, size_t *c</var>)</a></dt>
<dd class="defbody">
Convert a Prolog integer into a C integer of the specified size. 
Generate an exception and return <code>FALSE</code> if the conversion is 
impossible because the Prolog term is not an integer or the C type 
cannot represent the value of the Prolog integer.
</dd>
</dl>

<p><h3 id="sec:foreign-serialize"><a id="sec:12.4.9"><span class="sec-nr">12.4.9</span> <span class="sec-title">Serializing 
and deserializing Prolog terms</span></a></h3>

<a id="sec:foreign-serialize"></a>

<dl class="latex">
<dt class="pubdef"><a id="PL_put_term_from_chars()"><var>int</var> <strong>PL_put_term_from_chars</strong>(<var>term_t 
t, int flags, size_t len, const char *s</var>)</a></dt>
<dd class="defbody">
Parse the text from the C-string <var>s</var> holding <var>len</var> 
bytes and put the resulting term in <var>t</var>. <var>len</var> can be <code>(size_t)-1</code>, 
assuming a 0-terminated string. The <var>flags</var> argument controls 
the encoding and is currently one of <code>REP_UTF8</code> (string is 
UTF8 encoded), <code>REP_MB</code> (string is encoded in the current 
locale) or 0 (string is encoded in ISO latin 1). The string may, but is 
not required, to be closed by a full stop (.).

<p>If parsing produces an exception; the behaviour depends on the
<code>CVT_EXCEPTION</code> flag. If present, the exception is propagated 
into the environment. Otherwise, the exception is placed in <var>t</var> 
and the return value is <code>FALSE</code>.<sup class="fn">222<span class="fn-text">The <code>CVT_EXCEPTION</code> 
was added in version 8.3.12</span></sup>.
</dd>
</dl>

<p><h3 id="sec:blob"><a id="sec:12.4.10"><span class="sec-nr">12.4.10</span> <span class="sec-title">BLOBS: 
Using atoms to store arbitrary binary data</span></a></h3>

<a id="sec:blob"></a>

<p><a id="idx:Java:2543"></a><a id="idx:COM:2544"></a>SWI-Prolog atoms 
as well as strings can represent arbitrary binary data of arbitrary 
length. This facility is attractive for storing foreign data such as 
images in an atom. An atom is a unique handle to this data and the atom 
garbage collector is able to destroy atoms that are no longer referenced 
by the Prolog engine. This property of atoms makes them attractive as a 
handle to foreign resources, such as Java atoms, Microsoft's COM 
objects, etc., providing safe combined garbage collection.

<p>To exploit these features safely and in an organised manner, the 
SWI-Prolog foreign interface allows creating&lsquo;atoms&rsquo;with 
additional type information. The type is represented by a structure 
holding C function pointers that tell Prolog how to handle releasing the 
atom, writing it, sorting it, etc. Two atoms created with different 
types can represent the same sequence of bytes. Atoms are first ordered 
on the rank number of the type and then on the result of the
<a class="func" href="foreigninclude.html#compare()">compare()</a> 
function. Rank numbers are assigned when the type is registered. This 
implies that the results of inequality comparisons between blobs of 
different types is undefined and can change if the program is run twice 
(the ordering within a blob type will not change, of course).

<p>While the blob is alive, neither its handle nor the location of the 
contents (see <a class="func" href="foreigninclude.html#PL_blob_data()">PL_blob_data()</a>) 
change. If the blob's type has the
<code>PL_BLOB_UNIQUE</code> feature, the content of the blob must remain 
unmodified. If the blob's type does not have the
<code>PL_BLOB_UNIQUE</code> feature multiple instances of this blob type 
may contain the same data. The blob <em>handle</em> (<code>atom_t</code>) 
is reclaimed <em>only</em> by the atom garbage collector. The blob's
<em>content</em> (data) is normally reclaimed when the garbage collector 
reclaims the blob. If the blob's type defines the
<a class="func" href="foreigninclude.html#release()">release()</a> 
function, this function is called. This hook may deal with side effects 
and is responsible of releasing the data if the blob's type has the <code>PL_BLOB_NOCOPY</code> 
flag. The content of a
<code>PL_BLOB_NOCOPY</code> blob may be released before the blob itself 
can be garbage collected using <a class="func" href="foreigninclude.html#PL_free_blob()">PL_free_blob()</a>. 
This immediately triggers the <a class="func" href="foreigninclude.html#release()">release()</a> 
function. After <a class="func" href="foreigninclude.html#PL_free_blob()">PL_free_blob()</a> 
has reclaimed the content, this function will not be called when the <code>atom_t</code> 
handle is reclaimed. An <code>atom_t</code> handle may be reused for a 
new atom or blob after it has been garbage collected.

<p>If foreign code stores the <code>atom_t</code> handle in some 
permanent location it must make sure the handle is <em>registered</em> 
to prevent it from being garbage collected. If the handle is obtained 
from a
<code>term_t</code> object it is <b>not</b> registered because it is 
protected by the <code>term_t</code> object. This applies to e.g.,
<a class="func" href="foreigninclude.html#PL_get_atom()">PL_get_atom()</a>. 
Functions that create a handle from data, such as
<a class="func" href="foreigninclude.html#PL_new_atom()">PL_new_atom()</a>, 
return a registered handle to prevent the asynchronous atom garbage 
collector from reclaiming it immediately. Note that many of the API 
functions create an atom or blob handle and use this to fill a
<code>term_t</code> object, e.g., <a class="func" href="foreigninclude.html#PL_unify_blob()">PL_unify_blob()</a>, <a class="func" href="foreigninclude.html#PL_unify_chars()">PL_unify_chars()</a>, 
etc. In this scenario the handle is protected by the <code>term_t</code> 
object. Registering and unregistering <code>atom_t</code> handles is 
done by
<a class="func" href="foreigninclude.html#PL_register_atom()">PL_register_atom()</a> 
and <a class="func" href="foreigninclude.html#PL_unregister_atom()">PL_unregister_atom()</a>.

<p>Note that during program shutdown using <a class="func" href="foreigninclude.html#PL_cleanup()">PL_cleanup()</a>, 
all atoms and blobs are reclaimed as described above. <b>These objects 
are reclaimed regardless of their registration count. The order in which 
the atoms or blobs are reclaimed under <a class="func" href="foreigninclude.html#PL_cleanup()">PL_cleanup()</a> 
is undefined.</b> However, when these objects are reclaimed using <a id="idx:garbagecollectatoms0:2545"></a><a class="pred" href="memory.html#garbage_collect_atoms/0">garbage_collect_atoms/0</a>, 
registration counts are taken into account.

<p><h4 id="sec:blobtype"><a id="sec:12.4.10.1"><span class="sec-nr">12.4.10.1</span> <span class="sec-title">Defining 
a BLOB type</span></a></h4>

<a id="sec:blobtype"></a>

<p>The type <code>PL_blob_t</code> represents a structure with the 
layout displayed below. The structure contains additional fields at the 
... for internal bookkeeping as well as future extensions.

<pre class="code">
typedef struct PL_blob_t
{ uintptr_t     magic;          /* PL_BLOB_MAGIC */
  uintptr_t     flags;          /* Bitwise or of PL_BLOB_* */
  const char *  name;           /* name of the type */
  int           (*release)(atom_t a);
  int           (*compare)(atom_t a, atom_t b);
  int           (*write)(IOSTREAM *s, atom_t a, int flags);
  void          (*acquire)(atom_t a);
  int           (*save)(atom_t a, IOSTREAM *s);
  atom_t        (*load)(IOSTREAM *s);
  ...
} PL_blob_t;
</pre>

<p>For each type, exactly one such structure should be allocated and 
must not be moved because the address of the structure determines the 
blob's "type". Its first field must be initialised to <code>PL_BLOB_MAGIC</code>. 
If a blob type is registered from a loadable object (shared object or 
DLL) the blob type must be deregistered using <a class="func" href="foreigninclude.html#PL_unregister_blob_type()">PL_unregister_blob_type()</a> 
before the object may be released.

<p>The <var>flags</var> is a bitwise <em>or</em> of the following 
constants:

<dl class="latex">
<dt><a id="PL_BLOB_TEXT"><strong>PL_BLOB_TEXT</strong></a></dt>
<dd class="defbody">
If specified, the blob is assumed to contain text and is considered a 
normal Prolog atom. The (currently) two predefined blob types that 
represent atoms have this flag set. User-defined blobs may not specify 
this, even if they contain only text. Applications should <em>not</em> 
use the blob API to create normal text atoms or get access to the text 
represented by normal text atoms. Most applications should use
<a class="func" href="foreigninclude.html#PL_get_nchars()">PL_get_nchars()</a> 
and <a class="func" href="foreigninclude.html#PL_unify_chars()">PL_unify_chars()</a> 
to get text from Prolog terms or create Prolog terms that represent 
text.</dd>
<dt><a id="PL_BLOB_UNIQUE"><strong>PL_BLOB_UNIQUE</strong></a></dt>
<dd class="defbody">
If specified the system ensures that the blob-handle is a unique 
reference for a blob with the given type, length and content. If this 
flag is not specified, each lookup creates a new blob. Uniqueness is 
determined by comparing the bytes in the blobs unless
<code>PL_BLOB_NOCOPY</code> is also specified, in which case the 
pointers are compared. Note that the lookup does <em>not</em> use the 
blob's compare function when testing for equality, but only tests the 
bytes; this means that terms from the recorded database or C++-style 
strings will typically not compare as equal when doing blob lookup.</dd>
<dt><a id="PL_BLOB_NOCOPY"><strong>PL_BLOB_NOCOPY</strong></a></dt>
<dd class="defbody">
By default the content of the blob is copied. Using this flag the blob 
references the external data directly. The user must ensure the provided 
pointer is valid as long as the atom lives. If <code>PL_BLOB_UNIQUE</code> 
is also specified, uniqueness is determined by comparing the pointer 
rather than the data pointed at. Using
<code>PL_BLOB_UNIQUE<code><code>|</code></code>PL_BLOB_NOCOPY</code> can 
be used to make a blob reference an arbitrary pointer where the pointer 
data may be reclaimed in the <a class="func" href="foreigninclude.html#release()">release()</a> 
handler.</dd>
<dt><a id="PL_BLOB_WCHAR"><strong>PL_BLOB_WCHAR</strong></a></dt>
<dd class="defbody">
If <code>PL_BLOB_TEXT</code> is also set, then the text is made up of
<code>pl_wchar_t</code> items and the blob's lenght is the number of 
bytes (that is, the number of characters times <code>sizeof(pl_wchar_t)</code>). 
As <code>PL_BLOB_TEXT</code>, this flag should not be set in 
user-defined blobs.
</dd>
</dl>

<p>The <var>name</var> field represents the type name as available to 
Prolog. See also <a id="idx:currentblob2:2546"></a><a class="pred" href="examineprog.html#current_blob/2">current_blob/2</a>. 
The other fields are function pointers that must be initialised to 
proper functions or <code>NULL</code> to get the default behaviour of 
built-in atoms. Below are the defined member functions:

<dl class="latex">
<dt class="pubdef"><a id="acquire()"><var>void</var> <strong>acquire</strong>(<var>atom_t 
a</var>)</a></dt>
<dd class="defbody">
Called if a new blob of this type is created through <a class="func" href="foreigninclude.html#PL_put_blob()">PL_put_blob()</a>,
<a class="func" href="foreigninclude.html#PL_unify_blob()">PL_unify_blob()</a>, 
or <a class="func" href="foreigninclude.html#PL_new_blob()">PL_new_blob()</a>. 
Note this this call is done as part of creating the blob. The call to <a class="func" href="foreigninclude.html#PL_unify_blob()">PL_unify_blob()</a> 
may fail if the unification fails or cannot be completed due to a 
resource error. <a class="func" href="foreigninclude.html#PL_put_blob()">PL_put_blob()</a> 
has no such error conditions. This callback is typically used to store 
the
<code>atom_t</code> handle into the content of the blob. Given a pointer 
to the content, we can now use <a class="func" href="foreigninclude.html#PL_unify_atom()">PL_unify_atom()</a> 
to bind a Prolog term with a reference to the pointed to object. If the 
content of the blob can be modified (<code>PL_BLOB_UNIQUE</code> is not 
present) this is the only way to get access to the <code>atom_t</code> 
handle that belongs to this blob. If
<code>PL_BLOB_UNIQUE</code> is provided and respected, <a class="func" href="foreigninclude.html#PL_unify_blob()">PL_unify_blob()</a> 
given the same pointer and length will produce the same <code>atom_t</code> 
handle.</dd>
<dt class="pubdef"><a id="release()"><var>int</var> <strong>release</strong>(<var>atom_t 
a</var>)</a></dt>
<dd class="defbody">
The blob (atom) <var>a</var> is about to be released. The
<a class="func" href="foreigninclude.html#release()">release()</a> 
function is called when the atom is reclaimed by the atom garbage 
collector, when an explicit call to <a class="func" href="foreigninclude.html#PL_free_blob()">PL_free_blob()</a> 
is made or during shutdown of Prolog. This function can retrieve the 
data of the blob using <a class="func" href="foreigninclude.html#PL_blob_data()">PL_blob_data()</a>. 
If the <a class="func" href="foreigninclude.html#release()">release()</a> 
function returns <code>FALSE</code>, the atom garbage collector will
<em>not</em> reclaim the atom. For critical resources such as file 
handles or significant memory resources, it may be desirable to have an 
explicit call to dispose (most of) the resources. For example,
<a id="idx:close1:2547"></a><a class="pred" href="IO.html#close/1">close/1</a> 
reclaims the file handle and most of the resources associated with a 
stream, leaving only a tiny bit of content to the garbage collector. See 
also <a id="idx:setupcallcleanup3:2548"></a><a class="pred" href="metacall.html#setup_call_cleanup/3">setup_call_cleanup/3</a>.

<p>The <a class="func" href="foreigninclude.html#release()">release()</a> 
callback is called in the context of the thread executing the atom 
garbage collect, the thread executing
<a class="func" href="foreigninclude.html#PL_free_blob()">PL_free_blob()</a> 
or the thread initiating the shutdown. Normally the thread <code>gc</code> 
runs all atom and clause garbage collections. The
<a class="func" href="foreigninclude.html#release()">release()</a> 
function may not call any of the PL_*() functions except for
<a class="func" href="foreigninclude.html#PL_blob_data()">PL_blob_data()</a> 
or <a class="func" href="foreigninclude.html#PL_unregister_atom()">PL_unregister_atom()</a> 
to unregister other atoms that are part data associated to the blob. 
Calling any of the other PL_* functions may result in deadlocks or 
crashes. The <a class="func" href="foreigninclude.html#release()">release()</a> 
function should not call any potentially slow or blocking functions as 
this may cause serious slowdowns in the rest of the system.

<p>Blobs that require cleanup that is slow, blocking or requires calling 
Prolog must pass the data to be cleaned to another thread. Be aware that 
if the blob uses <code>PL_BLOB_NOCOPY</code> the user is responsible for 
discarding the data, otherwise the atom garbage collector will free the 
data.

<p>As SWI-Prolog atom garbage collector is <em>conservative</em>, there 
is no guarantee that the <a class="func" href="foreigninclude.html#release()">release()</a> 
function will ever be called. If it is important to clean up some 
resource, there should be an explicit predicate for doing that, and 
calling that predicate should be guaranteed by using <a id="idx:setupcallcleanup3:2549"></a><a class="pred" href="metacall.html#setup_call_cleanup/3">setup_call_cleanup/3</a> 
or some a process finalization hook such as <a id="idx:athalt1:2550"></a><a class="pred" href="consulting.html#at_halt/1">at_halt/1</a>.

<p>Normally, Prolog does not clean memory during shutdown. It does so on 
an explicit call to <a class="func" href="foreigninclude.html#PL_cleanup()">PL_cleanup()</a>.<sup class="fn">223<span class="fn-text">Or 
if the system is compiled with the <b>cmake</b> <em>build type</em> <code>Debug</code>.</span></sup> 
In such a situation, there is no guarantee of the order in which atoms 
are released; if a blob contains an atom (or another blob), those atoms 
(or blobs) may have already been released. See also
<a class="func" href="foreigninclude.html#PL_blob_data()">PL_blob_data()</a>.</dd>
<dt class="pubdef"><a id="compare()"><var>int</var> <strong>compare</strong>(<var>atom_t 
a, atom_t b</var>)</a></dt>
<dd class="defbody">
Compare the blobs <var>a</var> and <var>b</var>, both of which are of 
the type associated to this blob type. Return values are as <b>memcmp()</b>: <var>&lt; 
0</var> if
<var>a</var> is less than <var>b</var>, <var>= 0</var> if both are 
equal, and <var>&gt; 0</var> otherwise. The default implementation is a 
bitwise comparison of the blobs&rsquo;contents. This default 
implementation suffices if
<code>PL_BLOB_UNIQUE</code> is set and the blob follows the requirement 
that its contents do not change, although it might give an unexpected 
ordering, and the ordering may change if the blob is saved and restored 
using <a id="idx:saveprogram2:2551"></a><span class="pred-ext">save_program/2</span>.

<p>If the <a class="func" href="foreigninclude.html#compare()">compare()</a> 
function is defined, the <a id="idx:sort2:2552"></a><a class="pred" href="builtinlist.html#sort/2">sort/2</a> 
predicate uses that to determine if two blobs are equal and only keeps 
one of them. This can cause unexpected results with blobs that are 
actually different; if you cannot guarantee that the blobs all have 
unique contents, then you should incorporate the blob address (the 
system guarantees that blobs are not shifted in memory after they are 
allocated). This function should not call any PL_*() functions other 
than <a class="func" href="foreigninclude.html#PL_blob_data()">PL_blob_data()</a>.

<p>The following minimal compare function gives a stable total ordering:

<pre class="code">
static int
compare_my_blob(atom_t a, atom_t b)
{ const struct my_blob_data *blob_a = PL_blob_data(a, NULL, NULL);
  const struct my_blob_data *blob_b = PL_blob_data(b, NULL, NULL);
  return (blob_a &lt; blob_b) ? -1 : (blob_a &gt; blob_b) ? 1 : 0;
}
</pre>

</dd>
<dt class="pubdef"><a id="write()"><var>int</var> <strong>write</strong>(<var>IOSTREAM 
*s, atom_t a, int flags</var>)</a></dt>
<dd class="defbody">
Write the content of the blob <var>a</var> to the stream <var>s</var> 
respecting the <var>flags</var>. The return value is <code>TRUE</code> 
or <code>FALSE</code> and does <em>not</em> follow the Unix convention 
of the number of bytes (where zero is possible) and negative for errors. 
Any I/O operations to
<var>s</var> are in the context of a <a class="func" href="foreign-streams.html#PL_acquire_stream()">PL_acquire_stream()</a>; 
upon return, the <a class="func" href="foreign-streams.html#PL_release_stream()">PL_release_stream()</a> 
handles any errors, so it is safe to not check return codes from <a class="func" href="foreign-streams.html#Sfprintf()">Sfprintf()</a>, 
etc.

<p>In general, the output from the <a class="func" href="foreigninclude.html#write()">write()</a> 
callback should be minimal. If you wish to output more debug 
information, it is suggested that you either add a debug option to your 
"open" predicate to output more information, or provide a "properties" 
predicate. A typical implementation is:

<pre class="code">
static int write_my_blob(IOSTREAM *s, atom_t symbol, int flags)
{ (void)flags; /* unused */
  Sfprintf(s, "&lt;my_blob&gt;(%p)", PL_blob_data(symbol, NULL, NULL));
  return TRUE;
}
</pre>

<p>The <var>flags</var> are a bitwise <em>or</em> of zero or more of the
<code>PL_WRT_*</code> flags that were passed in to the calling
<a class="func" href="foreign-streams.html#PL_write_term()">PL_write_term()</a> 
that called <a class="func" href="foreigninclude.html#write()">write()</a>, 
and are defined in
<code>SWI-Prolog.h</code>. The <var>flags</var> do not have the
<code>PL_WRT_NEWLINE</code> bit set, so it is safe to call <a class="func" href="foreign-streams.html#PL_write_term()">PL_write_term()</a> 
and there is no need for writing a trailing newline. This prototype is 
available if the <code>SWI-Stream.h</code> is included <em>before</em>
<code>SWI-Prolog.h</code>. This function can retrieve the data of the 
blob using <a class="func" href="foreigninclude.html#PL_blob_data()">PL_blob_data()</a>.

<p>Most blobs reference some external data identified by a pointer and 
the
<a class="func" href="foreigninclude.html#write()">write()</a> function 
writes
<code>&lt;</code><var>type</var><code>&gt;(</code><var>address</var><code>)</code>. 
If this function is not provided, <a id="idx:write1:2553"></a><a class="pred" href="termrw.html#write/1">write/1</a> 
emits the content of the blob for blobs of type
<code>PL_BLOB_TEXT</code> or a string of the format <code>&lt;#</code><i>hex 
data</i><code>&gt;</code> for binary blobs.
</dd>
</dl>

<dl class="latex">
<dt class="pubdef"><a id="save()"><var>int</var> <strong>save</strong>(<var>atom_t 
a, IOSTREAM *s</var>)</a></dt>
<dd class="defbody">
Write the blob to stream <var>s</var>, in an opaque form that is known 
only to the blob. If a &ldquo;save&rdquo; function is not provided (that 
is, the field is <code>NULL</code>), the default implementation saves 
and restores the blob as if it is an array of bytes which may contain 
null (<code>&rsquo;<br>
0&rsquo;</code>) bytes.

<p><code>SWI-Stream.h</code> defines a number of PL_qlf_put_*() 
functions that write data in a machine-independent form that can be read 
by the corresponding PL_qlf_get_*() functions.

<p>If the &ldquo;save&rdquo; function encounters an error, it should 
call
<a class="func" href="foreigninclude.html#PL_warning()">PL_warning()</a>, 
raise an exception (see <a class="func" href="foreigninclude.html#PL_raise_exception()">PL_raise_exception()</a>), 
and return <code>FALSE</code>.<sup class="fn">224<span class="fn-text">Details 
are subject to change.</span></sup> Note that failure to save/restore a 
blob makes it impossible to compile a file that contains such a blob 
using <a id="idx:qcompile2:2554"></a><a class="pred" href="consulting.html#qcompile/2">qcompile/2</a> 
as well as creating a
<em>saved state</em> from a program that contains such a blob 
impossible. Here, <em>contains</em> means that the blob appears in a 
clause or directive.</dd>
<dt class="pubdef"><a id="load()"><var>atom_t</var> <strong>load</strong>(<var>IOSTREAM 
*s</var>)</a></dt>
<dd class="defbody">
Read the blob from its saved form as written by the &ldquo;save&rdquo; function 
of the same blob type. If this cannot be done (e.g., a stream read 
failure or a corrupted external form), the &ldquo;load&rdquo; function 
should call <a class="func" href="foreigninclude.html#PL_warning()">PL_warning()</a>, 
then <a class="func" href="foreigninclude.html#PL_fatal_error()">PL_fatal_error()</a>, 
and return constFALSE.<sup class="fn">225<span class="fn-text">Details 
are subject to change; see the &ldquo;save&rdquo; function.</span></sup> 
If a &ldquo;load&rdquo; function is not provided (that is, the field is <code>NULL</code>, 
the default implementation assumes that the blob was written by the 
default &ldquo;save&rdquo; - that is, as an array of bytes

<p><code>SWI-Stream.h</code> defines a number of PL_qlf_get_*() 
functions that read data in a machine-independent form, as written by 
the by the corresponding PL_qlf_put_*() functions.

<p>The atom that the &ldquo;load&rdquo; function returns can be created 
using
<a class="func" href="foreigninclude.html#PL_new_blob()">PL_new_blob()</a>.</dd>
<dt class="pubdef"><a id="PL_unregister_blob_type()"><var>int</var> <strong>PL_unregister_blob_type</strong>(<var>PL_blob_t 
*type</var>)</a></dt>
<dd class="defbody">
Unlink the blob type from the registered type and transform the type of 
possible living blobs to <code>unregistered</code>, avoiding further 
reference to the type structure, functions referred by it, as well as 
the data. This function returns <code>TRUE</code> if no blobs of this 
type existed and <code>FALSE</code> otherwise. <a class="func" href="foreigninclude.html#PL_unregister_blob_type()">PL_unregister_blob_type()</a> 
is intended for the <b>uninstall()</b> hook of foreign modules, avoiding 
further references to the module.</dd>
<dt class="pubdef"><a id="PL_register_blob_type()"><var>int</var> <strong>PL_register_blob_type</strong>(<var>PL_blob_t 
*type</var>)</a></dt>
<dd class="defbody">
This function does not need to be called explicitly. It is called if 
needed when a blob is created by <a class="func" href="foreigninclude.html#PL_unify_blob()">PL_unify_blob()</a>, <a class="func" href="foreigninclude.html#PL_put_blob()">PL_put_blob()</a>, 
or
<a class="func" href="foreigninclude.html#PL_new_blob()">PL_new_blob()</a>.
</dd>
</dl>

<p><h4 id="sec:blobaccess"><a id="sec:12.4.10.2"><span class="sec-nr">12.4.10.2</span> <span class="sec-title">Accessing 
blobs</span></a></h4>

<a id="sec:blobaccess"></a>

<p>The blob access functions are similar to the atom accessing 
functions. Blobs being atoms, the atom functions operate on blobs and 
vice versa. For clarity and possible future compatibility issues, 
however, it is not advised to rely on this.

<dl class="latex">
<dt class="pubdef"><a id="PL_is_blob()"><var>int</var> <strong>PL_is_blob</strong>(<var>term_t 
t, PL_blob_t **type</var>)</a></dt>
<dd class="defbody">
Succeeds if <var>t</var> refers to a blob, in which case <var>type</var> 
is filled with the type of the blob.</dd>
<dt class="pubdef"><a id="PL_unify_blob()"><var>int</var> <strong>PL_unify_blob</strong>(<var>term_t 
t, void *blob, size_t len, PL_blob_t *type</var>)</a></dt>
<dd class="defbody">
Unify <var>t</var> to a blob constructed from the given data and 
associated with the given type. This performs the following steps:

<p>
<ol class="latex">
<li>If the <var>type</var> has <code>PL_BLOB_UNIQUE</code> set, search 
the blob database for a blob of the same type with the same content. If 
found, unify <var>t</var> with the existing handle.
<li>If not found or <code>PL_BLOB_UNIQUE</code> is not set, create a new 
blob handle. If <code>PL_BLOB_NOCOPY</code> is set, associate it to the 
given memory; else, copy the memory to a new area owned by the blob. 
Call the <a class="func" href="foreigninclude.html#acquire()">acquire()</a> 
function of the <var>type</var>.
<li>Unify <var>t</var> with the existing or new handle. This succeeds if <var>t</var> 
is already bound to the existing blob handle. If
<var>t</var> is a variable, it succeeds <em>if</em> sufficient resources 
are available to perform the unification; if <var>t</var> is bound to 
something else, this fails.
</ol>

<p>It is possible that a blob referencing critial resources is created 
after which the unification fails. Typically these resources are 
eventually reclaimed because the new blob is not referenced and 
reclaimed by the atom garbage collector. As described with the
<a class="func" href="foreigninclude.html#release()">release()</a> 
function, it can be desirable to reclaim the critical resources after 
the failing <a class="func" href="foreigninclude.html#PL_unify_blob()">PL_unify_blob()</a> 
call.</dd>
<dt class="pubdef"><a id="PL_put_blob()"><var>int</var> <strong>PL_put_blob</strong>(<var>term_t 
t, void *blob, size_t len, PL_blob_t *type</var>)</a></dt>
<dd class="defbody">
Store the described blob in <var>t</var>. The return value indicates 
whether a new blob was allocated (<code>FALSE</code>) or the blob is a 
reference to an existing blob (<code>TRUE</code>). Reporting 
new/existing can be used to deal with external objects having their own 
reference counts. If the return is <code>TRUE</code> this reference 
count must be incremented, and it must be decremented on blob 
destruction callback. See also
<a class="func" href="foreigninclude.html#PL_put_atom_nchars()">PL_put_atom_nchars()</a>.</dd>
<dt class="pubdef"><a id="PL_new_blob()"><var>atom_t</var> <strong>PL_new_blob</strong>(<var>void 
*blob, size_t len, PL_blob_t *type</var>)</a></dt>
<dd class="defbody">
Create a blob from its internal opaque form. This function is intended 
for the &ldquo;load&rdquo; function of a blob.</dd>
<dt class="pubdef"><a id="PL_get_blob()"><var>int</var> <strong>PL_get_blob</strong>(<var>term_t 
t, void **blob, size_t *len, PL_blob_t **type</var>)</a></dt>
<dd class="defbody">
If <var>t</var> holds a blob or atom, get the data and type and return
<code>TRUE</code>. Otherwise return <code>FALSE</code>. Each result 
pointer may be <code>NULL</code>, in which case the requested 
information is ignored.</dd>
<dt class="pubdef"><a id="PL_blob_data()"><var>void *</var> <strong>PL_blob_data</strong>(<var>atom_t 
a, size_t *len, PL_blob_t **type</var>)</a></dt>
<dd class="defbody">
Get the data and type associated to a blob. This function is mainly used 
from the callback functions described in <a class="sec" href="foreigninclude.html#sec:12.4.10.1">section 
12.4.10.1</a>. Note that if the <a class="func" href="foreigninclude.html#release()">release()</a> 
hook is called from <a class="func" href="foreigninclude.html#PL_cleanup()">PL_cleanup()</a>, 
blobs are released regardless of whether or not they are referenced and 
the order in which blobs are released is undefined (the order depends on 
the ordering in the atom hash table). <a class="func" href="foreigninclude.html#PL_blob_data()">PL_blob_data()</a> 
may be called safely on a blob that has already been released. If this 
happens during <a class="func" href="foreigninclude.html#PL_cleanup()">PL_cleanup()</a> 
the return value is guaranteed to be <code>NULL</code>. During normal 
execution it may return the content of a newly allocated blob that 
reuses the released handle.</dd>
<dt class="pubdef"><a id="PL_free_blob()"><var>int</var> <strong>PL_free_blob</strong>(<var>atom_t 
blob</var>)</a></dt>
<dd class="defbody">
New in 9.1.12. This function may be used on blobs with the
<code>PL_BLOB_NOCOPY</code> flag set and the blob type implements the
<a class="func" href="foreigninclude.html#release()">release()</a> 
callback. It causes the <a class="func" href="foreigninclude.html#release()">release()</a> 
callback to be called, after which the data and size are set to 0 if the <a class="func" href="foreigninclude.html#release()">release()</a> 
returns <code>TRUE</code>. After this sequence, the <a class="func" href="foreigninclude.html#release()">release()</a> 
for this blob is never called again. The related <code>atom_t</code> 
handle remains valid until it is no longer referenced and reclaimed by 
the atom garbage collector. If the blob data is accessed using e.g., <a class="func" href="foreigninclude.html#PL_get_blob()">PL_get_blob()</a> 
it returns <code>NULL</code> for the data and 0 for the size.<sup class="fn">226<span class="fn-text">This 
means that any predicates or callbacks that use the blob must check the 
result of <a class="func" href="foreigninclude.html#PL_blob_data()">PL_blob_data()</a>.</span></sup> 
If the <a class="func" href="foreigninclude.html#release()">release()</a> 
function is not called, or if it returns <code>FALSE</code>, <code>FALSE</code> 
is returned.

<p><a class="func" href="foreigninclude.html#PL_free_blob()">PL_free_blob()</a> 
may be called multiple times on the same
<code>atom_t</code>, provided the handle is still valid. Subsequent 
calls after a successful call have no effect and return <code>FALSE</code>.
</dd>
</dl>

<p><h4 id="sec:blob-non-c"><a id="sec:12.4.10.3"><span class="sec-nr">12.4.10.3</span> <span class="sec-title">Considerations 
for non-C code</span></a></h4>

<a id="sec:blob-non-c"></a>

<p>The blob API assumes that Prolog will take care of memory management, 
using the <a class="func" href="foreigninclude.html#release()">release(c)</a>allback 
to handle any cleanup.

<p>Other programming languages have their own memory management, which 
might not fit nicely with the Prolog memory management. For more details 
on blobs written with C++, see
<a class="url" href="https://www.swi-prolog.org/pldoc/man?section=cpp2">C++ 
interface to SWI-Prolog (Version 2)</a>.

<p><h3 id="sec:gmpforeign"><a id="sec:12.4.11"><span class="sec-nr">12.4.11</span> <span class="sec-title">Exchanging 
GMP numbers</span></a></h3>

<a id="sec:gmpforeign"></a>

<p>If SWI-Prolog is linked with the GNU Multiple Precision Arithmetic 
Library (GMP, used by default), the foreign interface provides functions 
for exchanging numeric values to GMP types. To access these functions 
the header <code>&lt;gmp.h&gt;</code> must be included <em>before</em>
<code>&lt;SWI-Prolog.h&gt;</code>. Foreign code using GMP linked to 
SWI-Prolog asks for some considerations.

<p>
<ul class="latex">
<li>SWI-Prolog normally rebinds the GMP allocation functions using
<b>mp_set_memory_functions()</b>. This means SWI-Prolog must be 
initialised before the foreign code touches any GMP function. You can 
call
<code>PL_action(PL_GMP_SET_ALLOC_FUNCTIONS, TRUE)</code> to force 
Prolog's GMP initialization without doing the rest of the Prolog 
initialization. If you do not want Prolog rebinding the GMP allocation, 
call <code>PL_action(PL_GMP_SET_ALLOC_FUNCTIONS, FALSE)</code>
<em>before</em> initializing Prolog.

<p>
<li>On Windows, each DLL has its own memory pool. To make exchange of 
GMP numbers between Prolog and foreign code possible you must either let 
Prolog rebind the allocation functions (default) or you must recompile 
SWI-Prolog to link to a DLL version of the GMP library.
</ul>

<p>Here is an example exploiting the function <b>mpz_nextprime()</b>:

<pre class="code">
#include &lt;gmp.h&gt;
#include &lt;SWI-Prolog.h&gt;

static foreign_t
next_prime(term_t n, term_t prime)
{ mpz_t mpz;
  int rc;

  mpz_init(mpz);
  if ( PL_get_mpz(n, mpz) )
  { mpz_nextprime(mpz, mpz);

    rc = PL_unify_mpz(prime, mpz);
  } else
    rc = FALSE;

  mpz_clear(mpz);
  return rc;
}

install_t
install()
{ PL_register_foreign("next_prime", 2, next_prime, 0);
}
</pre>

<dl class="latex">
<dt class="pubdef"><a id="PL_get_mpz()"><var>int</var> <strong>PL_get_mpz</strong>(<var>term_t 
t, mpz_t mpz</var>)</a></dt>
<dd class="defbody">
If <var>t</var> represents an integer, <var>mpz</var> is filled with the 
value and the function returns <code>TRUE</code>. Otherwise <var>mpz</var> 
is untouched and the function returns <code>FALSE</code>. Note that <var>mpz</var> 
must have been initialised before calling this function and must be 
cleared using
<b>mpz_clear()</b> to reclaim any storage associated with it.</dd>
<dt class="pubdef"><a id="PL_get_mpq()"><var>int</var> <strong>PL_get_mpq</strong>(<var>term_t 
t, mpq_t mpq</var>)</a></dt>
<dd class="defbody">
If <var>t</var> is an integer or rational number (term <code>rdiv/2</code>),
<var>mpq</var> is filled with the <em>normalised</em> rational number 
and the function returns <code>TRUE</code>. Otherwise <var>mpq</var> is 
untouched and the function returns <code>FALSE</code>. Note that <var>mpq</var> 
must have been initialised before calling this function and must be 
cleared using
<b>mpq_clear()</b> to reclaim any storage associated with it.</dd>
<dt class="pubdef"><a id="PL_unify_mpz()"><var>int</var> <strong>PL_unify_mpz</strong>(<var>term_t 
t, mpz_t mpz</var>)</a></dt>
<dd class="defbody">
Unify <var>t</var> with the integer value represented by <var>mpz</var> 
and return
<code>TRUE</code> on success. The <var>mpz</var> argument is not 
changed.</dd>
<dt class="pubdef"><a id="PL_unify_mpq()"><var>int</var> <strong>PL_unify_mpq</strong>(<var>term_t 
t, mpq_t mpq</var>)</a></dt>
<dd class="defbody">
Unify <var>t</var> with a rational number represented by <var>mpq</var> 
and return
<code>TRUE</code> on success. Note that <var>t</var> is unified with an 
integer if the denominator is 1. The <var>mpq</var> argument is not 
changed.
</dd>
</dl>

<p><h3 id="sec:calling-prolog-from-c"><a id="sec:12.4.12"><span class="sec-nr">12.4.12</span> <span class="sec-title">Calling 
Prolog from C</span></a></h3>

<a id="sec:calling-prolog-from-c"></a>

<p>The Prolog engine can be called from C. There are two interfaces for 
this. For the first, a term is created that could be used as an argument 
to <a id="idx:call1:2555"></a><a class="pred" href="metacall.html#call/1">call/1</a>, 
and then <a class="func" href="foreigninclude.html#PL_call()">PL_call()</a> 
is used to call Prolog. This system is simple, but does not allow to 
inspect the different answers to a non-deterministic goal and is 
relatively slow as the runtime system needs to find the predicate. The 
other interface is based on
<a class="func" href="foreigninclude.html#PL_open_query()">PL_open_query()</a>, <a class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</a>, 
and <a class="func" href="foreigninclude.html#PL_cut_query()">PL_cut_query()</a> 
or
<a class="func" href="foreigninclude.html#PL_close_query()">PL_close_query()</a>. 
This mechanism is more powerful, but also more complicated to use.

<p><h4 id="sec:foreign-predicate-handle"><a id="sec:12.4.12.1"><span class="sec-nr">12.4.12.1</span> <span class="sec-title">Predicate 
references</span></a></h4>

<a id="sec:foreign-predicate-handle"></a>

<p>This section discusses the functions used to communicate about 
predicates. Though a Prolog predicate may be defined or not, redefined, 
etc., a Prolog predicate has a handle that is neither destroyed nor 
moved. This handle is known by the type <code>predicate_t</code>.

<dl class="latex">
<dt class="pubdef"><a id="PL_pred()"><var>predicate_t</var> <strong>PL_pred</strong>(<var>functor_t 
f, module_t m</var>)</a></dt>
<dd class="defbody">
Return a handle to a predicate for the specified name/arity in the given 
module. If the module argument <var>m</var> is <code>NULL</code>, the 
current context module is used. If the target predicate does not exist a 
handle to a new <i>undefined</i> predicate is returned. The predicate 
may fail, returning <code>(predicate_t)0</code> after setting a resource 
exception, if the target module has a limit on the
<code>program_space</code>, see <a id="idx:setmodule1:2556"></a><a class="pred" href="manipmodule.html#set_module/1">set_module/1</a>. 
Currently aborts the process with a <em>fatal error</em> when out of 
memory. Future versions may raise a resource exception and return <code>(predicate_t)0</code>.</dd>
<dt class="pubdef"><a id="PL_predicate()"><var>predicate_t</var> <strong>PL_predicate</strong>(<var>const 
char *name, int arity, const char* module</var>)</a></dt>
<dd class="defbody">
Same as <a class="func" href="foreigninclude.html#PL_pred()">PL_pred()</a>, 
but provides a more convenient interface to the C programmer. If the 
module argument <var>module</var> is <code>NULL</code>, the current 
context module is used. The <code>predicate_t</code> handle may be 
stored as global data and reused for future queries<sup class="fn">227<span class="fn-text"><a class="func" href="foreigninclude.html#PL_predicate()">PL_predicate()</a> 
involves 5 hash lookups (two to get the atoms, one to get the module, 
one to get the functor and the final one to get the predicate associated 
with the functor in the module)</span></sup> as illustrated below.

<pre class="code">
static predicate_t p = 0;

  ...
  if ( !p )
    p = PL_predicate("is_a", 2, "database");
</pre>

<p>Note that <a class="func" href="foreigninclude.html#PL_cleanup()">PL_cleanup()</a> 
invalidates the predicate handle. Foreign libraries that use the above 
mechanism must implement the module
<b>uninstall()</b> function to clear the <code>predicate_t</code> global 
variable.</dd>
<dt class="pubdef"><a id="PL_predicate_info()"><var>int</var> <strong>PL_predicate_info</strong>(<var>predicate_t 
p, atom_t *n, size_t *a, module_t *m</var>)</a></dt>
<dd class="defbody">
Return information on the predicate <var>p</var>. The name is stored 
over
<var>n</var>, the arity over <var>a</var>, while <var>m</var> receives 
the definition module. Note that the latter need not be the same as 
specified with
<a class="func" href="foreigninclude.html#PL_predicate()">PL_predicate()</a>. 
If the predicate is imported into the module given to
<a class="func" href="foreigninclude.html#PL_predicate()">PL_predicate()</a>, 
this function will return the module where the predicate is defined. Any 
of the arguments <var>n</var>, <var>a</var> and <var>m</var> can be
<code>NULL</code>. Currently always returns <code>TRUE</code>.
</dd>
</dl>

<p><h4 id="sec:foreign-create-query"><a id="sec:12.4.12.2"><span class="sec-nr">12.4.12.2</span> <span class="sec-title">Initiating 
a query from C</span></a></h4>

<a id="sec:foreign-create-query"></a>

<p>This section discusses the functions for creating and manipulating 
queries from C. Note that a foreign context can have at most one active 
query. This implies that it is allowed to make strictly nested calls 
between C and Prolog (Prolog calls C, calls Prolog, calls C, etc.), but 
it is <strong>not</strong> allowed to open multiple queries and start 
generating solutions for each of them by calling <a class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</a>. 
Be sure to call <a class="func" href="foreigninclude.html#PL_cut_query()">PL_cut_query()</a> 
or <a class="func" href="foreigninclude.html#PL_close_query()">PL_close_query()</a> 
on any query you opened before opening the next or returning control 
back to Prolog. Failure to do so results in "undefined behavior" 
(typically, a crash).

<dl class="latex">
<dt class="pubdef"><a id="PL_open_query()"><var>qid_t</var> <strong>PL_open_query</strong>(<var>module_t 
ctx, int flags, predicate_t p, term_t +t0</var>)</a></dt>
<dd class="defbody">

<p>Opens a query and returns an identifier for it. <var>ctx</var> is the <em>context 
module</em> of the goal. When <code>NULL</code>, the context module of 
the calling context will be used, or <code>user</code> if there is no 
calling context (as may happen in embedded systems). Note that the 
context module only matters for <em>meta-predicates</em>. See <a id="idx:metapredicate1:2557"></a><a class="pred" href="metapred.html#meta_predicate/1">meta_predicate/1</a>,
<a id="idx:contextmodule1:2558"></a><a class="pred" href="ctxmodule.html#context_module/1">context_module/1</a> 
and <a id="idx:moduletransparent1:2559"></a><a class="pred" href="ctxmodule.html#module_transparent/1">module_transparent/1</a>. 
The term reference <var>t0</var> is the first of a vector of term 
references as returned by
<a class="func" href="foreigntypes.html#PL_new_term_refs()">PL_new_term_refs(n)</a>. 
Raise a resource exception and returns
<code>(qid_t)0</code> on failure.

<p>Every use of <a class="func" href="foreigninclude.html#PL_open_query()">PL_open_query()</a> 
must have a corresponding call to
<a class="func" href="foreigninclude.html#PL_cut_query()">PL_cut_query()</a> 
or <a class="func" href="foreigninclude.html#PL_close_query()">PL_close_query()</a> 
before the foreign predicate returns either <code>TRUE</code> or <code>FALSE</code>.

<p>The <var>flags</var> arguments provides some additional options 
concerning debugging and exception handling. It is a bitwise <em>or</em> 
of the following values below. Note that exception propagation is 
defined by the flags <code>PL_Q_NORMAL</code>, <code>PL_Q_CATCH_EXCEPTION</code> 
and
<code>PL_Q_PASS_EXCEPTION</code>. Exactly one of these flags must be 
specified (if none of them is specified, the behavior is as if
<code>PL_Q_NODEBUG</code> is specified)..

<dl class="latex">
<dt><b><code>PL_Q_NORMAL</code></b></dt>
<dd class="defbody">
Normal operation. It is named "normal" because it makes a call to Prolog 
behave as it did before exceptions were implemented, i.e., an error (now 
uncaught exception) triggers the debugger. See also the Prolog flag <a class="flag" href="flags.html#flag:debug_on_error">debug_on_error</a>. 
This mode is still useful when calling Prolog from C if the C code is 
not willing to handle exceptions.</dd>
<dt><b><code>PL_Q_NODEBUG</code></b></dt>
<dd class="defbody">
Switch off the debugger while executing the goal. This option is used by 
many calls to hook-predicates to avoid tracing the hooks. An example is <a id="idx:print1:2560"></a><a class="pred" href="termrw.html#print/1">print/1</a> 
calling <a id="idx:portray1:2561"></a><a class="pred" href="termrw.html#portray/1">portray/1</a> 
from foreign code. This is the default if flags is <code>0</code>.</dd>
<dt><b><code>PL_Q_CATCH_EXCEPTION</code></b></dt>
<dd class="defbody">
If an exception is raised while executing the goal, make it available by 
calling <code><a class="func" href="foreigninclude.html#PL_exception()">PL_exception(qid)</a></code>, 
where <code>qid</code> is the <code>qid_t</code> returned by <a class="func" href="foreigninclude.html#PL_open_query()">PL_open_query()</a>. 
The exception is implicitly cleared from the environment when the query 
is closed and the exception term returned from <code><a class="func" href="foreigninclude.html#PL_exception()">PL_exception(qid)</a></code> 
becomes invalid. Use
<code>PL_Q_PASS_EXCEPTION</code> if you wish to propagate the exception.</dd>
<dt><b><code>PL_Q_PASS_EXCEPTION</code></b></dt>
<dd class="defbody">
As <code>PL_Q_CATCH_EXCEPTION</code>, making the exception on the inner 
environment available using <code><a class="func" href="foreigninclude.html#PL_exception()">PL_exception(0)</a></code> 
in the parent environment. If <a class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</a> 
returns <code>FALSE</code>, you must call
<a class="func" href="foreigninclude.html#PL_cut_query()">PL_cut_query()</a> 
or <a class="func" href="foreigninclude.html#PL_close_query()">PL_close_query()</a>. 
After that you may verify whether failure was due to logical failure of 
the called predicate or an exception by calling <code><a class="func" href="foreigninclude.html#PL_exception()">PL_exception(0)</a></code>. 
If the predicate failed due to an exception you should return with <code>FALSE</code> 
from the foreign predicate or call <a class="func" href="foreigninclude.html#PL_clear_exception()">PL_clear_exception()</a> 
to clear it. If you wish to process the exception in C, it is advised to 
use <code>PL_Q_CATCH_EXCEPTION</code> instead, but only if you have no 
need to raise an exception or re-raise the caught exception.

<p>Note that <code>PL_Q_PASS_EXCEPTION</code> is used by the debugger to 
decide whether the exception is <em>caught</em>. If there is no matching
<a id="idx:catch3:2562"></a><a class="pred" href="exception.html#catch/3">catch/3</a> 
call in the current query and the query was started using
<code>PL_Q_PASS_EXCEPTION</code> the debugger searches the parent 
queries until it either finds a matching <a id="idx:catch3:2563"></a><a class="pred" href="exception.html#catch/3">catch/3</a>, 
a query with
<code>PL_Q_CATCH_EXCEPTION</code> (in which case it considers the 
exception handled by C) or the top of the query stack (in which case it 
considers the exception <em>uncaught</em>). Uncaught exceptions use the
<code>library(library(prolog_stack))</code> to add a backtrace to the 
exception and start the debugger as soon as possible if the Prolog flag
<a class="flag" href="flags.html#flag:debug_on_error">debug_on_error</a> 
is <code>true</code>.</dd>
<dt><b><code>PL_Q_ALLOW_YIELD</code></b></dt>
<dd class="defbody">
Support the <code>I_YIELD</code> instruction for engine-based 
coroutining. See $engine_yield/2 in <code>boot/init.pl</code> for 
details.</dd>
<dt><b><code>PL_Q_EXT_STATUS</code></b></dt>
<dd class="defbody">
Make <a class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</a> 
return extended status. Instead of only
<code>TRUE</code> or <code>FALSE</code> extended status as illustrated 
in the following table:

<p><table class="latex frame-void center">
<tr><td><b>Extended</b></td><td><b>Normal</b></td><td></td></tr>
<tr class="hline"><td>PL_S_EXCEPTION</td><td>FALSE</td><td>Exception 
available through <a class="func" href="foreigninclude.html#PL_exception()">PL_exception()</a> </td></tr>
<tr><td>PL_S_FALSE</td><td>FALSE</td><td>Query failed </td></tr>
<tr><td>PL_S_TRUE</td><td>TRUE</td><td>Query succeeded with choicepoint </td></tr>
<tr><td>PL_S_LAST</td><td>TRUE</td><td>Query succeeded without 
choicepoint </td></tr>
</table>
</dd>
</dl>

<p><a class="func" href="foreigninclude.html#PL_open_query()">PL_open_query()</a> 
can return the query identifier <code>0</code> if there is not enough 
space on the environment stack (and makes the exception available 
through <code><a class="func" href="foreigninclude.html#PL_exception()">PL_exception(0)</a></code>). 
This function succeeds, even if the referenced predicate is not defined. 
In this case, running the query using <a class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</a> 
may return an existence_error. See
<a class="func" href="foreigninclude.html#PL_exception()">PL_exception()</a>.

<p>The example below opens a query to the predicate is_a/2 to find the 
ancestor of&lsquo;me&rsquo;. The reference to the predicate is valid for 
the duration of the process or until <a class="func" href="foreigninclude.html#PL_cleanup()">PL_cleanup()</a> 
is called (see
<a class="func" href="foreigninclude.html#PL_predicate()">PL_predicate()</a> 
for details) and may be cached by the client.

<pre class="code">
char *
ancestor(const char *me)
{ term_t a0 = PL_new_term_refs(2);
  static predicate_t p;

  if ( !p )
    p = PL_predicate("is_a", 2, "database");

  PL_put_atom_chars(a0, me);
  PL_open_query(NULL, PL_Q_PASS_EXCEPTION, p, a0);
  ...
}
</pre>

</dd>
<dt class="pubdef"><a id="PL_next_solution()"><var>int</var> <strong>PL_next_solution</strong>(<var>qid_t 
qid</var>)</a></dt>
<dd class="defbody">
Generate the first (next) solution for the given query. The return value 
is <code>TRUE</code> if a solution was found, or <code>FALSE</code> to 
indicate the query could not be proven. This function may be called 
repeatedly until it fails to generate all solutions to the query. The 
return value
<code>PL_S_NOT_INNER</code> is returned if <var>qid</var> is not the 
innermost query.

<p>If the <a class="func" href="foreigninclude.html#PL_open_query()">PL_open_query()</a> 
had the flag <code>PL_Q_EXT_STATUS</code>, there are additional return 
values (see <a class="sec" href="foreigninclude.html#sec:12.4.1.2">section 
12.4.1.2</a>).</dd>
<dt class="pubdef"><a id="PL_cut_query()"><var>int</var> <strong>PL_cut_query</strong>(<var>qid_t 
qid</var>)</a></dt>
<dd class="defbody">
Discards the query, but does not delete any of the data created by the 
query. It just invalidates <var>qid</var>, allowing for a new call to
<a class="func" href="foreigninclude.html#PL_open_query()">PL_open_query()</a> 
in this context. <a class="func" href="foreigninclude.html#PL_cut_query()">PL_cut_query()</a> 
may invoke cleanup handlers (see <a id="idx:setupcallcleanup3:2564"></a><a class="pred" href="metacall.html#setup_call_cleanup/3">setup_call_cleanup/3</a>) 
and therefore may experience exceptions. If an exception occurs the 
return value is <code>FALSE</code> and the exception is accessible 
through <code><a class="func" href="foreigninclude.html#PL_exception()">PL_exception(0)</a></code>.

<p>An example of a handler that can trigger an exception in
<a class="func" href="foreigninclude.html#PL_cut_query()">PL_cut_query()</a> 
is:

<pre class="code">
test_setup_call_cleanup(X) :-
    setup_call_cleanup(
        true,
        between(1, 5, X),
        throw(error)).
</pre>

<p>where <a class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</a> 
returns <code>TRUE</code> on the first result and the <code>throw(error)</code> 
will only run when <a class="func" href="foreigninclude.html#PL_cut_query()">PL_cut_query()</a> 
or
<a class="func" href="foreigninclude.html#PL_close_query()">PL_close_query()</a> 
is run. On the other hand, if the goal in
<a id="idx:setupcallcleanup3:2565"></a><a class="pred" href="metacall.html#setup_call_cleanup/3">setup_call_cleanup/3</a> 
has completed (failure, exception, determinitic success), the cleanup 
handler will have done its work before control gets back to Prolog and 
therefore <a class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</a> 
will have generated the exception. The return value <code>PL_S_NOT_INNER</code> 
is returned if <var>qid</var> is not the innermost query.</dd>
<dt class="pubdef"><a id="PL_close_query()"><var>int</var> <strong>PL_close_query</strong>(<var>qid_t 
qid</var>)</a></dt>
<dd class="defbody">
As <a class="func" href="foreigninclude.html#PL_cut_query()">PL_cut_query()</a>, 
but all data and bindings created by the query are destroyed as if the 
query is called as <code>\+ \+ Goal</code>. This reduces the need for 
garbage collection, but also rewinds side effects such as setting global 
variables using <a id="idx:bsetval2:2566"></a><a class="pred" href="gvar.html#b_setval/2">b_setval/2</a>. 
The return value
<code>PL_S_NOT_INNER</code> is returned if <var>qid</var> is not the 
innermost query.</dd>
<dt class="pubdef"><a id="PL_current_query()"><var>qid_t</var> <strong>PL_current_query</strong>(<var>void</var>)</a></dt>
<dd class="defbody">
Returns the query id of the current query or <code>0</code> if the 
current thread is not executing any queries.</dd>
<dt class="pubdef"><a id="PL_query_engine()"><var>PL_engine_t</var> <strong>PL_query_engine</strong>(<var>qid_t 
qid</var>)</a></dt>
<dd class="defbody">
Return the engine to which <var>qid</var> belongs. Note that interacting 
with a query or the Prolog terms associated with a query requires the 
engine to be <em>current</em>. See <a class="func" href="foreignthread.html#PL_set_engine()">PL_set_engine()</a>.</dd>
<dt class="pubdef"><a id="PL_call_predicate()"><var>int</var> <strong>PL_call_predicate</strong>(<var>module_t 
m, int flags, predicate_t pred, term_t +t0</var>)</a></dt>
<dd class="defbody">
Shorthand for <a class="func" href="foreigninclude.html#PL_open_query()">PL_open_query()</a>, <a class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</a>, <a class="func" href="foreigninclude.html#PL_cut_query()">PL_cut_query()</a>, 
generating a single solution. The arguments are the same as for
<a class="func" href="foreigninclude.html#PL_open_query()">PL_open_query()</a>, 
the return value is the same as <a class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</a>.</dd>
<dt class="pubdef"><a id="PL_call()"><var>int</var> <strong>PL_call</strong>(<var>term_t 
t, module_t m</var>)</a></dt>
<dd class="defbody">
Call term <var>t</var> just like the Prolog predicate <a id="idx:once1:2567"></a><a class="pred" href="metacall.html#once/1">once/1</a>. <var>t</var> 
is called in the module <var>m</var>, or in the context module if <var>m</var> 
== NULL. Returns <code>TRUE</code> if the call succeeds, <code>FALSE</code> 
otherwise. If the goal raises an exception the return value is
<code>FALSE</code> and the exception term is available using
<a class="func" href="foreigninclude.html#PL_exception()">PL_exception(0)</a>.<sup class="fn">228<span class="fn-text">Up 
to version 9.1.11 the debugger was started and the exception was not 
propagated.</span></sup>
<a class="fig" href="foreigninclude.html#fig:calling">Figure 7</a> shows 
an example to obtain the number of defined atoms.
</dd>
</dl>

<p><h3 id="sec:foreign-discard-term-t"><a id="sec:12.4.13"><span class="sec-nr">12.4.13</span> <span class="sec-title">Discarding 
Data</span></a></h3>

<a id="sec:foreign-discard-term-t"></a>

<p>The Prolog data created and term references needed to set up the call 
and/or analyse the result can in most cases be discarded right after the 
call. <a class="func" href="foreigninclude.html#PL_close_query()">PL_close_query()</a> 
allows for destroying the data, while leaving the term references. The 
calls below may be used to destroy term references and data. See <a class="fig" href="foreigninclude.html#fig:calling">figure 
7</a> for an example.

<dl class="latex">
<dt class="pubdef"><a id="PL_open_foreign_frame()"><var>fid_t</var> <strong>PL_open_foreign_frame</strong>(<var></var>)</a></dt>
<dd class="defbody">
Create a foreign frame, holding a mark that allows the system to undo 
bindings and destroy data created after it, as well as providing the 
environment for creating term references. Each call to a foreign 
predicate is wrapped in a <a class="func" href="foreigninclude.html#PL_open_foreign_frame()">PL_open_foreign_frame()</a> 
and
<a class="func" href="foreigninclude.html#PL_close_foreign_frame()">PL_close_foreign_frame()</a> 
pair. This ensures that <code>term_t</code> handles created during the 
execution of a foreign predicate are scoped to this execution. Note that 
if the foreign predicate is
<em>non-deterministic</em>, <code>term_t</code> handles are scoped to
<em>each</em> activation of the foreign function.

<p>The user may create explicit foreign frames to undo (backtrack) 
changes to Prolog terms. See <a class="func" href="foreigninclude.html#PL_unify()">PL_unify()</a> 
for an example. An explicit foreign frame must also be used for creating 
a callback from C to Prolog (see <a class="func" href="foreigninclude.html#PL_open_query()">PL_open_query()</a>) 
to ensure the existence of such a frame and to scope the <code>term_t</code> 
handles needed to setup the call to Prolog.

<p>On success, the stack has room for at least 10 <code>term_t</code> 
handles. This implies that foreign predicates as well as code inside an 
explicitly created foreign frame may use <a class="func" href="foreigntypes.html#PL_new_term_ref()">PL_new_term_ref()</a> 
to create up to 10 <code>term_t</code> handles without checking the 
return status.

<p>Returns <code>(fid_t)0</code> on failure. Failure is either lack of 
space on the stacks, in which case a resource exception is scheduled or 
atom-gc being in progress in the current thread, in which case no 
exception is scheduled. The latter is an exceptional case that prevents 
doing a callback on Prolog from <em>blob release handlers</em>.<sup class="fn">229<span class="fn-text">Such 
a callback would <em>deadlock</em> if the callback creates new atoms or 
requires stack shifts or garbage collection.</span></sup></dd>
<dt class="pubdef"><a id="PL_close_foreign_frame()"><var>void</var> <strong>PL_close_foreign_frame</strong>(<var>fid_t 
id</var>)</a></dt>
<dd class="defbody">
Discard all term references created after the frame was opened. Prolog 
data referenced by the discarded term references is not affected.</dd>
<dt class="pubdef"><a id="PL_discard_foreign_frame()"><var>void</var> <strong>PL_discard_foreign_frame</strong>(<var>fid_t 
id</var>)</a></dt>
<dd class="defbody">
Same as <a class="func" href="foreigninclude.html#PL_close_foreign_frame()">PL_close_foreign_frame()</a>, 
but also undo all bindings made since the open and destroy all Prolog 
data.</dd>
<dt class="pubdef"><a id="PL_rewind_foreign_frame()"><var>void</var> <strong>PL_rewind_foreign_frame</strong>(<var>fid_t 
id</var>)</a></dt>
<dd class="defbody">
Undo all bindings and discard all term references created since the 
frame was created, but do not pop the frame. That is, the same frame can 
be rewound multiple times, and must eventually be closed or discarded.
</dd>
</dl>

<p>It is obligatory to call either of the two closing functions to 
discard a foreign frame. Foreign frames may be nested.

<pre class="code">
int
count_atoms()
{ fid_t fid = PL_open_foreign_frame();
  term_t goal  = PL_new_term_ref();
  term_t a1    = PL_new_term_ref();
  term_t a2    = PL_new_term_ref();
  functor_t s2 = PL_new_functor(PL_new_atom("statistics"), 2);
  int atoms;

  PL_put_atom_chars(a1, "atoms");
  PL_cons_functor(goal, s2, a1, a2);
  PL_call(goal, NULL);         /* call it in current module */

  PL_get_integer(a2, &amp;atoms);
  PL_discard_foreign_frame(fid);

  return atoms;
}
</pre>

<div class="caption"><b>Figure 7 : </b>Calling Prolog</div>
<a id="fig:calling"></a>

<p><h3 id="sec:foreign-strings"><a id="sec:12.4.14"><span class="sec-nr">12.4.14</span> <span class="sec-title">String 
buffering</span></a></h3>

<a id="sec:foreign-strings"></a>

<p>Many of the functions of the foreign language interface involve 
strings. Some of these strings point into static memory like those 
associated with atoms. These strings are valid as long as the atom is 
protected against atom garbage collection, which generally implies the 
atom must be locked using <a class="func" href="foreigninclude.html#PL_register_atom()">PL_register_atom()</a> 
or be part of an accessible term. Other strings are more volatile. 
Several functions provide a BUF_* flag that can be set to either <code>BUF_STACK</code> 
(default) or
<code>BUF_MALLOC</code>. Strings returned by a function accepting
<code>BUF_MALLOC</code> <b>must</b> be freed using <a class="func" href="foreignnotes.html#PL_free()">PL_free()</a>. 
Strings returned using <code>BUF_STACK</code> are pushed on a stack that 
is cleared when a foreign predicate returns control back to Prolog. More 
fine grained control may be needed if functions that return strings are 
called outside the context of a foreign predicate or a foreign predicate 
creates many strings during its execution. Temporary strings are scoped 
using these macros:

<dl class="latex">
<dt class="pubdef"><a id="PL_STRINGS_MARK()"><var>void</var> <strong>PL_STRINGS_MARK</strong>(<var></var>)</a></dt>
<dt class="pubdef"><a id="PL_STRINGS_RELEASE()"><var>void</var> <strong>PL_STRINGS_RELEASE</strong>(<var></var>)</a></dt>
<dd class="defbody">
These macros must be paired and create a C <em>block</em> ({...}). Any 
string created using <code>BUF_STACK</code> after <a class="func" href="foreigninclude.html#PL_STRINGS_MARK()">PL_STRINGS_MARK()</a> 
is released by the corresponding <a class="func" href="foreigninclude.html#PL_STRINGS_RELEASE()">PL_STRINGS_RELEASE()</a>. 
These macros should be used like below. Note that strings returned by 
any of the Prolog functions between this pair may be invalidated.

<pre class="code">
  ...
  PL_STRINGS_MARK();
    &lt;operations involving strings&gt;
  PL_STRINGS_RELEASE();
  ...
</pre>

<p></dd>
</dl>

<p>The Prolog flag <a class="flag" href="flags.html#flag:string_stack_tripwire">string_stack_tripwire</a> 
may be used to set a
<em>tripwire</em> to help finding places where scoping strings may help 
reducing resources.

<p><h3 id="sec:foreign-modules"><a id="sec:12.4.15"><span class="sec-nr">12.4.15</span> <span class="sec-title">Foreign 
Code and Modules</span></a></h3>

<a id="sec:foreign-modules"></a>

<p>Modules are identified via a unique handle. The following functions 
are available to query and manipulate modules.

<dl class="latex">
<dt class="pubdef"><a id="PL_context()"><var>module_t</var> <strong>PL_context</strong>(<var></var>)</a></dt>
<dd class="defbody">
Return the module identifier of the context module of the currently 
active foreign predicate. If there is no currently active predicate it 
returns a handle to the <code>user</code> module.</dd>
<dt class="pubdef"><a id="PL_strip_module()"><var>int</var> <strong>PL_strip_module</strong>(<var>term_t 
+raw, module_t *m, term_t -plain</var>)</a></dt>
<dd class="defbody">
Utility function. If <var>raw</var> is a term, possibly holding the 
module construct &lt;<var>module</var>&gt;<code>:</code>&lt;<var>rest</var>&gt;, 
this function will make
<var>plain</var> a reference to &lt;<var>rest</var>&gt; and fill <var>module 
*</var> with &lt;<var>module</var>&gt;. For further nested module 
constructs the innermost module is returned via <var>module *</var>. If <var>raw</var> 
is not a module construct, <var>raw</var> will simply be put in <var>plain</var>. 
The value pointed to by <var>m</var> must be initialized before calling <a class="func" href="foreigninclude.html#PL_strip_module()">PL_strip_module()</a>, 
either to the default module or to <code>NULL</code>. A <code>NULL</code> 
value is replaced by the current context module if <var>raw</var> 
carries no module. The following example shows how to obtain the plain 
term and module if the default module is the user module:

<pre class="code">
{ module m = PL_new_module(PL_new_atom("user"));
  term_t plain = PL_new_term_ref();

  PL_strip_module(term, &amp;m, plain);
  ...
}
</pre>

<p>Returns <code>TRUE</code> on success and <code>FALSE</code> on error, 
leaving an exception. Currently the only exception condition is <var>raw</var> 
to be a cyclic term.</dd>
<dt class="pubdef"><a id="PL_module_name()"><var>atom_t</var> <strong>PL_module_name</strong>(<var>module_t 
module</var>)</a></dt>
<dd class="defbody">
Return the name of <var>module</var> as an atom.</dd>
<dt class="pubdef"><a id="PL_new_module()"><var>module_t</var> <strong>PL_new_module</strong>(<var>atom_t 
name</var>)</a></dt>
<dd class="defbody">
Find an existing module or create a new module with the name <var>name</var>. 
Currently aborts the process with a <em>fatal error</em> on failure. 
Future versions may raise a resource exception and return
<code>(module_t)0</code>.
</dd>
</dl>

<p><h3 id="sec:foreign-exceptions"><a id="sec:12.4.16"><span class="sec-nr">12.4.16</span> <span class="sec-title">Prolog 
exceptions in foreign code</span></a></h3>

<a id="sec:foreign-exceptions"></a>

<p>This section discusses <a class="func" href="foreigninclude.html#PL_exception()">PL_exception()</a> 
and <a class="func" href="foreigninclude.html#PL_raise_exception()">PL_raise_exception()</a>, 
the interface functions to detect and generate Prolog exceptions from C 
code. <a class="func" href="foreigninclude.html#PL_raise_exception()">PL_raise_exception()</a> 
from the C interface registers the exception term and returns <code>FALSE</code>. 
If a foreign predicate returns
<code>FALSE</code>, while an exception term is registered, a Prolog 
exception will be raised by the virtual machine. This implies for a 
foreign function that implements a predicate and wishes to raise an 
exception, the function must call <a class="func" href="foreigninclude.html#PL_raise_exception()">PL_raise_exception()</a>, 
perform any necessary cleanup, and return the return code of <a class="func" href="foreigninclude.html#PL_raise_exception()">PL_raise_exception()</a> 
or explicitly
<code>FALSE</code>. Calling <a class="func" href="foreigninclude.html#PL_raise_exception()">PL_raise_exception()</a> 
outside the context of a function implementing a foreign predicate 
results in undefined behaviour.

<p>Note that many of the C API functions may call <a class="func" href="foreigninclude.html#PL_raise_exception()">PL_raise_exception()</a> 
and return <code>FALSE</code>. The user must test for this, cleanup, and 
make the foreign function return <code>FALSE</code>.

<p><a class="func" href="foreigninclude.html#PL_exception()">PL_exception()</a> 
may be used to inspect the currently registered exception. It is 
normally called after a call to <a class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</a> 
returns <code>FALSE</code>, and returns a term reference to an exception 
term if an exception is pending, and <code>(term_t)0</code> otherwise. 
It may also be called after, e.g., <a class="func" href="foreigninclude.html#PL_unify()">PL_unify()</a> 
to distinguish a normal failing unification from a unification that 
raised an resource error exception.
<a class="func" href="foreigninclude.html#PL_exception()">PL_exception()</a> 
must only be called after a function such as
<a class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</a> 
or <a class="func" href="foreigninclude.html#PL_unify()">PL_unify()</a> 
returns failure; if called elsewhere, the return value is undefined.

<p>If a C function implementing a predicate that calls Prolog should use
<a class="func" href="foreigninclude.html#PL_open_query()">PL_open_query()</a> 
with the flag <code>PL_Q_PASS_EXCEPTION</code> and make the function 
return FALSE if <a class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</a> 
returns <code>FALSE</code> and
<a class="func" href="foreigninclude.html#PL_exception()">PL_exception()</a> 
indicates an exception is pending.

<p>Both for C functions implementing a predicate and when Prolog is 
called while the main control of the process is in C, user code should 
always check for exceptions. As explained above, C functions 
implementing a predicate should normally cleanup and return with <code>FALSE</code>. 
If the C function whishes to continue it may call <a class="func" href="foreigninclude.html#PL_clear_exception()">PL_clear_exception()</a>. 
Note that this may cause any exception to be ignored, including <em>time 
outs</em> and <em>abort</em>. Typically the user should check the 
exception details before ignoring an exception (using <code><a class="func" href="foreigninclude.html#PL_exception()">PL_exception(0)</a></code> 
or
<code><a class="func" href="foreigninclude.html#PL_exception()">PL_exception(qid)</a></code> 
as appropriate). If the C code does not implement a predicate it 
normally prints the exception and calls
<a class="func" href="foreigninclude.html#PL_clear_exception()">PL_clear_exception()</a> 
to discard it. Exceptions may be printed by calling
<a id="idx:printmessage2:2568"></a><a class="pred" href="printmsg.html#print_message/2">print_message/2</a> 
through the C interface.

<dl class="latex">
<dt class="pubdef"><a id="PL_raise_exception()"><var>int</var> <strong>PL_raise_exception</strong>(<var>term_t 
exception</var>)</a></dt>
<dd class="defbody">
Generate an exception (as <a id="idx:throw1:2569"></a><a class="pred" href="exception.html#throw/1">throw/1</a>) 
and return <code>FALSE</code>. If there is already a pending exception, 
the most urgent exception is kept; and if both are of the same urgency, 
the new exception is kept. Urgency of exceptions is defined as

<p>
<ol class="latex">
<li>abort (<code>'$aborted'</code>).
<li><code>time_limit_exceeded</code> (see <a id="idx:callwithtimelimit2:2570"></a><span class="pred-ext">call_with_time_limit/2</span>).
<li><code>resource_error</code> exceptions.
<li>Other <code>error(Formal, ImplDef)</code> exceptions.
<li>Other exceptions.
</ol>

<p>This function is rarely used directly. Instead, errors are typically 
raised using the functions in <a class="sec" href="foreigninclude.html#sec:12.4.7">section 
12.4.7</a> or the C api functions that end in <code>_ex</code> such as <a class="func" href="foreigninclude.html#PL_get_atom_ex()">PL_get_atom_ex()</a>. 
Below we give an example returning an exception from a foreign predicate 
the verbose way. Note that the exception is raised in a sequence of 
actions connected using <code>&amp;&amp;</code>. This ensures that a 
proper exception is raised should any of the calls used to build or 
raise the exception themselves raise an exception. In this simple case <a class="func" href="foreigntypes.html#PL_new_term_ref()">PL_new_term_ref()</a> 
is guaranteed to succeed because the system guarantees at least 10 
available term references before entering the foreign predicate. <a class="func" href="foreigninclude.html#PL_unify_term()">PL_unify_term()</a> 
however may raise a resource exception for the global stack.

<pre class="code">
foreign_t
pl_hello(term_t to)
{ char *s;

  if ( PL_get_atom_chars(to, &amp;s) )
  { return Sfprintf(Scurrent_output, "Hello \"%s\"\n", s);
  } else
  { term_t except;

    return  ( (except=PL_new_term_ref()) &amp;&amp;
              PL_unify_term(except,
                            PL_FUNCTOR_CHARS, "type_error", 2,
                              PL_CHARS, "atom",
                              PL_TERM, to) &amp;&amp;
              PL_raise_exception(except) );
  }
}
</pre>

<p>For reference, the preferred implementation of the above is below. 
The
<code>CVT_EXCEPTION</code> tells the system to generate an exception if 
the conversion fails. The other <code>CVT_</code> flags define the 
admissible types and <code>REP_MB</code> requests the string to be 
provided in the current <em>locale</em> representation. This implies 
that Unicode text is printed correctly if the current environment can 
represent it. If not, a <code>representation_error</code> is raised.

<pre class="code">
foreign_t
pl_hello(term_t to)
{ char *s;

  if ( PL_get_chars(to, &amp;s, CVT_ATOM|CVT_STRING|CVT_EXCEPTION|REP_MB) )
  { return Sfprintf(Scurrent_output, "Hello \"%s\"\n", s);
  }

  return FALSE;
}
</pre>

</dd>
<dt class="pubdef"><a id="PL_throw()"><var>int</var> <strong>PL_throw</strong>(<var>term_t 
exception</var>)</a></dt>
<dd class="defbody">
Similar to <a class="func" href="foreigninclude.html#PL_raise_exception()">PL_raise_exception()</a>, 
but returns using the C <b>longjmp()</b> function to the innermost <a class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</a>. 
This function is deprecated as it does not provide the opportunity to 
cleanup.</dd>
<dt class="pubdef"><a id="PL_exception()"><var>term_t</var> <strong>PL_exception</strong>(<var>qid_t 
qid</var>)</a></dt>
<dd class="defbody">
Return the <em>pending exception</em>. Exceptions may be raised by most 
of the API calls described in this chapter, a common possibility being
<code>resource_error</code> exceptions. Some return <code>type_error</code> 
or <code>domain_error</code> exceptions. A call to Prolog using
<a class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</a> 
may return any exception, including those thrown by explicit calls to <a id="idx:throw1:2571"></a><a class="pred" href="exception.html#throw/1">throw/1</a>. 
If no exception is pending this function returns <code>(term_t)0</code>.

<p>Normally <var>qid</var> should be <code>0</code>. An explicit <var>qid</var> 
must be used after a call to <a class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</a> 
that returns <code>FALSE</code> when the query was created using the <code>PL_Q_PASS_EXCEPTION</code> 
flag (see <a class="func" href="foreigninclude.html#PL_open_query()">PL_open_query()</a>).

<p>Note that an API may only raise an exception when it fails; if the 
API call succeeds, the result of <code><a class="func" href="foreigninclude.html#PL_exception()">PL_exception(0)</a></code> 
will be 0.<sup class="fn">230<span class="fn-text">Provided no exception 
was pending before calling the API function. As clients must deal with 
exceptions immediately after an API call raises one, this can not happen 
in a well behaved client.</span></sup> The implementation of a foreign 
predicate should normally cleanup and return
<code>FALSE</code> after an exception is raised (and typically also 
after an API call failed for logical reasons; see <a class="func" href="foreigninclude.html#PL_unify()">PL_unify()</a> 
for an elaboration on this topic). If the call to Prolog is not the 
implementation of a foreign predicate, e.g., when the overall process 
control is in some other language, exceptions may be printed by calling <a id="idx:printmessage2:2572"></a><a class="pred" href="printmsg.html#print_message/2">print_message/2</a> 
and should be discarded by calling <a class="func" href="foreigninclude.html#PL_clear_exception()">PL_clear_exception()</a>.</dd>
<dt class="pubdef"><a id="PL_clear_exception()"><var>void</var> <strong>PL_clear_exception</strong>(<var>void</var>)</a></dt>
<dd class="defbody">
Tells Prolog that the encountered exception must be ignored. This 
function must be called if control remains in C after a previous API 
call fails with an exception.<sup class="fn">231<span class="fn-text">This 
feature is non-portable. Other Prolog systems (e.g., YAP) have no 
facilities to ignore raised exceptions, and the design of YAP's 
exception handling does not support such a facility.</span></sup> If 
there is no pending exception, <a class="func" href="foreigninclude.html#PL_clear_exception()">PL_clear_exception()</a> 
does nothing.
</dd>
</dl>

<p><h3 id="sec:csignal"><a id="sec:12.4.17"><span class="sec-nr">12.4.17</span> <span class="sec-title">Catching 
Signals (Software Interrupts)</span></a></h3>

<a id="sec:csignal"></a>

<p>SWI-Prolog offers both a C and Prolog interface to deal with software 
interrupts (signals). The Prolog mapping is defined in
<a class="sec" href="signal.html#sec:4.12">section 4.12</a>. This 
subsection deals with handling signals from C.

<p>If a signal is not used by Prolog and the handler does not call 
Prolog in any way, the native signal interface routines may be used.

<p>Any handler that wishes to call one of the Prolog interface functions 
should call <a class="func" href="foreigninclude.html#PL_sigaction()">PL_sigaction()</a> 
to install the handler. <a class="func" href="foreigninclude.html#PL_signal()">PL_signal()</a> 
provides a deprecated interface that is notably not capable of properly 
restoring the old signal status if the signal was previously handled by 
Prolog.

<dl class="latex">
<dt class="pubdef"><a id="PL_sigaction()"><var>int</var> <strong>PL_sigaction</strong>(<var>int 
sig, pl_sigaction_t *act, pl_sigaction_t *oldact</var>)</a></dt>
<dd class="defbody">
Install or query the status for signal <var>sig</var>. The signal is an 
integer between 1 and 64, where the where the signals up to 32 are 
mapped to OS signals and signals above that are handled by Prolog's 
synchronous signal handling. The <code>pl_sigaction_t</code> is a struct 
with the following definition:

<pre class="code">
typedef struct pl_sigaction
{ void        (*sa_cfunction)(int);     /* traditional C function */
  predicate_t sa_predicate;             /* call a predicate */
  int         sa_flags;                 /* additional flags */
} pl_sigaction_t;
</pre>

<p>The <code>sa_flags</code> is a bitwise or of <code>PLSIG_THROW</code>,
<code>PLSIG_SYNC</code> and <code>PLSIG_NOFRAME</code>. Signal handling 
is enabled if <code>PLSIG_THROW</code> is provided, <code>sa_cfunction</code> 
or
<code>sa_predicate</code> is provided. <code>sa_predicate</code> is a 
predicate handle for a predicate with arity&nbsp;1. If no action is 
provided the signal handling for this signal is restored to the default 
before
<a class="func" href="foreigninclude.html#PL_initialise()">PL_initialise()</a> 
was called.

<p>Finally, 0 (zero) may be passed for <var>sig</var>. In that case the 
system allocates a free signal in the <i>Prolog range</i> (32 ... 64). 
Such signal handler are activated using <b>PL_thread_raise()</b>.</dd>
<dt class="pubdef"><a id="PL_signal()"><var>void (*)()</var> <strong>PL_signal</strong>(<var>sig, 
func</var>)</a></dt>
<dd class="defbody">
This function is equivalent to the BSD-Unix <b>signal()</b> function, 
regardless of the platform used. The signal handler is blocked while the 
signal routine is active, and automatically reactivated after the 
handler returns.

<p>After a signal handler is registered using this function, the native 
signal interface redirects the signal to a generic signal handler inside 
SWI-Prolog. This generic handler validates the environment, creates a 
suitable environment for calling the interface functions described in 
this chapter and finally calls the registered user-handler.

<p>By default, signals are handled asynchronously (i.e., at the time 
they arrive). It is inherently dangerous to call extensive code 
fragments, and especially exception related code from asynchronous 
handlers. The interface allows for <em>synchronous</em> handling of 
signals. In this case the native OS handler just schedules the signal 
using <a class="func" href="foreigninclude.html#PL_raise()">PL_raise()</a>, 
which is checked by <a class="func" href="foreigninclude.html#PL_handle_signals()">PL_handle_signals()</a> 
at the call- and redo-port. This behaviour is realised by <em>or</em>-ing <var>sig</var> 
with the constant
<code>PL_SIGSYNC</code>.<sup class="fn">232<span class="fn-text">A 
better default would be to use synchronous handling, but this interface 
preserves backward compatibility.</span></sup>

<p>Signal handling routines may raise exceptions using
<a class="func" href="foreigninclude.html#PL_raise_exception()">PL_raise_exception()</a>. 
The use of <a class="func" href="foreigninclude.html#PL_throw()">PL_throw()</a> 
is not safe. If a synchronous handler raises an exception, the exception 
is delayed to the next call to <a class="func" href="foreigninclude.html#PL_handle_signals()">PL_handle_signals()</a>;</dd>
<dt class="pubdef"><a id="PL_raise()"><var>int</var> <strong>PL_raise</strong>(<var>int 
sig</var>)</a></dt>
<dd class="defbody">
Register <var>sig</var> for <em>synchronous</em> handling by Prolog. 
Synchronous signals are handled at the call-port or if foreign code 
calls <a class="func" href="foreigninclude.html#PL_handle_signals()">PL_handle_signals()</a>. 
See also <a id="idx:threadsignal2:2573"></a><a class="pred" href="threadcom.html#thread_signal/2">thread_signal/2</a>.</dd>
<dt class="pubdef"><a id="PL_handle_signals()"><var>int</var> <strong>PL_handle_signals</strong>(<var>void</var>)</a></dt>
<dd class="defbody">
Handle any signals pending from <a class="func" href="foreigninclude.html#PL_raise()">PL_raise()</a>. <a class="func" href="foreigninclude.html#PL_handle_signals()">PL_handle_signals()</a> 
is called at each pass through the call- and redo-port at a safe point. 
Exceptions raised by the handler using <a class="func" href="foreigninclude.html#PL_raise_exception()">PL_raise_exception()</a> 
are properly passed to the environment.

<p>The user may call this function inside long-running foreign functions 
to handle scheduled interrupts. This routine returns the number of 
signals handled. If a handler raises an exception, the return value is 
-1 and the calling routine should return with <code>FALSE</code> as soon 
as possible.</dd>
<dt class="pubdef"><a id="PL_get_signum_ex()"><var>int</var> <strong>PL_get_signum_ex</strong>(<var>term_t 
t, int *sig</var>)</a></dt>
<dd class="defbody">
Extract a signal specification from a Prolog term and store as an 
integer signal number in <var>sig</var>. The specification is an 
integer, a lowercase signal name without <code>SIG</code> or the full 
signal name. These refer to the same: <code>9</code>, <code>kill</code> 
and <code>SIGKILL</code>. Leaves a typed, domain or instantiation error 
if the conversion fails.
</dd>
</dl>

<p><h3 id="sec:foreign-misc"><a id="sec:12.4.18"><span class="sec-nr">12.4.18</span> <span class="sec-title">Miscellaneous</span></a></h3>

<a id="sec:foreign-misc"></a>

<p><h4 id="sec:foreign-compare"><a id="sec:12.4.18.1"><span class="sec-nr">12.4.18.1</span> <span class="sec-title">Term 
Comparison</span></a></h4>

<a id="sec:foreign-compare"></a>

<dl class="latex">
<dt class="pubdef"><a id="PL_compare()"><var>int</var> <strong>PL_compare</strong>(<var>term_t 
t1, term_t t2</var>)</a></dt>
<dd class="defbody">
Compares two terms using the standard order of terms and returns -1, 0 
or 1. See also <a id="idx:compare3:2574"></a><a class="pred" href="compare.html#compare/3">compare/3</a>.
</dd>
<dt class="pubdef"><a id="PL_same_compound()"><var>int</var> <strong>PL_same_compound</strong>(<var>term_t 
t1, term_t t2</var>)</a></dt>
<dd class="defbody">
Yields <code>TRUE</code> if <var>t1</var> and <var>t2</var> refer to 
physically the same compound term and <code>FALSE</code> otherwise.
</dd>
</dl>

<p><h4 id="sec:foreign-recorded"><a id="sec:12.4.18.2"><span class="sec-nr">12.4.18.2</span> <span class="sec-title">Recorded 
database</span></a></h4>

<a id="sec:foreign-recorded"></a>

<p>In some applications it is useful to store and retrieve Prolog terms 
from C code. For example, the XPCE graphical environment does this for 
storing arbitrary Prolog data as slot-data of XPCE objects.

<p>Please note that the returned handles have no meaning at the Prolog 
level and the recorded terms are not visible from Prolog. The functions
<a class="func" href="foreigninclude.html#PL_recorded()">PL_recorded()</a> 
and <a class="func" href="foreigninclude.html#PL_erase()">PL_erase()</a> 
are the only functions that can operate on the stored term.

<p>Two groups of functions are provided. The first group (<a class="func" href="foreigninclude.html#PL_record()">PL_record()</a> 
and friends) store Prolog terms on the Prolog heap for retrieval during 
the same session. These functions are also used by <a id="idx:recorda3:2575"></a><a class="pred" href="db.html#recorda/3">recorda/3</a> 
and friends. The recorded database may be used to communicate Prolog 
terms between threads.

<dl class="latex">
<dt class="pubdef"><a id="PL_record()"><var>record_t</var> <strong>PL_record</strong>(<var>term_t 
+t</var>)</a></dt>
<dd class="defbody">
Record the term <var>t</var> into the Prolog database as <a id="idx:recorda3:2576"></a><a class="pred" href="db.html#recorda/3">recorda/3</a> 
and return an opaque handle to the term. The returned handle remains 
valid until <a class="func" href="foreigninclude.html#PL_erase()">PL_erase()</a> 
is called on it. <a class="func" href="foreigninclude.html#PL_recorded()">PL_recorded()</a> 
is used to copy recorded terms back to the Prolog stack. Currently 
aborts the process with a <em>fatal error</em> on failure. Future 
versions may raise a resource exception and return <code>(record_t)0</code>.</dd>
<dt class="pubdef"><a id="PL_duplicate_record()"><var>record_t</var> <strong>PL_duplicate_record</strong>(<var>record_t 
record</var>)</a></dt>
<dd class="defbody">
Return a duplicate of <var>record</var>. As records are read-only 
objects this function merely increments the records reference count. 
Returns <code>(record_t)0</code> if the <var>record</var> is an
<em>external record</em> (see <a class="func" href="foreigninclude.html#PL_record_external()">PL_record_external()</a>).</dd>
<dt class="pubdef"><a id="PL_recorded()"><var>int</var> <strong>PL_recorded</strong>(<var>record_t 
record, term_t -t</var>)</a></dt>
<dd class="defbody">
Copy a recorded term back to the Prolog stack. The same record may be 
used to copy multiple instances at any time to the Prolog stack. Returns <code>TRUE</code> 
on success, and <code>FALSE</code> if there is not enough space on the 
stack to accommodate the term. See also <a class="func" href="foreigninclude.html#PL_record()">PL_record()</a> 
and <a class="func" href="foreigninclude.html#PL_erase()">PL_erase()</a>.</dd>
<dt class="pubdef"><a id="PL_erase()"><var>void</var> <strong>PL_erase</strong>(<var>record_t 
record</var>)</a></dt>
<dd class="defbody">
Remove the recorded term from the Prolog database, reclaiming all 
associated memory resources.
</dd>
</dl>

<p>The second group (headed by <a class="func" href="foreigninclude.html#PL_record_external()">PL_record_external()</a>) 
provides the same functionality, but the returned data has properties 
that enable storing the data on an external device. It has been designed 
for fast and compact storage of Prolog terms in an external database. 
Here are the main features:

<p>
<ul class="latex">
<li><i>Independent of session</i><br>
Records can be communicated to another Prolog session and made visible 
using <a class="func" href="foreigninclude.html#PL_recorded_external()">PL_recorded_external()</a>.
<li><i>Binary</i><br>
The representation is binary for maximum performance. The returned data 
may contain zero bytes.
<li><i>Byte-order independent</i><br>
The representation can be transferred between machines with different 
byte order.
<li><i>No alignment restrictions</i><br>
There are no memory alignment restrictions and copies of the record can 
thus be moved freely. For example, it is possible to use this 
representation to exchange terms using shared memory between different 
Prolog processes.
<li><i>Compact</i><br>
It is assumed that a smaller memory footprint will eventually outperform 
slightly faster representations.
<li><i>Stable</i><br>
The format is designed for future enhancements without breaking 
compatibility with older records.
</ul>

<dl class="latex">
<dt class="pubdef"><a id="PL_record_external()"><var>char *</var> <strong>PL_record_external</strong>(<var>term_t 
+t, size_t *len</var>)</a></dt>
<dd class="defbody">
Similar to <a class="func" href="foreigninclude.html#PL_record()">PL_record()</a>, 
but the term is serialized such that it can be reloaded in another 
Prolog session. This implies that atoms and functors are stored by their 
content rather than their handle. As a result, <a class="func" href="foreigninclude.html#PL_record_external()">PL_record_external()</a> 
fails (returning
<code>NULL</code> if the term contains <em>blobs</em> that cannot be 
serialized, such as streams.

<p>These functions are used to implement library <code>library(fastrw)</code> 
as well as for storing Prolog terms in external databases such as 
BerkeleyDB (library <code>library(bdb)</code>) or RocksDB. The 
representation is optimized for plain atoms and numbers.

<p>Records that are used only in the same Prolog process should use
<a class="func" href="foreigninclude.html#PL_record()">PL_record()</a> 
as this can represent any term, is more compact and faster.

<p>The returned string may be copied. Note that the string may contain 
null bytes and is not null terminated. The length in bytes is returned 
in <var>len</var>. After copying, the returned string may be discarded 
using <a class="func" href="foreigninclude.html#PL_erase_external()">PL_erase_external()</a>.

<p><a class="func" href="foreigninclude.html#PL_recorded_external()">PL_recorded_external()</a> 
is used to copy the term represented in the data back to the Prolog 
stack. <a class="func" href="foreigninclude.html#PL_recorded_external()">PL_recorded_external()</a> 
can be used on the returned string as well as on a copy.
</dd>
<dt class="pubdef"><a id="PL_recorded_external()"><var>int</var> <strong>PL_recorded_external</strong>(<var>const 
char *record, term_t -t</var>)</a></dt>
<dd class="defbody">
Copy a recorded term back to the Prolog stack. The same record may be 
used to copy multiple instances at any time to the Prolog stack. See 
also <a class="func" href="foreigninclude.html#PL_record_external()">PL_record_external()</a> 
and <a class="func" href="foreigninclude.html#PL_erase_external()">PL_erase_external()</a>.
</dd>
<dt class="pubdef"><a id="PL_erase_external()"><var>int</var> <strong>PL_erase_external</strong>(<var>char 
*record</var>)</a></dt>
<dd class="defbody">
Remove the recorded term from the Prolog database, reclaiming all 
associated memory resources.
</dd>
</dl>

<p><h4 id="sec:foreign-db"><a id="sec:12.4.18.3"><span class="sec-nr">12.4.18.3</span> <span class="sec-title">Database</span></a></h4>

<a id="sec:foreign-db"></a>

<dl class="latex">
<dt class="pubdef"><a id="PL_assert()"><var>int</var> <strong>PL_assert</strong>(<var>term_t 
t, module_t m, int flags</var>)</a></dt>
<dd class="defbody">
Provides direct access to <a id="idx:asserta1:2577"></a><a class="pred" href="db.html#asserta/1">asserta/1</a> 
and <a id="idx:assertz1:2578"></a><a class="pred" href="db.html#assertz/1">assertz/1</a> 
by asserting <var>t</var> into the database in the module <var>m</var>. 
Defined flags are:

<dl class="latex">
<dt><strong>PL_ASSERTZ</strong></dt>
<dd class="defbody">
Add the new clause as last. Calls <a id="idx:assertz1:2579"></a><a class="pred" href="db.html#assertz/1">assertz/1</a>. 
This macros is defined as 0 and thus the default.
</dd>
<dt><strong>PL_ASSERTA</strong></dt>
<dd class="defbody">
Add the new clause as first. Calls <a id="idx:asserta1:2580"></a><a class="pred" href="db.html#asserta/1">asserta/1</a>.
</dd>
<dt><strong>PL_CREATE_THREAD_LOCAL</strong></dt>
<dd class="defbody">
If the predicate is not defined, create it as thread-local. See
<a id="idx:threadlocal1:2581"></a><a class="pred" href="threadcom.html#thread_local/1">thread_local/1</a>.
</dd>
<dt><strong>PL_CREATE_INCREMENTAL</strong></dt>
<dd class="defbody">
If the predicate is not defined, create it as <em>incremental</em> see
<a id="idx:table1:2582"></a><a class="pred" href="tabling-preds.html#table/1">table/1</a> 
and <a class="sec" href="tabling-incremental.html#sec:7.7">section 7.7</a>.
</dd>
</dl>

<p>On success this function returns <code>TRUE</code>. On failure <code>FALSE</code> 
is returned and an exception is left in the environment that describes 
the reason of failure. See <a class="func" href="foreigninclude.html#PL_exception()">PL_exception()</a>.

<p>This predicate bypasses creating a Prolog callback environment and is 
faster than setting up a call to <a id="idx:assertz1:2583"></a><a class="pred" href="db.html#assertz/1">assertz/1</a>. 
It may be used together with
<a class="func" href="foreigninclude.html#PL_chars_to_term()">PL_chars_to_term()</a>, 
but the typical use case will create a number of clauses for the same 
predicate. The fastest way to achieve this is by creating a term that 
represents the invariable structure of the desired clauses using 
variables for the variable sub terms. Now we can loop over the data, 
binding the variables, asserting the term and undoing the bindings. 
Below is an example loading words from a file that contains a word per 
line.

<pre class="code">
#include &lt;SWI-Prolog.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define MAXWLEN 256

static foreign_t
load_words(term_t name)
{ char *fn;

  if ( PL_get_file_name(name, &amp;fn, PL_FILE_READ) )
  { FILE *fd = fopen(fn, "r");
    char word[MAXWLEN];
    module_t m = PL_new_module(PL_new_atom("words"));
    term_t cl = PL_new_term_ref();
    term_t w  = PL_new_term_ref();
    fid_t fid;

    if ( !PL_unify_term(cl, PL_FUNCTOR_CHARS, "word", 1, PL_TERM, w) )
      return FALSE;

    if ( (fid = PL_open_foreign_frame()) )
    { while(fgets(word, sizeof word, fd))
      { size_t len;

        if ( (len=strlen(word)) )
        { word[len-1] = '\0';
          if ( !PL_unify_chars(w, PL_ATOM|REP_MB, (size_t)-1, word) ||
               !PL_assert(cl, m, 0) )
            return FALSE;
          PL_rewind_foreign_frame(fid);
        }
      }

      PL_close_foreign_frame(fid);
    }

    fclose(fd);
    return TRUE;
  }

  return FALSE;
}

install_t
install(void)
{ PL_register_foreign("load_words", 1, load_words, 0);
}
</pre>

<p></dd>
</dl>

<p><h4 id="sec:cfilenames"><a id="sec:12.4.18.4"><span class="sec-nr">12.4.18.4</span> <span class="sec-title">Getting 
file names</span></a></h4>

<a id="sec:cfilenames"></a>

<p>The function <a class="func" href="foreigninclude.html#PL_get_file_name()">PL_get_file_name()</a> 
provides access to Prolog filenames and its file-search mechanism 
described with <a id="idx:absolutefilename3:2584"></a><a class="pred" href="files.html#absolute_file_name/3">absolute_file_name/3</a>. 
Its existence is motivated to realise a uniform interface to deal with 
file properties, search, naming conventions, etc., from foreign code.

<dl class="latex">
<dt class="pubdef"><a id="PL_get_file_name()"><var>int</var> <strong>PL_get_file_name</strong>(<var>term_t 
spec, char **name, int flags</var>)</a></dt>
<dd class="defbody">
Translate a Prolog term into a file name. The name is stored in the 
buffer stack described with the <a class="func" href="foreigninclude.html#PL_get_chars()">PL_get_chars()</a> 
option <code>BUF_STACK</code>, which is popped upon return from the 
foreign predicate to Prolog. Conversion from the internal UNICODE 
encoding is done using standard C library functions. <var>flags</var> is 
a bit-mask controlling the conversion process. On failure, <code>PL_FILE_NOERRORS</code> 
controls whether an exception is raised. Options are:

<dl class="latex">
<dt><b><code>PL_FILE_ABSOLUTE</code></b></dt>
<dd class="defbody">
Return an absolute path to the requested file.
</dd>
<dt><b><code>PL_FILE_OSPATH</code></b></dt>
<dd class="defbody">
Return the name using the hosting OS conventions. On MS-Windows,
<code><code>\</code></code> is used to separate directories rather than 
the canonical
<code><code>/</code></code>.
</dd>
<dt><b><code>PL_FILE_SEARCH</code></b></dt>
<dd class="defbody">
Invoke <a id="idx:absolutefilename3:2585"></a><a class="pred" href="files.html#absolute_file_name/3">absolute_file_name/3</a>. 
This implies rules from <a id="idx:filesearchpath2:2586"></a><a class="pred" href="consulting.html#file_search_path/2">file_search_path/2</a> 
are used.
</dd>
<dt><b><code>PL_FILE_EXIST</code></b></dt>
<dd class="defbody">
Demand the path to refer to an existing entity.
</dd>
<dt><b><code>PL_FILE_READ</code></b></dt>
<dd class="defbody">
Demand read-access on the result.
</dd>
<dt><b><code>PL_FILE_WRITE</code></b></dt>
<dd class="defbody">
Demand write-access on the result.
</dd>
<dt><b><code>PL_FILE_EXECUTE</code></b></dt>
<dd class="defbody">
Demand execute-access on the result.
</dd>
<dt><b><code>PL_FILE_NOERRORS</code></b></dt>
<dd class="defbody">
Do not raise any exceptions.
</dd>
</dl>

</dd>
<dt class="pubdef"><a id="PL_get_file_nameW()"><var>int</var> <strong>PL_get_file_nameW</strong>(<var>term_t 
spec, wchar_t **name, int flags</var>)</a></dt>
<dd class="defbody">
Same as <a class="func" href="foreigninclude.html#PL_get_file_name()">PL_get_file_name()</a>, 
but returns the filename as a wide-character string. This is intended 
for Windows to access the Unicode version of the Win32 API. Note that 
the flag <code>PL_FILE_OSPATH</code> must be provided to fetch a 
filename in OS native (e.g., <code>C:\x\y</code>) notation.
</dd>
</dl>

<p><h4 id="sec:cprologflags"><a id="sec:12.4.18.5"><span class="sec-nr">12.4.18.5</span> <span class="sec-title">Dealing 
with Prolog flags from C</span></a></h4>

<a id="sec:cprologflags"></a>

<p>Foreign code can set or create Prolog flags using <a class="func" href="foreigninclude.html#PL_set_prolog_flag()">PL_set_prolog_flag()</a>. 
See <a id="idx:setprologflag2:2587"></a><a class="pred" href="flags.html#set_prolog_flag/2">set_prolog_flag/2</a> 
and <a id="idx:createprologflag3:2588"></a><a class="pred" href="flags.html#create_prolog_flag/3">create_prolog_flag/3</a>. 
To retrieve the value of a flag you can use <a class="func" href="foreigninclude.html#PL_current_prolog_flag()">PL_current_prolog_flag()</a>.

<dl class="latex">
<dt class="pubdef"><a id="PL_set_prolog_flag()"><var>int</var> <strong>PL_set_prolog_flag</strong>(<var>const 
char *name, int type, ...</var>)</a></dt>
<dd class="defbody">
Set/create a Prolog flag from C. <var>name</var> is the name of the 
affected flag. <var>type</var> is one of the values below, which also 
dictates the type of the final argument. The function returns
<code>TRUE</code> on success and <code>FALSE</code> on failure. This 
function can be called <em>before</em> <a class="func" href="foreigninclude.html#PL_initialise()">PL_initialise()</a>, 
making the flag available to the Prolog startup code.

<dl class="latex">
<dt><b><code>PL_BOOL</code></b></dt>
<dd class="defbody">
Create a boolean (<code>true</code> or <code>false</code>) flag. The 
argument must be an <code>int</code>.
</dd>
<dt><b><code>PL_ATOM</code></b></dt>
<dd class="defbody">
Create a flag with an atom as value. The argument must be of type
<code>const char *</code>.
</dd>
<dt><b><code>PL_INTEGER</code></b></dt>
<dd class="defbody">
Create a flag with an integer as value. The argument must be of type
<code>intptr_t *</code>.
</dd>
</dl>

</dd>
</dl>

<dl class="latex">
<dt class="pubdef"><a id="PL_current_prolog_flag()"><var>int</var> <strong>PL_current_prolog_flag</strong>(<var>atom_t 
name, int type, void *value</var>)</a></dt>
<dd class="defbody">
Retrieve the value of a Prolog flag from C. <var>name</var> is the name 
of the flag as an <code>atom_t</code> (see <a id="idx:currentprologflag2:2589"></a><a class="pred" href="flags.html#current_prolog_flag/2">current_prolog_flag/2</a>).
<var>type</var> specifies the kind of value to be retrieved, it is one 
of the values below. <var>value</var> is a pointer to a location where 
to store the value. The user is responsible for making sure this memory 
location is of the appropriate size/type (see the returned types below 
to determine the size/type). The function returns <code>TRUE</code> on 
success and <code>FALSE</code> on failure.

<dl class="latex">
<dt><b><code>PL_ATOM</code></b></dt>
<dd class="defbody">
Retrieve a flag whose value is an <code>atom</code>. The returned value 
is an atom handle of type <code>atom_t</code>.
</dd>
<dt><b><code>PL_INTEGER</code></b></dt>
<dd class="defbody">
Retrieve a flag whose value is an <code>integer</code>. The returned 
value is an integer of type <code>int64_t</code>.
</dd>
<dt><b><code>PL_FLOAT</code></b></dt>
<dd class="defbody">
Retrieve a flag whose value is a <code>float</code>. The returned value 
is a floating point number of type <code>double</code>.
</dd>
<dt><b><code>PL_TERM</code></b></dt>
<dd class="defbody">
Retrieve a flag whose value is a <code>term</code>. The returned value 
is a term handle of type <code>term_t</code>.
</dd>
</dl>

</dd>
</dl>

<p><h4 id="sec:c-api-wfs"><a id="sec:12.4.18.6"><span class="sec-nr">12.4.18.6</span> <span class="sec-title">Foreign 
code and Well Founded Semantics</span></a></h4>

<a id="sec:c-api-wfs"></a>

<dl class="latex">
<dt class="pubdef"><a id="PL_get_delay_list()"><var>int</var> <strong>PL_get_delay_list</strong>(<var>term_t 
-dl</var>)</a></dt>
<dd class="defbody">
Fetch the current <em>delay list</em>. If this list is not empty, the 
current answer is <em>undefined</em>. In the logical sense, this 
function always succeeds and sets <var>dl</var> to the delay list. It 
returns
<code>FALSE</code> if the delay list is empty (and answer is well 
defined) and <code>TRUE</code> if the delay list is not empty. If <var>dl</var> 
is 0 no list is instantiated, while the return value is the same. This 
allows for testing that an answer is undefined as below.

<pre class="code">
  if ( PL_get_delay_list(0) )
    &lt;undefined&gt;
  else
    &lt;normal answer&gt;
</pre>

<p>For now, we consider the content of the list elements opaque. See
<code>boot/tabling.pl</code> for examples.
</dd>
</dl>

<p><h3 id="sec:foreign-print-warning"><a id="sec:12.4.19"><span class="sec-nr">12.4.19</span> <span class="sec-title">Errors 
and warnings</span></a></h3>

<a id="sec:foreign-print-warning"></a>

<p><a class="func" href="foreigninclude.html#PL_warning()">PL_warning()</a> 
prints a standard Prolog warning message to the standard error (<code>user_error</code>) 
stream. Please note that new code should consider using <a class="func" href="foreigninclude.html#PL_raise_exception()">PL_raise_exception()</a> 
to raise a Prolog exception. See also <a class="sec" href="exception.html#sec:4.10">section 
4.10</a>.

<dl class="latex">
<dt class="pubdef"><a id="PL_warning()"><var>int</var> <strong>PL_warning</strong>(<var>format, 
a1, ...</var>)</a></dt>
<dd class="defbody">
Print an error message starting with&lsquo;<code>[WARNING: </code>&rsquo;, 
followed by the output from <var>format</var>, followed by a&lsquo;<code>]</code>&rsquo;and 
a newline. Then start the tracer. <var>format</var> and the arguments 
are the same as for <strong>printf</strong>(2). Always returns <code>FALSE</code>.</dd>
<dt class="pubdef"><a id="PL_fatal_error()"><var>int</var> <strong>PL_fatal_error</strong>(<var>format, 
a1, ...</var>)</a></dt>
<dd class="defbody">
As <a class="func" href="foreigninclude.html#PL_warning()">PL_warning()</a>, 
but using <code>[FATAL ERROR: at &lt;<var>time</var>&gt; ...]</code> and 
terminates the process after cleanup using <b>abort()</b>. If the 
process is a Windows GUI application it uses a message box. This 
function should be used if an unrepairable error is detected. For 
example, Prolog uses it to signal it cannot find the compiled Prolog 
startup or memory allocation fails in a place from where we cannot 
gracefully generate an exception.<sup class="fn">233<span class="fn-text">Currently 
most memory allocation except for most of the big allocations such as 
for the Prolog stacks.</span></sup></dd>
<dt class="pubdef"><a id="PL_system_error()"><var>int</var> <strong>PL_system_error</strong>(<var>format, 
a1, ...</var>)</a></dt>
<dd class="defbody">
As <a class="func" href="foreigninclude.html#PL_fatal_error()">PL_fatal_error()</a>, 
but using <code>[ERROR: system error:]</code> and provides additional 
technical details such as the thread that trapped the error and 
backtrace of the C and Prolog stacks. This function should be used to 
when an unexpected and unrepairable error is detected. For example, 
Prolog uses this after it finds an inconsistency in the data during 
garbage collection.</dd>
<dt class="pubdef"><a id="PL_api_error()"><var>int</var> <strong>PL_api_error</strong>(<var>format, 
a1, ...</var>)</a></dt>
<dd class="defbody">
As <a class="func" href="foreigninclude.html#PL_system_error()">PL_system_error()</a>, 
but using <code>[ERROR: API error:]</code> and provides additional 
technical details such as the thread that trapped the error and 
backtrace of the C and Prolog stacks. This function is used by the C&nbsp;API 
and may be used by other language bindings to report invalid use of the 
API. This function causes the process to be terminated.</dd>
<dt class="pubdef"><a id="PL_print_message()"><var>bool</var> <strong>PL_print_message</strong>(<var>atom_t 
severity, ...</var>)</a></dt>
<dd class="defbody">
Calls <a id="idx:printmessage2:2590"></a><a class="pred" href="printmsg.html#print_message/2">print_message/2</a> 
using a term constructed from the remaining arguments that are passed to <a class="func" href="foreigninclude.html#PL_unify_term()">PL_unify_term()</a>. 
This is similar to setting up a call to <a id="idx:printmessage2:2591"></a><a class="pred" href="printmsg.html#print_message/2">print_message/2</a> 
using <a class="func" href="foreigninclude.html#PL_call_predicate()">PL_call_predicate()</a>, 
except that it saves and restores possibly pending exceptions and 
delayed goals. The <var>severity</var> argument must be valid for
<a id="idx:printmessage2:2592"></a><a class="pred" href="printmsg.html#print_message/2">print_message/2</a>.
</dd>
</dl>

<p><h3 id="sec:foreign-control-prolog"><a id="sec:12.4.20"><span class="sec-nr">12.4.20</span> <span class="sec-title">Environment 
Control from Foreign Code</span></a></h3>

<a id="sec:foreign-control-prolog"></a>

<dl class="latex">
<dt class="pubdef"><a id="PL_action()"><var>int</var> <strong>PL_action</strong>(<var>int, 
...</var>)</a></dt>
<dd class="defbody">
Perform some action on the Prolog system. <var>int</var> describes the 
action. Remaining arguments depend on the requested action. The actions 
are listed below:

<dl class="latex">
<dt><strong>PL_ACTION_TRACE</strong></dt>
<dd class="defbody">
Start Prolog tracer (<a id="idx:trace0:2593"></a><a class="pred" href="debugger.html#trace/0">trace/0</a>). 
Requires no arguments.</dd>
<dt><strong>PL_ACTION_DEBUG</strong></dt>
<dd class="defbody">
Switch on Prolog debug mode (<a id="idx:debug0:2594"></a><a class="pred" href="debugger.html#debug/0">debug/0</a>). 
Requires no arguments.</dd>
<dt><strong>PL_ACTION_BACKTRACE</strong></dt>
<dd class="defbody">
Print backtrace on current output stream. The argument (an <code>int</code>) 
is the number of frames printed.</dd>
<dt><strong>PL_ACTION_HALT</strong></dt>
<dd class="defbody">
Halt Prolog execution. This action should be called rather than Unix
<b>exit()</b> to give Prolog the opportunity to clean up. This call does 
not return. The argument (an <code>int</code>) is the exit code. See <a id="idx:halt1:2595"></a><a class="pred" href="toplevel.html#halt/1">halt/1</a>.</dd>
<dt><strong>PL_ACTION_ABORT</strong></dt>
<dd class="defbody">
Generate a Prolog abort (<a id="idx:abort0:2596"></a><a class="pred" href="toplevel.html#abort/0">abort/0</a>). 
This call does not return. Requires no arguments.</dd>
<dt><strong>PL_ACTION_BREAK</strong></dt>
<dd class="defbody">
Create a standard Prolog break environment (<a id="idx:break0:2597"></a><a class="pred" href="toplevel.html#break/0">break/0</a>). 
Returns after the user types the end-of-file character. Requires no 
arguments.</dd>
<dt><strong>PL_ACTION_GUIAPP</strong></dt>
<dd class="defbody">
Windows: Used to indicate to the kernel that the application is a GUI 
application if the argument is not 0, and a console application if the 
argument is 0. If a fatal error occurs, the system uses a windows 
messagebox to report this on a GUI application, and otherwise simply 
prints the error and exits.</dd>
<dt><strong>PL_ACTION_TRADITIONAL</strong></dt>
<dd class="defbody">
Same effect as using <strong>--traditional</strong>. Must be called
<em>before</em> <a class="func" href="foreigninclude.html#PL_initialise()">PL_initialise()</a>.</dd>
<dt><strong>PL_ACTION_WRITE</strong></dt>
<dd class="defbody">
Write the argument, a <code>char *</code> to the current output stream.</dd>
<dt><strong>PL_ACTION_FLUSH</strong></dt>
<dd class="defbody">
Flush the current output stream. Requires no arguments.</dd>
<dt><strong>PL_ACTION_ATTACH_CONSOLE</strong></dt>
<dd class="defbody">
Attach a console to a thread if it does not have one. See
<a id="idx:attachconsole0:2598"></a><a class="pred" href="thutil.html#attach_console/0">attach_console/0</a>.</dd>
<dt><strong>PL_GMP_SET_ALLOC_FUNCTIONS</strong></dt>
<dd class="defbody">
Takes an integer argument. If <code>TRUE</code>, the GMP allocations are 
immediately bound to the Prolog functions. If <code>FALSE</code>, 
SWI-Prolog will never rebind the GMP allocation functions. See
<b>mp_set_memory_functions()</b> in the GMP documentation. The action 
returns
<code>FALSE</code> if there is no GMP support or GMP is already 
initialised.
</dd>
</dl>

</dd>
<dt class="pubdef"><a id="PL_version_info()"><var>unsigned int</var> <strong>PL_version_info</strong>(<var>int 
key</var>)</a></dt>
<dd class="defbody">
Query version information. This function may be called before
<a class="func" href="foreigninclude.html#PL_initialise()">PL_initialise()</a>. 
If the key is unknown the function returns 0. See <a class="sec" href="abi-versions.html#sec:2.21">section 
2.21</a> for a more in-depth discussion on binary compatibility. 
Versions upto SWI-Prolog 8.5.2 defined this function as <b>PL_version()</b>. 
It was renamed to avoid a conflict with Perl affecting
<a class="url" href="https://github.com/salva/p5-Language-Prolog-Yaswi">Yaswi</a>.
<b>PL_version()</b> is provided as a macro for compatibility. Defined 
keys are:

<dl class="latex">
<dt><strong>PL_VERSION_SYSTEM</strong></dt>
<dd class="defbody">
SWI-Prolog version as <var>10,000 &times; major + 100 &times; minor + 
patch</var>.
</dd>
<dt><strong>PL_VERSION_FLI</strong></dt>
<dd class="defbody">
Incremented if the foreign interface defined in this chapter changes in 
a way that breaks backward compatibility.
</dd>
<dt><strong>PL_VERSION_REC</strong></dt>
<dd class="defbody">
Incremented if the binary representation of terms as used by
<a class="func" href="foreigninclude.html#PL_record_external()">PL_record_external()</a> 
and <a id="idx:fastwrite2:2599"></a><a class="pred" href="IO.html#fast_write/2">fast_write/2</a> 
changes.
</dd>
<dt><strong>PL_VERSION_QLF</strong></dt>
<dd class="defbody">
Incremented if the QLF file format changes.
</dd>
<dt><strong>PL_VERSION_QLF_LOAD</strong></dt>
<dd class="defbody">
Represents the oldest loadable QLF file format version.
</dd>
<dt><strong>PL_VERSION_VM</strong></dt>
<dd class="defbody">
A hash that represents the VM instructions and their arguments.
</dd>
<dt><strong>PL_VERSION_BUILT_IN</strong></dt>
<dd class="defbody">
A hash that represents the names, arities and properties of all built-in 
predicates defined in C. If this function is called before <a class="func" href="foreigninclude.html#PL_initialise()">PL_initialise()</a> 
it returns 0.
</dd>
</dl>

</dd>
</dl>

<p><h3 id="sec:foreign-query"><a id="sec:12.4.21"><span class="sec-nr">12.4.21</span> <span class="sec-title">Querying 
Prolog</span></a></h3>

<a id="sec:foreign-query"></a>

<dl class="latex">
<dt class="pubdef"><a id="PL_query()"><var>long</var> <strong>PL_query</strong>(<var>int</var>)</a></dt>
<dd class="defbody">
Obtain status information on the Prolog system. The actual argument type 
depends on the information required. <var>int</var> describes what 
information is wanted.<sup class="fn">234<span class="fn-text">Returning 
pointers and integers as a long is bad style. The signature of this 
function should be changed.</span></sup> The options are given in <a class="tab" href="foreigninclude.html#tab:query">table 
9</a>.
<blockquote><table class="latex frame-box">
<tr><td><code>PL_QUERY_ARGC</code> </td><td>Return an integer holding 
the number of arguments given to Prolog from Unix. </td></tr>
<tr><td><code>PL_QUERY_ARGV</code> </td><td>Return a <code>char **</code> 
holding the argument vector given to Prolog from Unix. </td></tr>
<tr><td><code>PL_QUERY_SYMBOLFILE</code> </td><td>Return a <code>char *</code> 
holding the current symbol file of the running process. </td></tr>
<tr><td><code>PL_MAX_INTEGER</code> </td><td>Return a long, representing 
the maximal integer value represented by a Prolog integer. </td></tr>
<tr><td><code>PL_MIN_INTEGER</code> </td><td>Return a long, representing 
the minimal integer value. </td></tr>
<tr><td><code>PL_QUERY_VERSION</code> </td><td>Return a long, 
representing the version as
<var>10,000 &times; M + 100 &times; m + p</var>, where
<var>M</var> is the major, <var>m</var> the minor version number and <var>p</var> 
the patch level. For example,
<code>20717</code> means <code>2.7.17</code>. </td></tr>
<tr><td><code>PL_QUERY_ENCODING</code> </td><td>Return the default 
stream encoding of Prolog (of type <code>IOENC</code>). </td></tr>
<tr><td><code>PL_QUERY_USER_CPU</code> </td><td>Get amount of user CPU 
time of the process in milliseconds. </td></tr>
</table>
</blockquote>
<div class="caption"><b>Table 9 : </b><a class="func" href="foreigninclude.html#PL_query()">PL_query()</a> 
options</div>
<a id="tab:query"></a>
</dd>
</dl>

<p><h3 id="sec:foreign-register-predicate"><a id="sec:12.4.22"><span class="sec-nr">12.4.22</span> <span class="sec-title">Registering 
Foreign Predicates</span></a></h3>

<a id="sec:foreign-register-predicate"></a>

<dl class="latex">
<dt class="pubdef"><a id="PL_register_foreign_in_module()"><var>int</var> <strong>PL_register_foreign_in_module</strong>(<var>char 
*mod, char *name, int arity, foreign_t (*f)(), int flags, ...</var>)</a></dt>
<dd class="defbody">
Register the C function <var>f</var> to implement a Prolog predicate. 
After this call returns successfully a predicate with name <var>name</var> 
(a
<code>char *</code>) and arity <var>arity</var> (a C <code>int</code>) 
is created in module <var>mod</var>. If <var>mod</var> is <code>NULL</code>, 
the predicate is created in the module of the calling context, or if no 
context is present in the module <code>user</code>.

<p>When called in Prolog, Prolog will call <var>function</var>. <var>flags</var> 
form a bitwise <em>or</em>&rsquo;ed list of options for the 
installation. These are:

<p><table class="latex frame-box">
<tr><td><code>PL_FA_META</code> </td><td>Provide meta-predicate info 
(see below) </td></tr>
<tr><td><code>PL_FA_TRANSPARENT</code> </td><td>Predicate is module 
transparent (deprecated) </td></tr>
<tr><td><code>PL_FA_NONDETERMINISTIC</code> </td><td>Predicate is 
non-deterministic. See also <a class="func" href="foreigninclude.html#PL_retry()">PL_retry()</a>. </td></tr>
<tr><td><code>PL_FA_NOTRACE</code> </td><td>Predicate cannot be seen in 
the tracer </td></tr>
<tr><td><code>PL_FA_VARARGS</code> </td><td>Use alternative calling 
convention. </td></tr>
</table>

<p>If <code>PL_FA_META</code> is provided, <a class="func" href="foreigninclude.html#PL_register_foreign_in_module()">PL_register_foreign_in_module()</a> 
takes one extra argument. This argument is of type <code>const char*</code>. 
This string must be exactly as long as the number of arguments of the 
predicate and filled with characters from the set <code>0-9:^-+?</code>. 
See
<a id="idx:metapredicate1:2600"></a><a class="pred" href="metapred.html#meta_predicate/1">meta_predicate/1</a> 
for details. <code>PL_FA_TRANSPARENT</code> is implied if at least one 
meta-argument is provided (<code>0-9:^</code>). Note that meta-arguments 
are <em>not always</em> passed as &lt;<var>module</var>&gt;:&lt;<var>term</var>&gt;. 
Always use <a class="func" href="foreigninclude.html#PL_strip_module()">PL_strip_module()</a> 
to extract the module and plain term from a meta-argument.<sup class="fn">235<span class="fn-text">It 
is encouraged to pass an additional <code>NULL</code> pointer for 
non-meta-predicates.</span></sup>

<p>Predicates may be registered either before or after <a class="func" href="foreigninclude.html#PL_initialise()">PL_initialise()</a>. 
When registered before initialisation the registration is recorded and 
executed after installing the system predicates and before loading the 
saved state.

<p>Default calling (i.e. without <code>PL_FA_VARARGS</code>) <var>function</var> 
is passed the same number of <code>term_t</code> arguments as the arity 
of the predicate and, if the predicate is non-deterministic, an extra 
argument of type
<code>control_t</code> (see <a class="sec" href="foreigninclude.html#sec:12.4.1.1">section 
12.4.1.1</a>). If <code>PL_FA_VARARGS</code> is provided, <var>function</var> 
is called with three arguments. The first argument is a <code>term_t</code> 
handle to the first argument. Further arguments can be reached by adding 
the offset (see also
<a class="func" href="foreigntypes.html#PL_new_term_refs()">PL_new_term_refs()</a>). 
The second argument is the arity, which defines the number of valid term 
references in the argument vector. The last argument is used for 
non-deterministic calls. It is currently undocumented and should be 
defined of type <code>void*</code>. Here is an example:

<pre class="code">
static foreign_t
atom_checksum(term_t a0, int arity, void* context)
{ char *s;

  if ( PL_get_atom_chars(a0, &amp;s) )
  { int sum;

    for(sum=0; *s; s++)
      sum += *s&amp;0xff;

    return PL_unify_integer(a0+1, sum&amp;0xff);
  }

  return FALSE;
}

install_t
install()
{ PL_register_foreign("atom_checksum", 2,
                      atom_checksum, PL_FA_VARARGS);
}
</pre>

</dd>
<dt class="pubdef"><a id="PL_register_foreign()"><var>int</var> <strong>PL_register_foreign</strong>(<var>const 
char *name, int arity, foreign_t (*function)(), int flags, ...</var>)</a></dt>
<dd class="defbody">
Same as <a class="func" href="foreigninclude.html#PL_register_foreign_in_module()">PL_register_foreign_in_module()</a>, 
passing <code>NULL</code> for the
<var>module</var>.</dd>
<dt class="pubdef"><a id="PL_register_extensions_in_module()"><var>void</var> <strong>PL_register_extensions_in_module</strong>(<var>const 
char *module, PL_extension *e</var>)</a></dt>
<dd class="defbody">
Register a series of predicates from an array of definitions of the type
<code>PL_extension</code> in the given <var>module</var>. If <var>module</var> 
is
<code>NULL</code>, the predicate is created in the module of the calling 
context, or if no context is present in the module <code>user</code>. 
The <code>PL_extension</code> type is defined as

<pre class="code">
typedef struct PL_extension
{ char          *predicate_name; /* Name of the predicate */
  short         arity;           /* Arity of the predicate */
  pl_function_t function;        /* Implementing functions */
  short         flags;           /* Or of PL_FA_... */
} PL_extension;
</pre>

<p>For details, see <a class="func" href="foreigninclude.html#PL_register_foreign_in_module()">PL_register_foreign_in_module()</a>. 
Here is an example of its usage:

<pre class="code">
static PL_extension predicates[] = {
{ "foo",        1,      pl_foo, 0 },
{ "bar",        2,      pl_bar, PL_FA_NONDETERMINISTIC },
{ NULL,         0,      NULL,   0 }
};

main(int argc, char **argv)
{ PL_register_extensions_in_module("user", predicates);

  if ( !PL_initialise(argc, argv) )
    PL_halt(1);

  ...
}
</pre>

</dd>
<dt class="pubdef"><a id="PL_register_extensions()"><var>void</var> <strong>PL_register_extensions</strong>(<var> 
PL_extension *e</var>)</a></dt>
<dd class="defbody">
Same as <a class="func" href="foreigninclude.html#PL_register_extensions_in_module()">PL_register_extensions_in_module()</a> 
using <code>NULL</code> for the <var>module</var> argument.
</dd>
</dl>

<p><h3 id="sec:foreign-hooks"><a id="sec:12.4.23"><span class="sec-nr">12.4.23</span> <span class="sec-title">Foreign 
Code Hooks</span></a></h3>

<a id="sec:foreign-hooks"></a>

<p>For various specific applications some hooks are provided.

<dl class="latex">
<dt class="pubdef"><a id="PL_dispatch_hook()"><var>PL_dispatch_hook_t</var> <strong>PL_dispatch_hook</strong>(<var>PL_dispatch_hook_t</var>)</a></dt>
<dd class="defbody">
If this hook is not NULL, this function is called when reading from the 
terminal. It is supposed to dispatch events when SWI-Prolog is connected 
to a window environment. It can return two values:
<code>PL_DISPATCH_INPUT</code> indicates Prolog input is available on 
file descriptor 0 or <code>PL_DISPATCH_TIMEOUT</code> to indicate a 
timeout. The old hook is returned. The type <code>PL_dispatch_hook_t</code> 
is defined as:

<pre class="code">
typedef int  (*PL_dispatch_hook_t)(void);
</pre>

</dd>
<dt class="pubdef"><a id="PL_abort_hook()"><var>void</var> <strong>PL_abort_hook</strong>(<var>PL_abort_hook_t</var>)</a></dt>
<dd class="defbody">
Install a hook when <a id="idx:abort0:2601"></a><a class="pred" href="toplevel.html#abort/0">abort/0</a> 
is executed. SWI-Prolog <a id="idx:abort0:2602"></a><a class="pred" href="toplevel.html#abort/0">abort/0</a> 
is implemented using C <b>setjmp()</b>/<b>longjmp()</b> construct. The 
hooks are executed in the reverse order of their registration after the <b>longjmp()</b> 
took place and before the Prolog top level is reinvoked. The type
<code>PL_abort_hook_t</code> is defined as:

<pre class="code">
typedef void (*PL_abort_hook_t)(void);
</pre>

</dd>
<dt class="pubdef"><a id="PL_abort_unhook()"><var>int</var> <strong>PL_abort_unhook</strong>(<var>PL_abort_hook_t</var>)</a></dt>
<dd class="defbody">
Remove a hook installed with <a class="func" href="foreigninclude.html#PL_abort_hook()">PL_abort_hook()</a>. 
Returns <code>FALSE</code> if no such hook is found, <code>TRUE</code> 
otherwise.</dd>
<dt class="pubdef"><a id="PL_on_halt()"><var>void</var> <strong>PL_on_halt</strong>(<var>int 
(*f)(int, void *), void *closure</var>)</a></dt>
<dd class="defbody">
Register the function <var>f</var> to be called if SWI-Prolog is halted. 
The function is called with two arguments: the exit code of the process 
(0 if this cannot be determined) and the <var>closure</var> argument 
passed to the <a class="func" href="foreigninclude.html#PL_on_halt()">PL_on_halt()</a> 
call. Handlers <em>must</em> return 0. Other return values are reserved 
for future use. See also <a id="idx:athalt1:2603"></a><a class="pred" href="consulting.html#at_halt/1">at_halt/1</a>.<sup class="fn">bug<span class="fn-text">Although 
both <a class="func" href="foreigninclude.html#PL_on_halt()">PL_on_halt()</a> 
and <a id="idx:athalt1:2604"></a><a class="pred" href="consulting.html#at_halt/1">at_halt/1</a> 
are called in FIFO order, <em>all</em> <a id="idx:athalt1:2605"></a><a class="pred" href="consulting.html#at_halt/1">at_halt/1</a> 
handlers are called before <em>all</em> <a class="func" href="foreigninclude.html#PL_on_halt()">PL_on_halt()</a> 
handlers.</span></sup> These handlers are called <em>before</em> system 
cleanup and can therefore access all normal Prolog resources. See also <a class="func" href="foreigninclude.html#PL_exit_hook()">PL_exit_hook()</a>.</dd>
<dt class="pubdef"><a id="PL_exit_hook()"><var>void</var> <strong>PL_exit_hook</strong>(<var>int 
(*f)(int, void *), void *closure</var>)</a></dt>
<dd class="defbody">
Similar to <a class="func" href="foreigninclude.html#PL_on_halt()">PL_on_halt()</a>, 
but the hooks are executed by <a class="func" href="foreigninclude.html#PL_halt()">PL_halt()</a> 
instead of <a class="func" href="foreigninclude.html#PL_cleanup()">PL_cleanup()</a> 
just before calling <b>exit()</b>.</dd>
<dt class="pubdef"><a id="PL_agc_hook()"><var>PL_agc_hook_t</var> <strong>PL_agc_hook</strong>(<var>PL_agc_hook_t 
new</var>)</a></dt>
<dd class="defbody">
Register a hook with the atom-garbage collector (see
<a id="idx:garbagecollectatoms0:2606"></a><a class="pred" href="memory.html#garbage_collect_atoms/0">garbage_collect_atoms/0</a>) 
that is called on any atom that is reclaimed. The old hook is returned. 
If no hook is currently defined, <code>NULL</code> is returned. The 
argument of the called hook is the atom that is to be garbage collected. 
The return value is an <code>int</code>. If the return value is zero, 
the atom is <b>not</b> reclaimed. The hook may invoke any Prolog 
predicate.

<p>The example below defines a foreign library for printing the garbage 
collected atoms for debugging purposes.

<pre class="code">
#include &lt;SWI-Stream.h&gt;
#include &lt;SWI-Prolog.h&gt;

static int
atom_hook(atom_t a)
{ Sdprintf("AGC: deleting %s\n", PL_atom_chars(a));

  return TRUE;
}

static PL_agc_hook_t old;

install_t
install()
{ old = PL_agc_hook(atom_hook);
}

install_t
uninstall()
{ PL_agc_hook(old);
}
</pre>

<p></dd>
</dl>

<p><h3 id="sec:foreigndata"><a id="sec:12.4.24"><span class="sec-nr">12.4.24</span> <span class="sec-title">Storing 
foreign data</span></a></h3>

<a id="sec:foreigndata"></a>

<p>When combining foreign code with Prolog, it can be necessary to make 
data represented in the foreign language available to Prolog. For 
example, to pass it to another foreign function. At the end of this 
section, there is a partial implementation of using foreign functions to 
manage bit-vectors. Another example is the SGML/XML library that manages 
a&lsquo;parser&rsquo;object, an object that represents the current state 
of the parser and that can be directed to perform actions such as 
parsing a document or make queries about the document content.

<p>This section provides some hints for handling foreign data in Prolog. 
There are four options for storing such data:

<p>
<ul class="latex">
<li><i>Natural Prolog data</i><br>
Uses the representation one would choose if no foreign interface was 
required. For example, a bitvector representing a list of small integers 
can be represented as a Prolog list of integers.

<p>
<li><i>Opaque packed data on the stacks</i><br>
It is possible to represent the raw binary representation of the foreign 
object as a Prolog string (see <a class="sec" href="string.html#sec:5.2">section 
5.2</a>). Strings may be created from foreign data using <a class="func" href="foreigninclude.html#PL_put_string_nchars()">PL_put_string_nchars()</a> 
and retrieved using
<a class="func" href="foreigninclude.html#PL_get_string_chars()">PL_get_string_chars()</a>. 
It is good practice to wrap the string in a compound term with arity 1, 
so Prolog can identify the type. The hook
<a id="idx:portray1:2607"></a><a class="pred" href="termrw.html#portray/1">portray/1</a> 
rules may be used to streamline printing such terms during development.

<p>
<li><i>Opaque packed data in a blob</i><br>
Similar to the above solution, binary data can be stored in an atom. The 
blob interface (<a class="sec" href="foreigninclude.html#sec:12.4.10">section 
12.4.10</a>) provides additional facilities to assign a type and 
hook-functions that act on creation and destruction of the underlying 
atom.

<p>
<li><i>Natural foreign data, passed as a pointer</i><br>
An alternative is to pass a pointer to the foreign data. Again, the 
pointer is often wrapped in a compound term.
</ul>

<p>The choice may be guided using the following distinctions

<p>
<ul class="latex">
<li><i>Is the data opaque to Prolog</i><br>
With&lsquo;opaque&rsquo;data, we refer to data handled in foreign 
functions, passed around in Prolog, but where Prolog never examines the 
contents of the data itself. If the data is opaque to Prolog, the 
selection will be driven solely by simplicity of the interface and 
performance.

<p>
<li><i>What is the lifetime of the data</i><br>
With&lsquo;lifetime&rsquo;we refer to how it is decided that the object 
is (or can be) destroyed. We can distinguish three cases:

<p>
<ol class="latex">
<li>The object must be destroyed on backtracking and normal Prolog 
garbage collection (i.e., it acts as a normal Prolog term). In this 
case, representing the object as a Prolog string (second option above) 
is the only feasible solution.

<p>
<li>The data must survive Prolog backtracking. This leaves two options. 
One is to represent the object using a pointer and use explicit creation 
and destruction, making the programmer responsible. The alternative is 
to use the blob-interface, leaving destruction to the (atom) garbage 
collector.

<p>
<li>The data lives as during the lifetime of a foreign function that 
implements a predicate. If the predicate is deterministic, foreign 
automatic variables are suitable. If the predicate is non-deterministic, 
the data may be allocated using <b>malloc()</b> and a pointer may be 
passed. See <a class="sec" href="foreigninclude.html#sec:12.4.1.1">section 
12.4.1.1</a>.
</ol>
</ul>

<p><h4 id="sec:foreign-store-data"><a id="sec:12.4.24.1"><span class="sec-nr">12.4.24.1</span> <span class="sec-title">Examples 
for storing foreign data</span></a></h4>

<a id="sec:foreign-store-data"></a>

<p>In this section, we outline some examples, covering typical cases. In 
the first example, we will deal with extending Prolog's data 
representation with integer sets, represented as bit-vectors. Then, we 
discuss the outline of the DDE interface.

<p><b>Integer sets</b> with not-too-far-apart upper- and lower-bounds 
can be represented using bit-vectors. Common set operations, such as 
union, intersection, etc., are reduced to simple <em>and</em>&rsquo;ing 
and
<em>or</em>&rsquo;ing the bit-vectors. This can be done using Prolog's 
unbounded integers.

<p>For really demanding applications, foreign representation will 
perform better, especially time-wise. Bit-vectors are naturally 
expressed using string objects. If the string is wrapped in <code>bitvector/1</code>, 
the lower-bound of the vector is 0 and the upper-bound is not defined; 
an implementation for getting and putting the sets as well as the union 
predicate for it is below.

<pre class="code">
#include &lt;SWI-Prolog.h&gt;

#define max(a, b) ((a) &gt; (b) ? (a) : (b))
#define min(a, b) ((a) &lt; (b) ? (a) : (b))

static functor_t FUNCTOR_bitvector1;

static int
get_bitvector(term_t in, int *len, unsigned char **data)
{ if ( PL_is_functor(in, FUNCTOR_bitvector1) )
  { term_t a = PL_new_term_ref();

    PL_get_arg(1, in, a);
    return PL_get_string(a, (char **)data, len);
  }

  PL_fail;
}

static int
unify_bitvector(term_t out, int len, const unsigned char *data)
{ if ( PL_unify_functor(out, FUNCTOR_bitvector1) )
  { term_t a = PL_new_term_ref();

    PL_get_arg(1, out, a);

    return PL_unify_string_nchars(a, len, (const char *)data);
  }

  PL_fail;
}

static foreign_t
pl_bitvector_union(term_t t1, term_t t2, term_t u)
{ unsigned char *s1, *s2;
  int l1, l2;

  if ( get_bitvector(t1, &amp;l1, &amp;s1) &amp;&amp;
       get_bitvector(t2, &amp;l2, &amp;s2) )
  { int l = max(l1, l2);
    unsigned char *s3 = alloca(l);

    if ( s3 )
    { int n;
      int ml = min(l1, l2);

      for(n=0; n&lt;ml; n++)
        s3[n] = s1[n] | s2[n];
      for( ; n &lt; l1; n++)
        s3[n] = s1[n];
      for( ; n &lt; l2; n++)
        s3[n] = s2[n];

      return unify_bitvector(u, l, s3);
    }

    return PL_warning("Not enough memory");
  }

  PL_fail;
}


install_t
install()
{ PL_register_foreign("bitvector_union", 3, pl_bitvector_union, 0);

  FUNCTOR_bitvector1 = PL_new_functor(PL_new_atom("bitvector"), 1);
}
</pre>

<p><b>The DDE interface</b> (see <a class="sec" href="DDE.html#sec:4.44">section 
4.44</a>) represents another common usage of the foreign interface: 
providing communication to new operating system features. The DDE 
interface requires knowledge about active DDE server and client 
channels. These channels contains various foreign data types. Such an 
interface is normally achieved using an open/close protocol that creates 
and destroys a <em>handle</em>. The handle is a reference to a foreign 
data structure containing the relevant information.

<p>There are a couple of possibilities for representing the handle. The 
choice depends on responsibilities and debugging facilities. The 
simplest approach is to use <a class="func" href="foreigninclude.html#PL_unify_pointer()">PL_unify_pointer()</a> 
and <a class="func" href="foreigninclude.html#PL_get_pointer()">PL_get_pointer()</a>. 
This approach is fast and easy, but has the drawbacks of (untyped) 
pointers: there is no reliable way to detect the validity of the 
pointer, nor to verify that it is pointing to a structure of the desired 
type. The pointer may be wrapped into a compound term with arity 1 
(i.e., <code>dde_channel(&lt;<var>Pointer</var>&gt;)</code>), making the 
type-problem less serious.

<p>Alternatively (used in the DDE interface), the interface code can 
maintain a (preferably variable length) array of pointers and return the 
index in this array. This provides better protection. Especially for 
debugging purposes, wrapping the handle in a compound is a good 
suggestion.

<p><h3 id="sec:embedded"><a id="sec:12.4.25"><span class="sec-nr">12.4.25</span> <span class="sec-title">Embedding 
SWI-Prolog in other applications</span></a></h3>

<a id="sec:embedded"></a>

<p>With embedded Prolog we refer to the situation where the&lsquo;main&rsquo;program 
is not the Prolog application. Prolog is sometimes embedded in C, C++, 
Java or other languages to provide logic based services in a larger 
application. Embedding loads the Prolog engine as a library to the 
external language. Prolog itself only provides for embedding in the C 
language (compatible with C++). Embedding in Java is achieved using JPL 
using a C-glue between the Java and Prolog C interfaces.

<p>The most simple embedded program is below. The interface function
<a class="func" href="foreigninclude.html#PL_initialise()">PL_initialise()</a> <b>must</b> 
be called before any of the other SWI-Prolog foreign language functions 
described in this chapter, except for
<b>PL_initialise_hook()</b>, <a class="func" href="foreigninclude.html#PL_new_atom()">PL_new_atom()</a>, <a class="func" href="foreigninclude.html#PL_new_functor()">PL_new_functor()</a> 
and
<a class="func" href="foreigninclude.html#PL_register_foreign()">PL_register_foreign()</a>. <a class="func" href="foreigninclude.html#PL_initialise()">PL_initialise()</a> 
interprets all the command line arguments, except for the <strong>-t</strong> <var>toplevel</var> 
flag that is interpreted by <a class="func" href="foreigninclude.html#PL_toplevel()">PL_toplevel()</a>.

<pre class="code">
int
main(int argc, char **argv)
{ if ( !PL_initialise(argc, argv) )
    PL_halt(1);

  PL_halt(PL_toplevel() ? 0 : 1);
}
</pre>

<dl class="latex">
<dt class="pubdef"><a id="PL_initialise()"><var>int</var> <strong>PL_initialise</strong>(<var>int 
argc, char **argv</var>)</a></dt>
<dd class="defbody">
Initialises the SWI-Prolog heap and stacks, restores the Prolog state, 
loads the system and personal initialisation files, runs the <a id="idx:initialization1:2608"></a><a class="pred" href="consulting.html#initialization/1">initialization/1</a> 
hooks and finally runs the initialization goals registered using <strong>-g</strong> <var>goal</var>.

<p>Special consideration is required for <code>argv[0]</code>. On <b>Unix</b>, 
this argument passes the part of the command line that is used to locate 
the executable. Prolog uses this to find the file holding the running 
executable. The <b>Windows</b> version uses this to find a <em>module</em> 
of the running executable. If the specified module cannot be found, it 
tries the module <code>libswipl.dll</code>, containing the Prolog 
runtime kernel. In all these cases, the resulting file is used for two 
purposes:

<p>
<ul class="latex">
<li>See whether a Prolog saved state is appended to the file. If this is 
the case, this state will be loaded instead of the default <code>boot.prc</code> 
file from the SWI-Prolog home directory. See also <a id="idx:qsaveprogram12:2609"></a><a class="pred" href="saved-states.html#qsave_program/1">qsave_program/[1,2]</a> 
and <a class="sec" href="plld.html#sec:12.5">section 12.5</a>.
<li>Find the Prolog home directory. This process is described in detail 
in <a class="sec" href="findhome.html#sec:12.6">section 12.6</a>.
</ul>

<p><a class="func" href="foreigninclude.html#PL_initialise()">PL_initialise()</a> 
returns 1 if all initialisation succeeded and 0 otherwise.<sup class="fn">bug<span class="fn-text">Various 
fatal errors may cause <a class="func" href="foreigninclude.html#PL_initialise()">PL_initialise()</a> 
to call <a class="func" href="foreigninclude.html#PL_halt()">PL_halt(1)</a>, 
preventing it from returning at all.</span></sup>

<p>In most cases, <var>argc</var> and <var>argv</var> will be passed 
from the main program. It is allowed to create your own argument vector, 
provided
<code>argv[0]</code> is constructed according to the rules above. For 
example:

<pre class="code">
int
main(int argc, char **argv)
{ char *av[10];
  int ac = 0;

  av[ac++] = argv[0];
  av[ac++] = "-x";
  av[ac++] = "mystate";
  av[ac]   = NULL;

  if ( !PL_initialise(ac, av) )
    PL_halt(1);
  ...
}
</pre>

<p>Please note that the passed argument vector may be referred from 
Prolog at any time and should therefore be valid as long as the Prolog 
engine is used.

<p>A good setup in Windows is to add SWI-Prolog's <code>bin</code> 
directory to your <code>PATH</code> and either pass a module holding a 
saved state, or
<code>"libswipl.dll"</code> as <code>argv[0]</code>. If the Prolog state 
is attached to a DLL (see the <strong>-dll</strong> option of <b>swipl-ld</b>), 
pass the name of this DLL.</dd>
<dt class="pubdef"><a id="PL_winitialise()"><var>int</var> <strong>PL_winitialise</strong>(<var>int 
argc, wchar_t **argv</var>)</a></dt>
<dd class="defbody">
Wide character version of <a class="func" href="foreigninclude.html#PL_initialise()">PL_initialise()</a>. 
Can be used in Windows combined with the <b>wmain()</b> entry point.</dd>
<dt class="pubdef"><a id="PL_is_initialised()"><var>int</var> <strong>PL_is_initialised</strong>(<var>int 
*argc, char ***argv</var>)</a></dt>
<dd class="defbody">
Test whether the Prolog engine is already initialised. Returns
<code>FALSE</code> if Prolog is not initialised and <code>TRUE</code> 
otherwise. If the engine is initialised and <var>argc</var> is not <code>NULL</code>, 
the argument count used with <a class="func" href="foreigninclude.html#PL_initialise()">PL_initialise()</a> 
is stored in <var>argc</var>. Same for the argument vector <var>argv</var>.</dd>
<dt class="pubdef"><a id="PL_set_resource_db_mem()"><var>int</var> <strong>PL_set_resource_db_mem</strong>(<var>const 
unsigned char *data, size_t size</var>)</a></dt>
<dd class="defbody">
This function must be called at most once and <em>before</em> calling
<a class="func" href="foreigninclude.html#PL_initialise()">PL_initialise()</a>. 
The memory area designated by <var>data</var> and <var>size</var> must 
contain the resource data and be in the format as produced by
<a id="idx:qsaveprogram2:2610"></a><a class="pred" href="saved-states.html#qsave_program/2">qsave_program/2</a>. 
The memory area is accessed by <a class="func" href="foreigninclude.html#PL_initialise()">PL_initialise()</a> 
as well as calls to <a id="idx:openresource3:2611"></a><a class="pred" href="program-resources.html#open_resource/3">open_resource/3</a>.<sup class="fn">236<span class="fn-text">This 
implies that the data must remain accessible during the lifetime of the 
process if <a id="idx:openresource3:2612"></a><a class="pred" href="program-resources.html#open_resource/3">open_resource/3</a> 
is used. Future versions may provide a function to detach the resource 
database and cause <a id="idx:openresource3:2613"></a><a class="pred" href="program-resources.html#open_resource/3">open_resource/3</a> 
to raise an exception.</span></sup>

<p>For example, we can include the bootstrap data into an embedded 
executable using the steps below. The advantage of this approach is that 
it is fully supported by any OS and you obtain a single file executable.

<p>
<ol class="latex">
<li>Create a saved state using <a id="idx:qsaveprogram2:2614"></a><a class="pred" href="saved-states.html#qsave_program/2">qsave_program/2</a> 
or

<pre class="code">
% swipl -o state -c file.pl ...
</pre>

<p>
<li>Create a C source file from the state using e.g., the Unix utility <b>xxd</b>(1):

<pre class="code">
% xxd -i state &gt; state.h
</pre>

<p>
<li>Embed Prolog as in the example below. Instead of calling the 
toplevel you probably want to call your application code.

<pre class="code">
#include &lt;SWI-Prolog.h&gt;
#include "state.h"

int
main(int argc, char **argv)
{ if ( !PL_set_resource_db_mem(state, state_len) ||
       !PL_initialise(argc, argv) )
    PL_halt(1);

  return PL_toplevel();
}
</pre>

<p>
</ol>

<p>Alternative to <b>xxd</b>, it is possible to use inline assembler, 
e.g. the <b>gcc</b> <code>incbin</code> instruction. Code for
<b>gcc</b> was provided by Roberto Bagnara on the SWI-Prolog 
mailinglist. Given the state in a file <code>state</code>, create the 
following assembler program:

<pre class="code">
        .globl _state
        .globl _state_end
_state:
        .incbin "state"
_state_end:
</pre>

<p>Now include this as follows:

<pre class="code">
#include &lt;SWI-Prolog.h&gt;

#if __linux
#define STATE _state
#define STATE_END _state_end
#else
#define STATE state
#define STATE_END state_end
#endif

extern unsigned char STATE[];
extern unsigned char STATE_END[];

int
main(int argc, char **argv)
{ if ( !PL_set_resource_db_mem(STATE, STATE_END - STATE) ||
       !PL_initialise(argc, argv) )
    PL_halt(1);
  return PL_toplevel();
}
</pre>

<p>As Jose Morales pointed at
<a class="url" href="https://github.com/graphitemaster/incbin">https://github.com/graphitemaster/incbin</a>, 
which contains a portability layer on top of the above idea.</dd>
<dt class="pubdef"><a id="PL_toplevel()"><var>int</var> <strong>PL_toplevel</strong>(<var></var>)</a></dt>
<dd class="defbody">
Runs the goal of the <strong>-t</strong> <var>toplevel</var> switch 
(default <a id="idx:prolog0:2615"></a><a class="pred" href="toplevel.html#prolog/0">prolog/0</a>) 
and returns 1 if successful, 0 otherwise.</dd>
<dt class="pubdef"><a id="PL_cleanup()"><var>int</var> <strong>PL_cleanup</strong>(<var>int 
status_and_flags</var>)</a></dt>
<dd class="defbody">
This function may be called instead of <a class="func" href="foreigninclude.html#PL_halt()">PL_halt()</a> 
to cleanup Prolog without exiting the process. It performs the reverse 
of
<a class="func" href="foreigninclude.html#PL_initialise()">PL_initialise()</a>. 
It runs the <a class="func" href="foreigninclude.html#PL_on_halt()">PL_on_halt()</a> 
and <a id="idx:athalt1:2616"></a><a class="pred" href="consulting.html#at_halt/1">at_halt/1</a> 
handlers, closes all streams (except for the <em>standard I/O</em> 
streams, which are flushed only), restores all signal handlers and 
reclaims all memory unless asked not to. <var>status_and_flags</var> 
accepts the following flags:

<dl class="latex">
<dt><b><code>PL_CLEANUP_NO_RECLAIM_MEMORY</code></b></dt>
<dd class="defbody">
Do not reclaim memory. This is the default when called from <a class="func" href="foreigninclude.html#PL_halt()">PL_halt()</a> 
for the release versions because the OS will do so anyway.</dd>
<dt><b><code>PL_CLEANUP_NO_CANCEL</code></b></dt>
<dd class="defbody">
Do not allow Prolog and foreign <em>halt</em> hooks to cancel the 
cleanup.
</dd>
</dl>

<p>The return value of <a class="func" href="foreigninclude.html#PL_cleanup()">PL_cleanup()</a> 
is one of the following:

<dl class="latex">
<dt><b><code>PL_CLEANUP_CANCELED</code></b></dt>
<dd class="defbody">
A Prolog or foreign <em>halt</em> hook cancelled the cleanup. Note that 
some of the halt hooks may have been executed.</dd>
<dt><b><code>PL_CLEANUP_SUCCESS</code></b></dt>
<dd class="defbody">
Cleanup completed successfully. Unless <code>PL_CLEANUP_NO_RECLAIM_MEMORY</code> 
was specified this implies most of the memory was reclaimed and Prolog 
may be reinitialized in the same process using <a class="func" href="foreigninclude.html#PL_initialise()">PL_initialise()</a>.</dd>
<dt><b><code>PL_CLEANUP_FAILED</code></b></dt>
<dd class="defbody">
Cleanup failed. This happens if the user requested to reclaim all memory 
but this failed because the system was not able to
<em>join</em> all Prolog threads and could therefore not reclaim the 
memory.</dd>
<dt><b><code>PL_CLEANUP_RECURSIVE</code></b></dt>
<dd class="defbody">
<a class="func" href="foreigninclude.html#PL_cleanup()">PL_cleanup()</a> 
was called from a hook called by the cleanup process.
</dd>
</dl>

<p><a class="func" href="foreigninclude.html#PL_cleanup()">PL_cleanup()</a> 
allows deleting and restarting the Prolog system in the same process. In 
versions older than 8.5.9 this did not work. As of version 8.5.9, it 
works for the basic Prolog engine. Many of the plugins that contain 
foreign code do not implement a suitable <em>uninstall</em> handler and 
will leak memory and possibly other resources. Note that shutting Prolog 
down and renitializing it is slow. For almost all scenarios there are 
faster alternatives such as reloading modified code, using <em>temporary 
modules</em>, using <em>threads</em>, etc.</dd>
<dt class="pubdef"><a id="PL_cleanup_fork()"><var>void</var> <strong>PL_cleanup_fork</strong>(<var></var>)</a></dt>
<dd class="defbody">
Stop intervaltimer that may be running on behalf of <a id="idx:profile1:2617"></a><a class="pred" href="profile.html#profile/1">profile/1</a>. 
The call is intended to be used in combination with <b>fork()</b>:

<pre class="code">
    if ( (pid=fork()) == 0 )
    { PL_cleanup_fork();
      &lt;some exec variation&gt;
    }
</pre>

<p>The call behaves the same on Windows, though there is probably no 
meaningful application.</dd>
<dt class="pubdef"><a id="PL_halt()"><var>int</var> <strong>PL_halt</strong>(<var>int 
status</var>)</a></dt>
<dd class="defbody">
Clean up the Prolog environment using <a class="func" href="foreigninclude.html#PL_cleanup()">PL_cleanup()</a> 
and if successful call <b>exit()</b> with the status argument. Returns <code>FALSE</code> 
if exit was cancelled by <a class="func" href="foreigninclude.html#PL_cleanup()">PL_cleanup()</a>.
</dd>
</dl>

<p><h4 id="sec:sigembedded"><a id="sec:12.4.25.1"><span class="sec-nr">12.4.25.1</span> <span class="sec-title">Threading, 
Signals and embedded Prolog</span></a></h4>

<a id="sec:sigembedded"></a>

<p>This section applies to Unix-based environments that have signals or 
multithreading. The Windows version is compiled for multithreading, and 
Windows lacks proper signals.

<p>We can distinguish two classes of embedded executables. There are 
small C/C++ programs that act as an interfacing layer around Prolog. 
Most of these programs can be replaced using the normal Prolog 
executable extended with a dynamically loaded foreign extension and in 
most cases this is the preferred route. In other cases, Prolog is 
embedded in a complex application that---like Prolog---wants to control 
the process environment. A good example is Java. Embedding Prolog is 
generally the only way to get these environments together in one process 
image. Java VMs, however, are by nature multithreaded and appear to do 
signal handling (software interrupts).

<p>On Unix systems, SWI-Prolog installs handlers for the following 
signals:

<dl class="latex">
<dt><b>SIGUSR2</b></dt>
<dd>
has an empty signal handler. This signal is sent to a thread after 
sending a thread-signal (see
<a id="idx:threadsignal2:2618"></a><a class="pred" href="threadcom.html#thread_signal/2">thread_signal/2</a>). 
It causes blocking system calls to return with <code>EINTR</code>, which 
gives them the opportunity to react to thread-signals.

<p>In some cases the embedded system and SWI-Prolog may both use
<code>SIGUSR2</code> without conflict. If the embedded system redefines
<code>SIGUSR2</code> with a handler that runs quickly and no harm is 
done in the embedded system due to spurious wakeup when initiated from 
Prolog, there is no problem. If SWI-Prolog is initialised
<em>after</em> the embedded system it will call the handler set by the 
embedded system and the same conditions as above apply. SWI-Prolog's 
handler is a simple function only chaining a possibly previously 
registered handler. SWI-Prolog can handle spurious
<code>SIGUSR2</code> signals.</dd>
<dt><b>SIGINT</b></dt>
<dd>
is used by the top level to activate the tracer (typically bound to 
control-C). The first control-C posts a request for starting the tracer 
in a safe, synchronous fashion. If control-C is hit again before the 
safe route is executed, it prompts the user whether or not a forced 
interrupt is desired.</dd>
<dt><b>SIGTERM, SIGABRT and SIGQUIT</b></dt>
<dd>
are caught to cleanup before killing the process again using the same 
signal.</dd>
<dt><b>SIGSEGV, SIGILL, SIGBUS, SIGFPE and SIGSYS</b></dt>
<dd>
are caught by to print a backtrace before killing the process again 
using the same signal.</dd>
<dt><b>SIGHUP</b></dt>
<dd>
is caught and causes the process to exit with status 2 after cleanup.
</dd>
</dl>

<p>The <strong>--no-signals</strong> option can be used to inhibit all 
signal processing except for <code>SIGUSR2</code>. The handling of <code>SIGUSR2</code> 
is vital for dealing with blocking system call in threads. The used 
signal may be changed using the <strong>--sigalert=NUM</strong> option 
or disabled using <code>--sigalert=0</code>.

<p></body></html>