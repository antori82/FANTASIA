<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
<title>SWI-Prolog 9.2.9 Reference Manual: Section 10.3</title><link rel="home" href="index.html">
<link rel="contents" href="Contents.html">
<link rel="index" href="DocIndex.html">
<link rel="summary" href="summary.html">
<link rel="previous" href="thmonitor.html">
<link rel="next" href="threadsync.html">

<style type="text/css">

/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef, dt.multidef
{ color: #fff;
padding: 2px 10px 0px 10px;
margin-bottom: 5px;
font-size: 18px;
vertical-align: middle;
overflow: hidden;
}

dt.pubdef { background-color: #0c3d6e; }
dt.multidef { background-color: #ef9439; }

.bib dd
{ margin-bottom: 1em;
}

.bib dt
{ float: left;
margin-right: 1.3ex;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{
}

span.sec-title
{
}

span.pred-ext
{ font-weight: bold;
}

span.pred-tag
{ float: right;
padding-top: 0.2em;
font-size: 80%;
font-style: italic;
color: #fff;
}

div.caption
{ width: 80%;
margin: auto;
text-align:center;
}

/* Footnotes */
.fn {
color: red;
font-size: 70%;
}

.fn-text, .fnp {
position: absolute;
top: auto;
left: 10%;
border: 1px solid #000;
box-shadow: 5px 5px 5px #888;
display: none;
background: #fff;
color: #000;
margin-top: 25px;
padding: 8px 12px;
font-size: larger;
}

sup:hover span.fn-text
{ display: block;
}

/* Lists */

dl.latex
{ margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.latex dl.latex dd.defbody
{ margin-bottom: 0.5ex;
}

/* PlDoc Tags */

dl.tags
{ font-size: 90%;
margin-left: 5ex;
margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.tags dt
{ margin-left: 0pt;
font-weight: bold;
}

dl.tags dd
{ margin-left: 3ex;
}

td.param
{ font-style: italic;
font-weight: bold;
}

/* Index */

dt.index-sep
{ font-weight: bold;
font-size: +1;
margin-top: 1ex;
}

/* Tables */

table.center
{ margin: auto;
}

table.latex
{ border-collapse:collapse;
}

table.latex tr
{ vertical-align: text-top;
}

table.latex td,th
{ padding: 2px 1em;
}

table.latex tr.hline td,th
{ border-top: 1px solid black;
}

table.frame-box
{ border: 2px solid black;
}

</style>
</head>
<body style="background:white">
<div class="navigate"><a class="nav" href="index.html"><img src="home.gif" alt="Home"></a>
<a class="nav" href="Contents.html"><img src="index.gif" alt="Contents"></a>
<a class="nav" href="DocIndex.html"><img src="yellow_pages.gif" alt="Index"></a>
<a class="nav" href="summary.html"><img src="info.gif" alt="Summary"></a>
<a class="nav" href="thmonitor.html"><img src="prev.gif" alt="Previous"></a>
<a class="nav" href="threadsync.html"><img src="next.gif" alt="Next"></a>
</div>
<h2 id="sec:threadcom"><a id="sec:10.3"><span class="sec-nr">10.3</span> <span class="sec-title">Thread 
communication</span></a></h2>

<a id="sec:threadcom"></a>

<p><h3 id="sec:msgqueue"><a id="sec:10.3.1"><span class="sec-nr">10.3.1</span> <span class="sec-title">Message 
queues</span></a></h3>

<a id="sec:msgqueue"></a>

<p>Prolog threads can exchange data using dynamic predicates, database 
records, and other globally shared data. These provide no suitable means 
to wait for data or a condition as they can only be checked in an 
expensive polling loop. <em>Message queues</em> provide a means for 
threads to wait for data or conditions without using the CPU.

<p>Each thread has a message queue attached to it that is identified by 
the thread. Additional queues are created using <a id="idx:messagequeuecreate1:2327"></a><a class="pred" href="threadcom.html#message_queue_create/1">message_queue_create/1</a>. 
Explicitly created queues come in two flavours. When given an
<em>alias</em>, they must be destroyed by the user. <em>Anonymous</em> 
message queues are identified by a <em>blob</em> (see <a class="sec" href="foreigninclude.html#sec:12.4.10">section 
12.4.10</a>) and subject to garbage collection.

<dl class="latex">
<dt class="pubdef"><a id="thread_send_message/2"><strong>thread_send_message</strong>(<var>+QueueOrThreadId, 
+Term</var>)</a></dt>
<dd class="defbody">
Place <var>Term</var> in the given queue or default queue of the 
indicated thread (which can even be the message queue of itself, see
<a id="idx:threadself1:2328"></a><a class="pred" href="threadcreate.html#thread_self/1">thread_self/1</a>). 
Any term can be placed in a message queue, but note that the term is 
copied to the receiving thread and variable bindings are thus lost. This 
call returns immediately.

<p>If more than one thread is waiting for messages on the given queue 
and at least one of these is waiting with a partially instantiated
<var>Term</var>, the waiting threads are <em>all</em> sent a wake-up 
signal, starting a rush for the available messages in the queue. This 
behaviour can seriously harm performance with many threads waiting on 
the same queue as all-but-the-winner perform a useless scan of the 
queue. If there is only one waiting thread or all waiting threads wait 
with an unbound variable, an arbitrary thread is restarted to scan the 
queue.<sup class="fn">200<span class="fn-text">See the documentation for 
the POSIX thread functions <b>pthread_cond_signal()</b> v.s. <b>pthread_cond_broadcast()</b> 
for background information.</span></sup></dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="thread_send_message/3"><strong>thread_send_message</strong>(<var>+Queue, 
+Term, +Options</var>)</a></dt>
<dd class="defbody">
As <a id="idx:threadsendmessage2:2329"></a><a class="pred" href="threadcom.html#thread_send_message/2">thread_send_message/2</a>, 
but providing additional <var>Options</var>. These are to deal with the 
case that the queue has a finite maximum size and is full: whereas <a id="idx:threadsendmessage2:2330"></a><a class="pred" href="threadcom.html#thread_send_message/2">thread_send_message/2</a> 
will block until the queue has drained sufficiently to accept a new 
message, <a id="idx:threadsendmessage3:2331"></a><a class="pred" href="threadcom.html#thread_send_message/3">thread_send_message/3</a> 
can accept a time-out or deadline analogously to <a id="idx:threadgetmessage3:2332"></a><a class="pred" href="threadcom.html#thread_get_message/3">thread_get_message/3</a>. 
The options are:

<dl class="latex">
<dt><strong>deadline</strong>(<var>+AbsTime</var>)</dt>
<dd class="defbody">
The call fails (silently) if no space has become available before
<var>AbsTime</var>. See <a id="idx:gettime1:2333"></a><a class="pred" href="system.html#get_time/1">get_time/1</a> 
for the representation of absolute time. If <var>AbsTime</var> is 
earlier then the current time, <a id="idx:threadsendmessage3:2334"></a><a class="pred" href="threadcom.html#thread_send_message/3">thread_send_message/3</a> 
fails immediately. Both resolution and maximum wait time is 
platform-dependent.<sup class="fn">201<span class="fn-text">The 
implementation uses <b>MsgWaitForMultipleObjects()</b> on MS-Windows and <b>pthread_cond_timedwait()</b> 
on other systems.</span></sup></dd>
<dt><strong>timeout</strong>(<var>+Time</var>)</dt>
<dd class="defbody">
<var>Time</var> is a float or integer and specifies the maximum time to 
wait in seconds. This is a relative-time version of the <code>deadline</code> 
option. If both options are provided, the earlier time is effective.

<p>If <var>Time</var> is 0 or 0.0, <a id="idx:threadsendmessage3:2335"></a><a class="pred" href="threadcom.html#thread_send_message/3">thread_send_message/3</a> 
examines the queue and sends the message if space is available, but does 
not suspend if no space is available, failing immediately instead.

<p>If <var>Time</var> <var>&lt; 0</var>, <a id="idx:threadsendmessage3:2336"></a><a class="pred" href="threadcom.html#thread_send_message/3">thread_send_message/3</a> 
fails immediately without sending the message.</dd>
<dt><strong>signals</strong>(<var>+BoolOrTime</var>)</dt>
<dd class="defbody">
Whether or not signals (see <a id="idx:threadsignal2:2337"></a><a class="pred" href="threadcom.html#thread_signal/2">thread_signal/2</a>) 
are processed while waiting. As the underlying implementation does not 
handle signals on most platforms, the implementation by default (<code>true</code>) 
times out every 0.25&nbsp;seconds and checks for signals. If <code>false</code>, 
signals are not checked. If a number is specified, we check for signals 
every
<var>Time</var> seconds. Smaller times may be used to improved 
responsiveness to signals. Larger times may be used to reduce CPU usage.
</dd>
</dl>

</dd>
<dt class="pubdef"><a id="thread_get_message/1"><strong>thread_get_message</strong>(<var>?Term</var>)</a></dt>
<dd class="defbody">
Examines the thread message queue and if necessary blocks execution 
until a term that unifies to <var>Term</var> arrives in the queue. After 
a term from the queue has been unified to <var>Term</var>, the term is 
deleted from the queue.

<p>Please note that non-unifying messages remain in the queue. After the 
following has been executed, thread 1 has the term <code>b(gnu)</code> 
in its queue and continues execution using <var>A</var>&nbsp;=&nbsp;<code>gnat</code>.

<pre class="code">
   &lt;thread 1&gt;
   thread_get_message(a(A)),

   &lt;thread 2&gt;
   thread_send_message(Thread_1, b(gnu)),
   thread_send_message(Thread_1, a(gnat)),
</pre>

<p><var>Term</var> may contain attributed variables (see <a class="sec" href="clp.html#sec:8">section 
8</a>), in which case only terms for which the constraints successfully 
execute are returned. Handle constraints applies for all predicates that 
extract terms from message queues. For example, we can get the even 
numbers from a queue using this code:

<pre class="code">
get_matching_messages(Queue, Pattern, [H|T]) :-
    copy_term(Pattern, H),
    thread_get_message(Queue, H, [timeout(0)]),
    !,
    get_matching_messages(Queue, Pattern, T).
get_matching_messages(_, _, []).

even_numbers(Q, List) :-
    freeze(Even, Even mod 2 =:= 0),
    get_matching_messages(Q, Even, List).
</pre>

<p>See also <a id="idx:threadpeekmessage1:2338"></a><a class="pred" href="threadcom.html#thread_peek_message/1">thread_peek_message/1</a>.</dd>
<dt class="pubdef"><a id="thread_peek_message/1"><strong>thread_peek_message</strong>(<var>?Term</var>)</a></dt>
<dd class="defbody">
Examines the thread message queue and compares the queued terms with <var>Term</var> 
until one unifies or the end of the queue has been reached. In the first 
case the call succeeds, possibly instantiating
<var>Term</var>. If no term from the queue unifies, this call fails. 
I.e.,
<a id="idx:threadpeekmessage1:2339"></a><a class="pred" href="threadcom.html#thread_peek_message/1">thread_peek_message/1</a> 
never waits and does not remove any term from the queue. See also <a id="idx:threadgetmessage3:2340"></a><a class="pred" href="threadcom.html#thread_get_message/3">thread_get_message/3</a>.</dd>
<dt class="pubdef"><a id="message_queue_create/1"><strong>message_queue_create</strong>(<var>?Queue</var>)</a></dt>
<dd class="defbody">
Equivalent to <code>message_queue_create(Queue,[])</code>. For 
compatibility, calling <code>message_queue_create(+Atom)</code> is 
equivalent to
<code>message_queue_create(Queue, [alias(Atom)])</code>. New code should 
use
<a id="idx:messagequeuecreate2:2341"></a><a class="pred" href="threadcom.html#message_queue_create/2">message_queue_create/2</a> 
to create a named queue.</dd>
<dt class="pubdef"><a id="message_queue_create/2"><strong>message_queue_create</strong>(<var>-Queue, 
+Options</var>)</a></dt>
<dd class="defbody">
Create a message queue from <var>Options</var>. Defined options are:

<dl class="latex">
<dt><strong>alias</strong>(<var>+Alias</var>)</dt>
<dd class="defbody">
Create a message queue that is identified by the atom <var>Alias</var>. 
Message queues created this way must be explicitly destroyed by the 
user. If the alias option is omitted, an <em>Anonymous</em> queue is 
created that is identified by a <em>blob</em> (see <a class="sec" href="foreigninclude.html#sec:12.4.10">section 
12.4.10</a>) and subject to garbage collection.<sup class="fn">202<span class="fn-text">Garbage 
collecting anonymous message queues is not part of the ISO proposal and 
most likely not a widely implemented feature.</span></sup></dd>
<dt><strong>max_size</strong>(<var>+Size</var>)</dt>
<dd class="defbody">
Maximum number of terms in the queue. If this number is reached,
<a id="idx:threadsendmessage2:2342"></a><a class="pred" href="threadcom.html#thread_send_message/2">thread_send_message/2</a> 
will suspend until the queue is drained. The option can be used if the 
source, sending messages to the queue, is faster than the drain, 
consuming the messages.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="message_queue_destroy/1"><strong>message_queue_destroy</strong>(<var>+Queue</var>)</a></dt>
<dd class="defbody">
Destroy a message queue created with <a id="idx:messagequeuecreate1:2343"></a><a class="pred" href="threadcom.html#message_queue_create/1">message_queue_create/1</a>. 
A permission error is raised if <var>Queue</var> refers to (the default 
queue of) a thread. Other threads that are waiting for <var>Queue</var> 
using
<a id="idx:threadgetmessage2:2344"></a><a class="pred" href="threadcom.html#thread_get_message/2">thread_get_message/2</a> 
receive an existence error.</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="is_message_queue/1"><strong>is_message_queue</strong>(<var>@Term</var>)</a></dt>
<dd class="defbody">
True if <var>Term</var> refers to an existing message queue. This 
predicate can not block and has no error conditions. Note that message 
queues may be destroyed asynchronously by another thread and <em>anonymous</em> 
message queues may be garbage collected asynchronously.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="thread_get_message/2"><strong>thread_get_message</strong>(<var>+Queue, 
?Term</var>)</a></dt>
<dd class="defbody">
As <a id="idx:threadgetmessage1:2345"></a><a class="pred" href="threadcom.html#thread_get_message/1">thread_get_message/1</a>, 
operating on a given queue. It is allowed (but not advised) to get 
messages from the queue of other threads. This predicate raises an 
existence error exception if <var>Queue</var> doesn't exist or is 
destroyed using <a id="idx:messagequeuedestroy1:2346"></a><a class="pred" href="threadcom.html#message_queue_destroy/1">message_queue_destroy/1</a> 
while this predicate is waiting.</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="thread_get_message/3"><strong>thread_get_message</strong>(<var>+Queue, 
?Term, +Options</var>)</a></dt>
<dd class="defbody">
As <a id="idx:threadgetmessage2:2347"></a><a class="pred" href="threadcom.html#thread_get_message/2">thread_get_message/2</a>, 
but providing additional <var>Options</var>:

<dl class="latex">
<dt><strong>deadline</strong>(<var>+AbsTime</var>)</dt>
<dd class="defbody">
The call fails (silently) if no message has arrived before
<var>AbsTime</var>. See <a id="idx:gettime1:2348"></a><a class="pred" href="system.html#get_time/1">get_time/1</a> 
for the representation of absolute time. If <var>AbsTime</var> is 
earlier then the current time, <a id="idx:threadgetmessage3:2349"></a><a class="pred" href="threadcom.html#thread_get_message/3">thread_get_message/3</a> 
fails immediately. Both resolution and maximum wait time is 
platform-dependent.<sup class="fn">203<span class="fn-text">The 
implementation uses <b>MsgWaitForMultipleObjects()</b> on MS-Windows and <b>pthread_cond_timedwait()</b> 
on other systems.</span></sup></dd>
<dt><strong>timeout</strong>(<var>+Time</var>)</dt>
<dd class="defbody">
<var>Time</var> is a float or integer and specifies the maximum time to 
wait in seconds. This is a relative-time version of the <code>deadline</code> 
option. If both options are provided, the earlier time is effective.

<p>If <var>Time</var> is 0 or 0.0, <a id="idx:threadgetmessage3:2350"></a><a class="pred" href="threadcom.html#thread_get_message/3">thread_get_message/3</a> 
examines the queue but does not suspend if no matching term is 
available. Note that unlike
<a id="idx:threadpeekmessage2:2351"></a><a class="pred" href="threadcom.html#thread_peek_message/2">thread_peek_message/2</a>, 
a matching term is removed from the queue.

<p>If <var>Time</var> <var>&lt; 0</var>, <a id="idx:threadgetmessage3:2352"></a><a class="pred" href="threadcom.html#thread_get_message/3">thread_get_message/3</a> 
fails immediately without removing any message from the queue.</dd>
<dt><strong>signals</strong>(<var>+BoolOrTime</var>)</dt>
<dd class="defbody">
Whether or not signals (see <a id="idx:threadsignal2:2353"></a><a class="pred" href="threadcom.html#thread_signal/2">thread_signal/2</a>) 
are processed while waiting. As the underlying implementation does not 
handle signals on most platforms, the implementation by default (<code>true</code>) 
times out every 0.25&nbsp;seconds and checks for signals. If <code>false</code>, 
signals are not checked. If a number is specified, we check for signals 
every
<var>Time</var> seconds. Smaller times may be used to improved 
responsiveness to signals. Larger times may be used to reduce CPU usage.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="thread_peek_message/2"><strong>thread_peek_message</strong>(<var>+Queue, 
?Term</var>)</a></dt>
<dd class="defbody">
As <a id="idx:threadpeekmessage1:2354"></a><a class="pred" href="threadcom.html#thread_peek_message/1">thread_peek_message/1</a>, 
operating on a given queue. It is allowed to peek into another thread's 
message queue, an operation that can be used to check whether a thread 
has swallowed a message sent to it.</dd>
<dt class="pubdef"><a id="message_queue_property/2"><strong>message_queue_property</strong>(<var>?Queue, 
?Property</var>)</a></dt>
<dd class="defbody">
True if <var>Property</var> is a property of <var>Queue</var>. Defined 
properties are:

<dl class="latex">
<dt><strong>alias</strong>(<var>Alias</var>)</dt>
<dd class="defbody">
Queue has the given alias name.
</dd>
<dt><strong>max_size</strong>(<var>Size</var>)</dt>
<dd class="defbody">
Maximum number of terms that can be in the queue. See
<a id="idx:messagequeuecreate2:2355"></a><a class="pred" href="threadcom.html#message_queue_create/2">message_queue_create/2</a>. 
This property is not present if there is no limit (default).
</dd>
<dt><strong>size</strong>(<var>Size</var>)</dt>
<dd class="defbody">
Queue currently contains <var>Size</var> terms. Note that due to 
concurrent access the returned value may be outdated before it is 
returned. It can be used for debugging purposes as well as work 
distribution purposes.
</dd>
<dt><strong>waiting</strong>(<var>-Count</var>)</dt>
<dd class="defbody">
Number of threads waiting for this queue. This property is not present 
if no threads waits for this queue.
</dd>
</dl>

<p>The <code>size(Size)</code> property is always present and may be 
used to enumerate the created message queues. Note that this predicate 
does
<em>not enumerate</em> threads, but can be used to query the properties 
of the default queue of a thread.</dd>
<dt class="pubdef"><a id="message_queue_set/2"><strong>message_queue_set</strong>(<var>+Queue, 
+Property</var>)</a></dt>
<dd class="defbody">
Set a property on the queue. Supported properties are:

<dl class="latex">
<dt><strong>max_size</strong>(<var>+Size</var>)</dt>
<dd class="defbody">
Change the number of terms that may appear in the message queue before 
the next <a id="idx:threadsendmessage23:2356"></a><a class="pred" href="threadcom.html#thread_send_message/2">thread_send_message/[2,3]</a> 
blocks on it. If the value is higher then the current maximum and the 
queue has writers waiting, wakeup the writers. The value can be lower 
than the current number of terms in the queue. In that case writers will 
block until the queue is drained below the new maximum.
</dd>
</dl>

</dd>
</dl>

<p>Explicit message queues are designed with the <em>worker-pool</em> 
model in mind, where multiple threads wait on a single queue and pick up 
the first goal to execute. Below is a simple implementation where the 
workers execute arbitrary Prolog goals. Note that this example provides 
no means to tell when all work is done. This must be realised using 
additional synchronisation.

<pre class="code">
%%      create_workers(?Id, +N)
%
%       Create a pool with Id and number of workers.
%       After the pool is created, post_job/1 can be used to
%       send jobs to the pool.

create_workers(Id, N) :-
        message_queue_create(Id),
        forall(between(1, N, _),
               thread_create(do_work(Id), _, [])).

do_work(Id) :-
        repeat,
          thread_get_message(Id, Goal),
          (   catch(Goal, E, print_message(error, E))
          -&gt;  true
          ;   print_message(error, goal_failed(Goal, worker(Id)))
          ),
        fail.

%%      post_job(+Id, +Goal)
%
%       Post a job to be executed by one of the pool's workers.

post_job(Id, Goal) :-
        thread_send_message(Id, Goal).
</pre>

<p><h3 id="sec:thread-wait"><a id="sec:10.3.2"><span class="sec-nr">10.3.2</span> <span class="sec-title">Waiting 
for events</span></a></h3>

<a id="sec:thread-wait"></a>

<p><a id="idx:blackboard:2357"></a>While message queues realizes 
communicating <em>agents</em> sharing the same program and optionally 
dynamic data, the predicate <a id="idx:threadwait2:2358"></a><a class="pred" href="threadcom.html#thread_wait/2">thread_wait/2</a> 
facilitates agents that communicate based on a <em>shared blackboard</em>. 
An important difference is were message queues require the sender and 
receiver to know about the queue used to communicate and every message 
can wakeup at most one thread, the blackboard model allows any number 
(including zero) of threads to <em>listen</em> to changes on the 
blackboard. Any module can act as a blackboard. The blackboard can be 
updated using the standard Prolog database update predicates (<a id="idx:assert1:2359"></a><a class="pred" href="db.html#assert/1">assert/1</a>, <a id="idx:retract1:2360"></a><a class="pred" href="db.html#retract/1">retract/1</a> 
and friends).

<p><a id="idx:conditionvariable:2361"></a>Waiting is implemented using a 
POSIX <em>condition variable</em> and matching <em>mutex</em>. On a 
matching database change the condition variable is signalled using a <em>broadcast</em>, 
waking up all threads waiting in <a id="idx:threadwait2:2362"></a><a class="pred" href="threadcom.html#thread_wait/2">thread_wait/2</a>. 
Multiple database updates can be grouped and cause a single wakeup using <a id="idx:threadupdate2:2363"></a><a class="pred" href="threadcom.html#thread_update/2">thread_update/2</a>. 
This predicate also allows signalling the module condition variable 
without updating the database and controlling whether all or a single 
thread is activated.

<p>The blackboard architecture is a good match for an intelligent agent 
system that has to react on a changing world. Input threads gather 
sensor data from the world and update a shared world view in a set of 
dynamic predicates in one or more modules. Agent threads listen to this 
data or a subset thereof and trigger actions. This is notably a good 
match with <em>tabling</em>, in particular incremental tabling (see
<a class="sec" href="tabling-incremental.html#sec:7.7">section 7.7</a>) 
and <em>Well Founded Semantics</em> (see
<a class="sec" href="WFS.html#sec:7.6">section 7.6</a>).<sup class="fn">204<span class="fn-text">Future 
versions may provide additional triggers, for example to learn about 
invalidated tables. Please share your experience.</span></sup>

<dl class="latex">
<dt class="pubdef"><a id="thread_wait/2"><strong>thread_wait</strong>(<var>:Goal, 
:Options</var>)</a></dt>
<dd class="defbody">
Block execution of the calling thread until <var>Goal</var> becomes 
true. The application must be prepared to handle spurious calls to <var>Goal</var>, 
i.e., more calls than asked for based on the <var>Options</var> list. A 
possible exception in <var>Goal</var> is propagated and thus terminates
<a id="idx:threadwait2:2364"></a><a class="pred" href="threadcom.html#thread_wait/2">thread_wait/2</a>.

<p>The wait is associated with a module. This module is derived from the
<var>Options</var> argument.

<p>The <var>Options</var> list specifies when <var>Goal</var> is 
re-evaluated and optionally when the call terminates due to a timeout.

<dl class="latex">
<dt><strong>deadline</strong>(<var>+AbsTime</var>)</dt>
<dt><strong>timeout</strong>(<var>+Time</var>)</dt>
<dd class="defbody">
Timeout and deadline handling. See <a id="idx:threadgetmessage3:2365"></a><a class="pred" href="threadcom.html#thread_get_message/3">thread_get_message/3</a> 
for details. This predicate fails when it terminates due to one of these 
options.</dd>
<dt><strong>retry_every</strong>(<var>+Time</var>)</dt>
<dd class="defbody">
Retry goal every <var>Time</var> seconds regardless of whether an event 
happened. The default is 1 second. This ensures that signals (see <a id="idx:threadsignal2:2366"></a><a class="pred" href="threadcom.html#thread_signal/2">thread_signal/2</a>) 
and time limits are respected with an optional delay.<sup class="fn">205<span class="fn-text">Some 
operating systems process such signals immediately, while others only 
check for such events synchronously.</span></sup></dd>
<dt><strong>db</strong>(<var>+Boolean</var>)</dt>
<dd class="defbody">
Wakeup on arbitrary changes to any dynamic predicate that is defined in 
the associated module. This is the default if <code>wait_preds(+Preds)</code> 
is not provided.</dd>
<dt><strong>wait_preds</strong>(<var>+List</var>)</dt>
<dd class="defbody">
Only call <var>Goal</var> if at least one of the predicates in
<var>List</var> has been modified. Each element of <var>List</var> is a <em>predicate 
indicator</em> (<i>Name/Arity</i> or
<i>Name//Arity</i> that is resolved to a predicate in the module this 
wait is associated with. If the element is <code><code>+</code>(PI)</code><sup class="fn">206<span class="fn-text">Note 
that <code>+<a id="idx:p1:2367"></a><span class="pred-ext">p/1</span></code> 
is read as /(+(p),1).</span></sup>, <var>Goal</var> is only triggered if 
a clause was added (<a id="idx:assert1:2368"></a><a class="pred" href="db.html#assert/1">assert/1</a>). 
If the element is <code><code>-</code>(PI)</code>, <var>Goal</var> is 
only triggered if a clause was retracted (<a id="idx:retract1:2369"></a><a class="pred" href="db.html#retract/1">retract/1</a> 
or
<a id="idx:erase1:2370"></a><a class="pred" href="db.html#erase/1">erase/1</a>). 
Default is to wakeup on both assert and retract.</dd>
<dt><strong>modified</strong>(<var>-List</var>)</dt>
<dd class="defbody">
The <var>List</var> variable normally also appears in <var>Goal</var> 
and is unified with a list of predicates from the <code>wait_preds</code> 
option that have been modified.
<var>List</var> must be unbound at entry.</dd>
<dt><strong>module</strong>(<var>+Module</var>)</dt>
<dd class="defbody">
Specifies the module to act on explicitly.
</dd>
</dl>

<p>The execution of <var>Goal</var> is synchronized between all threads 
calling this predicate on the same module, changes to dynamic predicates 
in this module and calls to <a id="idx:threadupdate2:2371"></a><a class="pred" href="threadcom.html#thread_update/2">thread_update/2</a> 
on the same module.

<p>This predicate raises a <code>permision_error</code> exception when 
called recursively or called from inside a transaction. See
<a class="sec" href="db.html#sec:4.14.1.2">section 4.14.1.2</a> for 
details about interaction with transactions.</dd>
<dt class="pubdef"><a id="thread_update/2"><strong>thread_update</strong>(<var>:Goal, 
:Options</var>)</a></dt>
<dd class="defbody">
Update a module (typically using <a id="idx:assert1:2372"></a><a class="pred" href="db.html#assert/1">assert/1</a> 
and/or <a id="idx:retract1:2373"></a><a class="pred" href="db.html#retract/1">retract/1</a> 
and friends) and on completion signal threads waiting for this module 
using
<a id="idx:threadwait2:2374"></a><a class="pred" href="threadcom.html#thread_wait/2">thread_wait/2</a> 
to reevaluate their <var>Goal</var>. <var>Goal</var> is synchronized 
between updating and waiting threads. <var>Options</var>:

<dl class="latex">
<dt><strong>module</strong>(<var>+Module</var>)</dt>
<dd class="defbody">
Determines the module to operate on. Default is the context module 
associated with the <var>Options</var> argument.
</dd>
<dt><strong>notify</strong>(<var>+Atom</var>)</dt>
<dd class="defbody">
Determines whether all waiting threads are activated (<code>broadcast</code>, 
default) or a single thread (<code>signal</code>).
</dd>
</dl>

</dd>
</dl>

<p><i>Compatibility</i> The <a id="idx:threadwait2:2375"></a><a class="pred" href="threadcom.html#thread_wait/2">thread_wait/2</a> 
predicate is modelled after the
<a class="url" href="http://staff.itee.uq.edu.au/pjr/HomePages/QuPrologHome.html">Qu-Prolog</a> 
predicate <a id="idx:threadwaitongoal2:2376"></a><span class="pred-ext">thread_wait_on_goal/2</span>. 
It is largely compatible. Our current implementation does not support 
predicate time stamps.<sup class="fn">207<span class="fn-text">See <a id="idx:predicateproperty2:2377"></a><a class="pred" href="examineprog.html#predicate_property/2">predicate_property/2</a>, 
property <code>generation</code>.</span></sup> We made this predicate 
act on a specific module rather than the entire database. The timeout 
specification follows that of the other thread waiting predicates and 
may be combined with the <code>retry_every</code> option. The default 
retry-time is also 1 second rather than <i>infinite</i>.

<p><h3 id="sec:thread-signal"><a id="sec:10.3.3"><span class="sec-nr">10.3.3</span> <span class="sec-title">Signalling 
threads</span></a></h3>

<a id="sec:thread-signal"></a>

<p>The predicates in this section provide <em>signalling</em> between 
threads. A thread signal inserts any goal as an <em>interrupt</em> into 
the control flow of any target thread. The target thread processes the 
goal at the first safe opportunity. The mechanism was introduced with 
two goals in mind: (1) running a goal inside a thread for debugging 
purposes such as enabling the status or get access thread-specific data 
and (2) force a thread to abort its current goal by inserting an 
exeption into its control flow.

<p>Over time, more complicated use cases have been identified that may 
result in multiple signals that occur (nearly) simultaneous. As of 
version 8.5.1 the interface has been extended and the interaction with 
other built-in predicates has been specified in much more detail.

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="thread_signal/2"><strong>thread_signal</strong>(<var>+ThreadId, 
:Goal</var>)</a></dt>
<dd class="defbody">
Make thread <var>ThreadId</var> execute <var>Goal</var> at the first 
opportunity. The predicate <a id="idx:threadsignal2:2378"></a><a class="pred" href="threadcom.html#thread_signal/2">thread_signal/2</a> 
itself places <var>Goal</var> into the signalled thread's signal queue 
and returns immediately.

<p><var>ThreadId</var> executes <var>Goal</var> as an <em>interrupt</em> 
at the first opportunity. Defined opportunities are:

<p>
<ul class="latex">
<li>At the <em>call port</em> of any predicate except for predicates 
with the property <code>sig_atomic</code>. Currently this only applies 
to <a id="idx:sigatomic1:2379"></a><a class="pred" href="threadcom.html#sig_atomic/1">sig_atomic/1</a>.
<li>Before retrying a foreign predicate.
<li>Before backtracking to the next clause of a Prolog predicate.
<li>When a foreign predicate calls <a class="func" href="foreigninclude.html#PL_handle_signals()">PL_handle_signals()</a>. 
Foreign predicates that take long to complete should call
<a class="func" href="foreigninclude.html#PL_handle_signals()">PL_handle_signals()</a> 
regularly and return with <code>FALSE</code> after <a class="func" href="foreigninclude.html#PL_handle_signals()">PL_handle_signals()</a> 
returned -1, indicating an exception was raised.
<li>Foreign predicates calling <em>blocking system calls</em> should 
attempt to make these system calls interruptible. To enable this on 
POSIX systems, SWI-Prolog sends a
<code>SIGUSR2</code> to the signalled thread while the handler is an 
empty function. This causes most blocking system calls to return with <code>EINTR</code>. 
See also the commandline option
<strong>--sig-alert</strong>. On Windows, <a class="func" href="foreigninclude.html#PL_handle_signals()">PL_handle_signals()</a> 
is called when the user processes Windows messages.
<li>For some blocking (thread) APIs we use a timed version with a 0.25 
sec timeout to achieve a <em>polling loop</em>.
</ul>

<p>If one or more signals are queued, the queue is processed. Processing 
the queue skips signals blocked due to <a id="idx:sigblock1:2380"></a><a class="pred" href="threadcom.html#sig_block/1">sig_block/1</a> 
and stops after the queue does not contain any more non-blocked signals 
or processing a signal results in an exception. After an exception, 
other signals remain in the queue and will be processed after unwinding 
to the matching
<a id="idx:catch3:2381"></a><a class="pred" href="exception.html#catch/3">catch/3</a>. 
Typically these queued signals will be processed during the
<var>Recover</var> goal of the <a id="idx:catch3:2382"></a><a class="pred" href="exception.html#catch/3">catch/3</a>. 
Note that <a id="idx:sigatomic1:2383"></a><a class="pred" href="threadcom.html#sig_atomic/1">sig_atomic/1</a> 
may be used to protect the recovery goal.

<p>The <a id="idx:threadsignal2:2384"></a><a class="pred" href="threadcom.html#thread_signal/2">thread_signal/2</a> 
mechanism is primarily used by the system to insert debugging goals into 
the target thread (<a id="idx:tspy1:2385"></a><a class="pred" href="thutil.html#tspy/1">tspy/1</a>, <a id="idx:tbacktrace1:2386"></a><span class="pred-ext">tbacktrace/1</span>, 
etc.) or to interrupt a thread using e.g., <code>thread_signal(Thread, 
abort)</code>. Predicates from library <code>library(thread)</code> use 
signals to stop workers for e.g. <a id="idx:concurrentmaplist2:2387"></a><a class="pred" href="thread.html#concurrent_maplist/2">concurrent_maplist/2</a> 
if some call fails. Applications may use it, typically for similar 
purposes such as asynchronously stopping tasks or inspecting the status 
of a task. Below we describe the behaviour of thread signalling in more 
detail. The following notes apply for
<var>Goal</var> executing in <var>ThreadId</var>

<p>
<ul class="latex">
<li>The execution is protected by <a id="idx:sigatomic1:2388"></a><a class="pred" href="threadcom.html#sig_atomic/1">sig_atomic/1</a> 
and thus signal execution is <em>not nested</em>.
<li>If <var>Goal</var> <em>succeeds</em>, possible choice points are 
discarded. Changes to the Prolog stacks such as changes to backtrackable 
global variables remain.
<li>If <var>Goal</var> <em>fails</em>, no action is taken, i.e., failure 
is not considered a special condition.
<li>If <var>Goal</var> <em>raises an exception</em> the exeception is 
propagated into the environment. This allows for forcefully stopping the 
target thread. The system uses this to implement
<a id="idx:abort0:2389"></a><a class="pred" href="toplevel.html#abort/0">abort/0</a> 
and <a id="idx:callwithtimelimit2:2390"></a><span class="pred-ext">call_with_time_limit/2</span>.
<li>Code into which signals may be injected must make sure to use
<a id="idx:setupcallcleanup3:2391"></a><a class="pred" href="metacall.html#setup_call_cleanup/3">setup_call_cleanup/3</a> 
and friends to ensure proper cleanup in the case of an exception. This 
is good practice anyway to guard against unpredicatable exceptions such 
as resource exhaustion.
<li><var>Goal</var> may use stack inspection such as <a id="idx:prologframeattribute3:2392"></a><a class="pred" href="manipstack.html#prolog_frame_attribute/3">prolog_frame_attribute/3</a> 
to determine what the thread is doing.
</ul>
</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="sig_pending/1"><strong>sig_pending</strong>(<var>-List</var>)</a></dt>
<dd class="defbody">
True when <var>List</var> contains all signals submitted using
<a id="idx:threadsignal2:2393"></a><a class="pred" href="threadcom.html#thread_signal/2">thread_signal/2</a> 
that are not yet processed. This includes signals blocked by <a id="idx:sigblock1:2394"></a><a class="pred" href="threadcom.html#sig_block/1">sig_block/1</a>.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="sig_remove/2"><strong>sig_remove</strong>(<var>:Pattern, 
-List</var>)</a></dt>
<dd class="defbody">
Remove all signals that unify with <var>Pattern</var> from the signal 
queue and make the removed signals available in <var>List</var></dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="sig_block/1"><strong>sig_block</strong>(<var>:Pattern</var>)</a></dt>
<dd class="defbody">
Block thread signals queued using <a id="idx:threadsignal2:2395"></a><a class="pred" href="threadcom.html#thread_signal/2">thread_signal/2</a> 
that match
<var>Pattern</var>.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="sig_unblock/1"><strong>sig_unblock</strong>(<var>:Pattern</var>)</a></dt>
<dd class="defbody">
Remove any effect of <a id="idx:sigblock1:2396"></a><a class="pred" href="threadcom.html#sig_block/1">sig_block/1</a> 
for patterns that are more specific (see <a id="idx:subsumesterm2:2397"></a><a class="pred" href="compare.html#subsumes_term/2">subsumes_term/2</a>). 
If any patterns are removed, reschedule blocked signals. Note that <a id="idx:sigunblock1:2398"></a><a class="pred" href="threadcom.html#sig_unblock/1">sig_unblock/1</a> 
normally causes all unblocked signals to be executed immediately.</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="sig_atomic/1"><strong>sig_atomic</strong>(<var>:Goal</var>)</a></dt>
<dd class="defbody">
Execute <var>Goal</var> as <a id="idx:once1:2399"></a><a class="pred" href="metacall.html#once/1">once/1</a> 
while blocking both thread signals (see <a id="idx:threadsignal2:2400"></a><a class="pred" href="threadcom.html#thread_signal/2">thread_signal/2</a>) 
and OS signals (see <a id="idx:onsignal3:2401"></a><a class="pred" href="signal.html#on_signal/3">on_signal/3</a>). 
The system executes some goals while blocking signals. These are:

<p>
<ul class="latex">
<li>The goal injected using <a id="idx:threadsignal2:2402"></a><a class="pred" href="threadcom.html#thread_signal/2">thread_signal/2</a>, 
i.e., signals do not interrupt a running signal handler.
<li>The <var>Setup</var> call of <a id="idx:setupcallcleanup3:2403"></a><a class="pred" href="metacall.html#setup_call_cleanup/3">setup_call_cleanup/3</a> 
and friends.
<li>The <var>Cleanup</var> call of <a id="idx:callcleanup2:2404"></a><a class="pred" href="metacall.html#call_cleanup/2">call_cleanup/2</a> 
and friends.
<li>Compiling a file or loading a <em>quick load file</em>.
</ul>

<p>The call port of <a id="idx:sigatomic1:2405"></a><a class="pred" href="threadcom.html#sig_atomic/1">sig_atomic/1</a> 
does not handle signals. This may notably be used to prevent 
interruption of the <a id="idx:catch3:2406"></a><a class="pred" href="exception.html#catch/3">catch/3</a> <var>Recover</var> 
goal. For example, we may ensure the recovery goal of a timeout is 
called using the code below. Without this precaution another signal may 
run before
<a id="idx:writeln1:2407"></a><a class="pred" href="termrw.html#writeln/1">writeln/1</a> 
and raise an exception to prevent its execution. Note that
<a id="idx:catch3:2408"></a><a class="pred" href="exception.html#catch/3">catch/3</a> 
should generally <em>not</em> be used for cleanup of resources in case 
of an exception and thus it is typically fine if its <var>Recover</var> 
goal is interrupted. Use <a id="idx:setupcallcleanup3:2409"></a><a class="pred" href="metacall.html#setup_call_cleanup/3">setup_call_cleanup/3</a> 
or one of the other predicates from the <a id="idx:callcleanup2:2410"></a><a class="pred" href="metacall.html#call_cleanup/2">call_cleanup/2</a> 
family for cleanup.

<pre class="code">
    ...,
    catch(call_with_time_limit(Time, Goal),
          time_limit_exceeded,
          sig_atomic(writeln('Time limit exceeded'))).
</pre>

<p></dd>
</dl>

<p><h3 id="sec:threadlocal"><a id="sec:10.3.4"><span class="sec-nr">10.3.4</span> <span class="sec-title">Threads 
and dynamic predicates</span></a></h3>

<a id="sec:threadlocal"></a>

<p>Besides queues (<a class="sec" href="threadcom.html#sec:10.3.1">section 
10.3.1</a>) threads can share and exchange data using dynamic 
predicates. The multithreaded version knows about two types of dynamic 
predicates. By default, a predicate declared
<em>dynamic</em> (see <a id="idx:dynamic1:2411"></a><a class="pred" href="dynamic.html#dynamic/1">dynamic/1</a>) 
is shared by all threads. Each thread may assert, retract and run the 
dynamic predicate. Synchronisation inside Prolog guarantees the 
consistency of the predicate. Updates are
<em>logical</em>: visible clauses are not affected by assert/retract 
after a query started on the predicate. In many cases primitives from
<a class="sec" href="threadsync.html#sec:10.4">section 10.4</a> should 
be used to ensure that application invariants on the predicate are 
maintained.

<p>Besides shared predicates, dynamic predicates can be declared with 
the
<a id="idx:threadlocal1:2412"></a><a class="pred" href="threadcom.html#thread_local/1">thread_local/1</a> 
directive. Such predicates share their attributes, but the clause list 
is different in each thread.

<dl class="latex">
<dt class="pubdef"><a id="thread_local/1"><strong>thread_local</strong> <var>+Functor/+Arity, 
...</var></a></dt>
<dd class="defbody">
This directive is related to the <a id="idx:dynamic1:2413"></a><a class="pred" href="dynamic.html#dynamic/1">dynamic/1</a> 
directive. It tells the system that the predicate may be modified using <a id="idx:assert1:2414"></a><a class="pred" href="db.html#assert/1">assert/1</a>, <a id="idx:retract1:2415"></a><a class="pred" href="db.html#retract/1">retract/1</a>, 
etc., during execution of the program. Unlike normal shared dynamic 
data, however, each thread has its own clause list for the predicate. As 
a thread starts, this clause list is empty. If there are still clauses 
when the thread terminates, these are automatically reclaimed by the 
system (see also <a id="idx:volatile1:2416"></a><a class="pred" href="saved-states.html#volatile/1">volatile/1</a>). 
The thread_local property implies the properties <em>dynamic</em> and <em>volatile</em>.

<p>Thread-local dynamic predicates are intended for maintaining 
thread-specific state or intermediate results of a computation.

<p>It is not recommended to put clauses for a thread-local predicate 
into a file, as in the example below, because the clause is only visible 
from the thread that loaded the source file. All other threads start 
with an empty clause list.

<pre class="code">
:- thread_local
        foo/1.

foo(gnat).
</pre>

<p><b>DISCLAIMER</b> Whether or not this declaration is appropriate in 
the sense of the proper mechanism to reach the goal is still debated. If 
you have strong feelings in favour or against, please share them in the 
SWI-Prolog mailing list.
</dd>
</dl>

<p></body></html>