// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: audio2face.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_audio2face_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_audio2face_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_audio2face_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_audio2face_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_audio2face_2eproto;
namespace nvidia {
namespace audio2face {
class PushAudioRequest;
struct PushAudioRequestDefaultTypeInternal;
extern PushAudioRequestDefaultTypeInternal _PushAudioRequest_default_instance_;
class PushAudioRequestStart;
struct PushAudioRequestStartDefaultTypeInternal;
extern PushAudioRequestStartDefaultTypeInternal _PushAudioRequestStart_default_instance_;
class PushAudioResponse;
struct PushAudioResponseDefaultTypeInternal;
extern PushAudioResponseDefaultTypeInternal _PushAudioResponse_default_instance_;
class PushAudioStreamRequest;
struct PushAudioStreamRequestDefaultTypeInternal;
extern PushAudioStreamRequestDefaultTypeInternal _PushAudioStreamRequest_default_instance_;
class PushAudioStreamResponse;
struct PushAudioStreamResponseDefaultTypeInternal;
extern PushAudioStreamResponseDefaultTypeInternal _PushAudioStreamResponse_default_instance_;
}  // namespace audio2face
}  // namespace nvidia
PROTOBUF_NAMESPACE_OPEN
template<> ::nvidia::audio2face::PushAudioRequest* Arena::CreateMaybeMessage<::nvidia::audio2face::PushAudioRequest>(Arena*);
template<> ::nvidia::audio2face::PushAudioRequestStart* Arena::CreateMaybeMessage<::nvidia::audio2face::PushAudioRequestStart>(Arena*);
template<> ::nvidia::audio2face::PushAudioResponse* Arena::CreateMaybeMessage<::nvidia::audio2face::PushAudioResponse>(Arena*);
template<> ::nvidia::audio2face::PushAudioStreamRequest* Arena::CreateMaybeMessage<::nvidia::audio2face::PushAudioStreamRequest>(Arena*);
template<> ::nvidia::audio2face::PushAudioStreamResponse* Arena::CreateMaybeMessage<::nvidia::audio2face::PushAudioStreamResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace nvidia {
namespace audio2face {

// ===================================================================

class PushAudioRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nvidia.audio2face.PushAudioRequest) */ {
 public:
  inline PushAudioRequest() : PushAudioRequest(nullptr) {}
  ~PushAudioRequest() override;
  explicit PROTOBUF_CONSTEXPR PushAudioRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushAudioRequest(const PushAudioRequest& from);
  PushAudioRequest(PushAudioRequest&& from) noexcept
    : PushAudioRequest() {
    *this = ::std::move(from);
  }

  inline PushAudioRequest& operator=(const PushAudioRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushAudioRequest& operator=(PushAudioRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushAudioRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushAudioRequest* internal_default_instance() {
    return reinterpret_cast<const PushAudioRequest*>(
               &_PushAudioRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PushAudioRequest& a, PushAudioRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PushAudioRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushAudioRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PushAudioRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PushAudioRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PushAudioRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PushAudioRequest& from) {
    PushAudioRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushAudioRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nvidia.audio2face.PushAudioRequest";
  }
  protected:
  explicit PushAudioRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstanceNameFieldNumber = 1,
    kAudioDataFieldNumber = 3,
    kSamplerateFieldNumber = 2,
    kBlockUntilPlaybackIsFinishedFieldNumber = 4,
  };
  // string instance_name = 1;
  void clear_instance_name();
  const std::string& instance_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instance_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instance_name();
  PROTOBUF_NODISCARD std::string* release_instance_name();
  void set_allocated_instance_name(std::string* instance_name);
  private:
  const std::string& _internal_instance_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instance_name(const std::string& value);
  std::string* _internal_mutable_instance_name();
  public:

  // bytes audio_data = 3;
  void clear_audio_data();
  const std::string& audio_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audio_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audio_data();
  PROTOBUF_NODISCARD std::string* release_audio_data();
  void set_allocated_audio_data(std::string* audio_data);
  private:
  const std::string& _internal_audio_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_data(const std::string& value);
  std::string* _internal_mutable_audio_data();
  public:

  // int32 samplerate = 2;
  void clear_samplerate();
  int32_t samplerate() const;
  void set_samplerate(int32_t value);
  private:
  int32_t _internal_samplerate() const;
  void _internal_set_samplerate(int32_t value);
  public:

  // bool block_until_playback_is_finished = 4;
  void clear_block_until_playback_is_finished();
  bool block_until_playback_is_finished() const;
  void set_block_until_playback_is_finished(bool value);
  private:
  bool _internal_block_until_playback_is_finished() const;
  void _internal_set_block_until_playback_is_finished(bool value);
  public:

  // @@protoc_insertion_point(class_scope:nvidia.audio2face.PushAudioRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_data_;
    int32_t samplerate_;
    bool block_until_playback_is_finished_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio2face_2eproto;
};
// -------------------------------------------------------------------

class PushAudioResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nvidia.audio2face.PushAudioResponse) */ {
 public:
  inline PushAudioResponse() : PushAudioResponse(nullptr) {}
  ~PushAudioResponse() override;
  explicit PROTOBUF_CONSTEXPR PushAudioResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushAudioResponse(const PushAudioResponse& from);
  PushAudioResponse(PushAudioResponse&& from) noexcept
    : PushAudioResponse() {
    *this = ::std::move(from);
  }

  inline PushAudioResponse& operator=(const PushAudioResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushAudioResponse& operator=(PushAudioResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushAudioResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushAudioResponse* internal_default_instance() {
    return reinterpret_cast<const PushAudioResponse*>(
               &_PushAudioResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PushAudioResponse& a, PushAudioResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PushAudioResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushAudioResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PushAudioResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PushAudioResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PushAudioResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PushAudioResponse& from) {
    PushAudioResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushAudioResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nvidia.audio2face.PushAudioResponse";
  }
  protected:
  explicit PushAudioResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:nvidia.audio2face.PushAudioResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio2face_2eproto;
};
// -------------------------------------------------------------------

class PushAudioStreamRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nvidia.audio2face.PushAudioStreamRequest) */ {
 public:
  inline PushAudioStreamRequest() : PushAudioStreamRequest(nullptr) {}
  ~PushAudioStreamRequest() override;
  explicit PROTOBUF_CONSTEXPR PushAudioStreamRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushAudioStreamRequest(const PushAudioStreamRequest& from);
  PushAudioStreamRequest(PushAudioStreamRequest&& from) noexcept
    : PushAudioStreamRequest() {
    *this = ::std::move(from);
  }

  inline PushAudioStreamRequest& operator=(const PushAudioStreamRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushAudioStreamRequest& operator=(PushAudioStreamRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushAudioStreamRequest& default_instance() {
    return *internal_default_instance();
  }
  enum StreamingRequestCase {
    kStartMarker = 1,
    kAudioData = 2,
    STREAMING_REQUEST_NOT_SET = 0,
  };

  static inline const PushAudioStreamRequest* internal_default_instance() {
    return reinterpret_cast<const PushAudioStreamRequest*>(
               &_PushAudioStreamRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PushAudioStreamRequest& a, PushAudioStreamRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PushAudioStreamRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushAudioStreamRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PushAudioStreamRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PushAudioStreamRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PushAudioStreamRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PushAudioStreamRequest& from) {
    PushAudioStreamRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushAudioStreamRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nvidia.audio2face.PushAudioStreamRequest";
  }
  protected:
  explicit PushAudioStreamRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartMarkerFieldNumber = 1,
    kAudioDataFieldNumber = 2,
  };
  // .nvidia.audio2face.PushAudioRequestStart start_marker = 1;
  bool has_start_marker() const;
  private:
  bool _internal_has_start_marker() const;
  public:
  void clear_start_marker();
  const ::nvidia::audio2face::PushAudioRequestStart& start_marker() const;
  PROTOBUF_NODISCARD ::nvidia::audio2face::PushAudioRequestStart* release_start_marker();
  ::nvidia::audio2face::PushAudioRequestStart* mutable_start_marker();
  void set_allocated_start_marker(::nvidia::audio2face::PushAudioRequestStart* start_marker);
  private:
  const ::nvidia::audio2face::PushAudioRequestStart& _internal_start_marker() const;
  ::nvidia::audio2face::PushAudioRequestStart* _internal_mutable_start_marker();
  public:
  void unsafe_arena_set_allocated_start_marker(
      ::nvidia::audio2face::PushAudioRequestStart* start_marker);
  ::nvidia::audio2face::PushAudioRequestStart* unsafe_arena_release_start_marker();

  // bytes audio_data = 2;
  bool has_audio_data() const;
  private:
  bool _internal_has_audio_data() const;
  public:
  void clear_audio_data();
  const std::string& audio_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audio_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audio_data();
  PROTOBUF_NODISCARD std::string* release_audio_data();
  void set_allocated_audio_data(std::string* audio_data);
  private:
  const std::string& _internal_audio_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_data(const std::string& value);
  std::string* _internal_mutable_audio_data();
  public:

  void clear_streaming_request();
  StreamingRequestCase streaming_request_case() const;
  // @@protoc_insertion_point(class_scope:nvidia.audio2face.PushAudioStreamRequest)
 private:
  class _Internal;
  void set_has_start_marker();
  void set_has_audio_data();

  inline bool has_streaming_request() const;
  inline void clear_has_streaming_request();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union StreamingRequestUnion {
      constexpr StreamingRequestUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::nvidia::audio2face::PushAudioRequestStart* start_marker_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_data_;
    } streaming_request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio2face_2eproto;
};
// -------------------------------------------------------------------

class PushAudioRequestStart final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nvidia.audio2face.PushAudioRequestStart) */ {
 public:
  inline PushAudioRequestStart() : PushAudioRequestStart(nullptr) {}
  ~PushAudioRequestStart() override;
  explicit PROTOBUF_CONSTEXPR PushAudioRequestStart(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushAudioRequestStart(const PushAudioRequestStart& from);
  PushAudioRequestStart(PushAudioRequestStart&& from) noexcept
    : PushAudioRequestStart() {
    *this = ::std::move(from);
  }

  inline PushAudioRequestStart& operator=(const PushAudioRequestStart& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushAudioRequestStart& operator=(PushAudioRequestStart&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushAudioRequestStart& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushAudioRequestStart* internal_default_instance() {
    return reinterpret_cast<const PushAudioRequestStart*>(
               &_PushAudioRequestStart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PushAudioRequestStart& a, PushAudioRequestStart& b) {
    a.Swap(&b);
  }
  inline void Swap(PushAudioRequestStart* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushAudioRequestStart* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PushAudioRequestStart* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PushAudioRequestStart>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PushAudioRequestStart& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PushAudioRequestStart& from) {
    PushAudioRequestStart::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushAudioRequestStart* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nvidia.audio2face.PushAudioRequestStart";
  }
  protected:
  explicit PushAudioRequestStart(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstanceNameFieldNumber = 1,
    kSamplerateFieldNumber = 2,
    kBlockUntilPlaybackIsFinishedFieldNumber = 3,
  };
  // string instance_name = 1;
  void clear_instance_name();
  const std::string& instance_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instance_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instance_name();
  PROTOBUF_NODISCARD std::string* release_instance_name();
  void set_allocated_instance_name(std::string* instance_name);
  private:
  const std::string& _internal_instance_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instance_name(const std::string& value);
  std::string* _internal_mutable_instance_name();
  public:

  // int32 samplerate = 2;
  void clear_samplerate();
  int32_t samplerate() const;
  void set_samplerate(int32_t value);
  private:
  int32_t _internal_samplerate() const;
  void _internal_set_samplerate(int32_t value);
  public:

  // bool block_until_playback_is_finished = 3;
  void clear_block_until_playback_is_finished();
  bool block_until_playback_is_finished() const;
  void set_block_until_playback_is_finished(bool value);
  private:
  bool _internal_block_until_playback_is_finished() const;
  void _internal_set_block_until_playback_is_finished(bool value);
  public:

  // @@protoc_insertion_point(class_scope:nvidia.audio2face.PushAudioRequestStart)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_name_;
    int32_t samplerate_;
    bool block_until_playback_is_finished_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio2face_2eproto;
};
// -------------------------------------------------------------------

class PushAudioStreamResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nvidia.audio2face.PushAudioStreamResponse) */ {
 public:
  inline PushAudioStreamResponse() : PushAudioStreamResponse(nullptr) {}
  ~PushAudioStreamResponse() override;
  explicit PROTOBUF_CONSTEXPR PushAudioStreamResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushAudioStreamResponse(const PushAudioStreamResponse& from);
  PushAudioStreamResponse(PushAudioStreamResponse&& from) noexcept
    : PushAudioStreamResponse() {
    *this = ::std::move(from);
  }

  inline PushAudioStreamResponse& operator=(const PushAudioStreamResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushAudioStreamResponse& operator=(PushAudioStreamResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushAudioStreamResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushAudioStreamResponse* internal_default_instance() {
    return reinterpret_cast<const PushAudioStreamResponse*>(
               &_PushAudioStreamResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PushAudioStreamResponse& a, PushAudioStreamResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PushAudioStreamResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushAudioStreamResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PushAudioStreamResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PushAudioStreamResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PushAudioStreamResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PushAudioStreamResponse& from) {
    PushAudioStreamResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushAudioStreamResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nvidia.audio2face.PushAudioStreamResponse";
  }
  protected:
  explicit PushAudioStreamResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:nvidia.audio2face.PushAudioStreamResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio2face_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PushAudioRequest

// string instance_name = 1;
inline void PushAudioRequest::clear_instance_name() {
  _impl_.instance_name_.ClearToEmpty();
}
inline const std::string& PushAudioRequest::instance_name() const {
  // @@protoc_insertion_point(field_get:nvidia.audio2face.PushAudioRequest.instance_name)
  return _internal_instance_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PushAudioRequest::set_instance_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instance_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nvidia.audio2face.PushAudioRequest.instance_name)
}
inline std::string* PushAudioRequest::mutable_instance_name() {
  std::string* _s = _internal_mutable_instance_name();
  // @@protoc_insertion_point(field_mutable:nvidia.audio2face.PushAudioRequest.instance_name)
  return _s;
}
inline const std::string& PushAudioRequest::_internal_instance_name() const {
  return _impl_.instance_name_.Get();
}
inline void PushAudioRequest::_internal_set_instance_name(const std::string& value) {
  
  _impl_.instance_name_.Set(value, GetArenaForAllocation());
}
inline std::string* PushAudioRequest::_internal_mutable_instance_name() {
  
  return _impl_.instance_name_.Mutable(GetArenaForAllocation());
}
inline std::string* PushAudioRequest::release_instance_name() {
  // @@protoc_insertion_point(field_release:nvidia.audio2face.PushAudioRequest.instance_name)
  return _impl_.instance_name_.Release();
}
inline void PushAudioRequest::set_allocated_instance_name(std::string* instance_name) {
  if (instance_name != nullptr) {
    
  } else {
    
  }
  _impl_.instance_name_.SetAllocated(instance_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_name_.IsDefault()) {
    _impl_.instance_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.audio2face.PushAudioRequest.instance_name)
}

// int32 samplerate = 2;
inline void PushAudioRequest::clear_samplerate() {
  _impl_.samplerate_ = 0;
}
inline int32_t PushAudioRequest::_internal_samplerate() const {
  return _impl_.samplerate_;
}
inline int32_t PushAudioRequest::samplerate() const {
  // @@protoc_insertion_point(field_get:nvidia.audio2face.PushAudioRequest.samplerate)
  return _internal_samplerate();
}
inline void PushAudioRequest::_internal_set_samplerate(int32_t value) {
  
  _impl_.samplerate_ = value;
}
inline void PushAudioRequest::set_samplerate(int32_t value) {
  _internal_set_samplerate(value);
  // @@protoc_insertion_point(field_set:nvidia.audio2face.PushAudioRequest.samplerate)
}

// bytes audio_data = 3;
inline void PushAudioRequest::clear_audio_data() {
  _impl_.audio_data_.ClearToEmpty();
}
inline const std::string& PushAudioRequest::audio_data() const {
  // @@protoc_insertion_point(field_get:nvidia.audio2face.PushAudioRequest.audio_data)
  return _internal_audio_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PushAudioRequest::set_audio_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.audio_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nvidia.audio2face.PushAudioRequest.audio_data)
}
inline std::string* PushAudioRequest::mutable_audio_data() {
  std::string* _s = _internal_mutable_audio_data();
  // @@protoc_insertion_point(field_mutable:nvidia.audio2face.PushAudioRequest.audio_data)
  return _s;
}
inline const std::string& PushAudioRequest::_internal_audio_data() const {
  return _impl_.audio_data_.Get();
}
inline void PushAudioRequest::_internal_set_audio_data(const std::string& value) {
  
  _impl_.audio_data_.Set(value, GetArenaForAllocation());
}
inline std::string* PushAudioRequest::_internal_mutable_audio_data() {
  
  return _impl_.audio_data_.Mutable(GetArenaForAllocation());
}
inline std::string* PushAudioRequest::release_audio_data() {
  // @@protoc_insertion_point(field_release:nvidia.audio2face.PushAudioRequest.audio_data)
  return _impl_.audio_data_.Release();
}
inline void PushAudioRequest::set_allocated_audio_data(std::string* audio_data) {
  if (audio_data != nullptr) {
    
  } else {
    
  }
  _impl_.audio_data_.SetAllocated(audio_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.audio_data_.IsDefault()) {
    _impl_.audio_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.audio2face.PushAudioRequest.audio_data)
}

// bool block_until_playback_is_finished = 4;
inline void PushAudioRequest::clear_block_until_playback_is_finished() {
  _impl_.block_until_playback_is_finished_ = false;
}
inline bool PushAudioRequest::_internal_block_until_playback_is_finished() const {
  return _impl_.block_until_playback_is_finished_;
}
inline bool PushAudioRequest::block_until_playback_is_finished() const {
  // @@protoc_insertion_point(field_get:nvidia.audio2face.PushAudioRequest.block_until_playback_is_finished)
  return _internal_block_until_playback_is_finished();
}
inline void PushAudioRequest::_internal_set_block_until_playback_is_finished(bool value) {
  
  _impl_.block_until_playback_is_finished_ = value;
}
inline void PushAudioRequest::set_block_until_playback_is_finished(bool value) {
  _internal_set_block_until_playback_is_finished(value);
  // @@protoc_insertion_point(field_set:nvidia.audio2face.PushAudioRequest.block_until_playback_is_finished)
}

// -------------------------------------------------------------------

// PushAudioResponse

// bool success = 1;
inline void PushAudioResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool PushAudioResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool PushAudioResponse::success() const {
  // @@protoc_insertion_point(field_get:nvidia.audio2face.PushAudioResponse.success)
  return _internal_success();
}
inline void PushAudioResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void PushAudioResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:nvidia.audio2face.PushAudioResponse.success)
}

// string message = 2;
inline void PushAudioResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& PushAudioResponse::message() const {
  // @@protoc_insertion_point(field_get:nvidia.audio2face.PushAudioResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PushAudioResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nvidia.audio2face.PushAudioResponse.message)
}
inline std::string* PushAudioResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:nvidia.audio2face.PushAudioResponse.message)
  return _s;
}
inline const std::string& PushAudioResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void PushAudioResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* PushAudioResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* PushAudioResponse::release_message() {
  // @@protoc_insertion_point(field_release:nvidia.audio2face.PushAudioResponse.message)
  return _impl_.message_.Release();
}
inline void PushAudioResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.audio2face.PushAudioResponse.message)
}

// -------------------------------------------------------------------

// PushAudioStreamRequest

// .nvidia.audio2face.PushAudioRequestStart start_marker = 1;
inline bool PushAudioStreamRequest::_internal_has_start_marker() const {
  return streaming_request_case() == kStartMarker;
}
inline bool PushAudioStreamRequest::has_start_marker() const {
  return _internal_has_start_marker();
}
inline void PushAudioStreamRequest::set_has_start_marker() {
  _impl_._oneof_case_[0] = kStartMarker;
}
inline void PushAudioStreamRequest::clear_start_marker() {
  if (_internal_has_start_marker()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.streaming_request_.start_marker_;
    }
    clear_has_streaming_request();
  }
}
inline ::nvidia::audio2face::PushAudioRequestStart* PushAudioStreamRequest::release_start_marker() {
  // @@protoc_insertion_point(field_release:nvidia.audio2face.PushAudioStreamRequest.start_marker)
  if (_internal_has_start_marker()) {
    clear_has_streaming_request();
    ::nvidia::audio2face::PushAudioRequestStart* temp = _impl_.streaming_request_.start_marker_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.streaming_request_.start_marker_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nvidia::audio2face::PushAudioRequestStart& PushAudioStreamRequest::_internal_start_marker() const {
  return _internal_has_start_marker()
      ? *_impl_.streaming_request_.start_marker_
      : reinterpret_cast< ::nvidia::audio2face::PushAudioRequestStart&>(::nvidia::audio2face::_PushAudioRequestStart_default_instance_);
}
inline const ::nvidia::audio2face::PushAudioRequestStart& PushAudioStreamRequest::start_marker() const {
  // @@protoc_insertion_point(field_get:nvidia.audio2face.PushAudioStreamRequest.start_marker)
  return _internal_start_marker();
}
inline ::nvidia::audio2face::PushAudioRequestStart* PushAudioStreamRequest::unsafe_arena_release_start_marker() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nvidia.audio2face.PushAudioStreamRequest.start_marker)
  if (_internal_has_start_marker()) {
    clear_has_streaming_request();
    ::nvidia::audio2face::PushAudioRequestStart* temp = _impl_.streaming_request_.start_marker_;
    _impl_.streaming_request_.start_marker_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PushAudioStreamRequest::unsafe_arena_set_allocated_start_marker(::nvidia::audio2face::PushAudioRequestStart* start_marker) {
  clear_streaming_request();
  if (start_marker) {
    set_has_start_marker();
    _impl_.streaming_request_.start_marker_ = start_marker;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.audio2face.PushAudioStreamRequest.start_marker)
}
inline ::nvidia::audio2face::PushAudioRequestStart* PushAudioStreamRequest::_internal_mutable_start_marker() {
  if (!_internal_has_start_marker()) {
    clear_streaming_request();
    set_has_start_marker();
    _impl_.streaming_request_.start_marker_ = CreateMaybeMessage< ::nvidia::audio2face::PushAudioRequestStart >(GetArenaForAllocation());
  }
  return _impl_.streaming_request_.start_marker_;
}
inline ::nvidia::audio2face::PushAudioRequestStart* PushAudioStreamRequest::mutable_start_marker() {
  ::nvidia::audio2face::PushAudioRequestStart* _msg = _internal_mutable_start_marker();
  // @@protoc_insertion_point(field_mutable:nvidia.audio2face.PushAudioStreamRequest.start_marker)
  return _msg;
}

// bytes audio_data = 2;
inline bool PushAudioStreamRequest::_internal_has_audio_data() const {
  return streaming_request_case() == kAudioData;
}
inline bool PushAudioStreamRequest::has_audio_data() const {
  return _internal_has_audio_data();
}
inline void PushAudioStreamRequest::set_has_audio_data() {
  _impl_._oneof_case_[0] = kAudioData;
}
inline void PushAudioStreamRequest::clear_audio_data() {
  if (_internal_has_audio_data()) {
    _impl_.streaming_request_.audio_data_.Destroy();
    clear_has_streaming_request();
  }
}
inline const std::string& PushAudioStreamRequest::audio_data() const {
  // @@protoc_insertion_point(field_get:nvidia.audio2face.PushAudioStreamRequest.audio_data)
  return _internal_audio_data();
}
template <typename ArgT0, typename... ArgT>
inline void PushAudioStreamRequest::set_audio_data(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_audio_data()) {
    clear_streaming_request();
    set_has_audio_data();
    _impl_.streaming_request_.audio_data_.InitDefault();
  }
  _impl_.streaming_request_.audio_data_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nvidia.audio2face.PushAudioStreamRequest.audio_data)
}
inline std::string* PushAudioStreamRequest::mutable_audio_data() {
  std::string* _s = _internal_mutable_audio_data();
  // @@protoc_insertion_point(field_mutable:nvidia.audio2face.PushAudioStreamRequest.audio_data)
  return _s;
}
inline const std::string& PushAudioStreamRequest::_internal_audio_data() const {
  if (_internal_has_audio_data()) {
    return _impl_.streaming_request_.audio_data_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void PushAudioStreamRequest::_internal_set_audio_data(const std::string& value) {
  if (!_internal_has_audio_data()) {
    clear_streaming_request();
    set_has_audio_data();
    _impl_.streaming_request_.audio_data_.InitDefault();
  }
  _impl_.streaming_request_.audio_data_.Set(value, GetArenaForAllocation());
}
inline std::string* PushAudioStreamRequest::_internal_mutable_audio_data() {
  if (!_internal_has_audio_data()) {
    clear_streaming_request();
    set_has_audio_data();
    _impl_.streaming_request_.audio_data_.InitDefault();
  }
  return _impl_.streaming_request_.audio_data_.Mutable(      GetArenaForAllocation());
}
inline std::string* PushAudioStreamRequest::release_audio_data() {
  // @@protoc_insertion_point(field_release:nvidia.audio2face.PushAudioStreamRequest.audio_data)
  if (_internal_has_audio_data()) {
    clear_has_streaming_request();
    return _impl_.streaming_request_.audio_data_.Release();
  } else {
    return nullptr;
  }
}
inline void PushAudioStreamRequest::set_allocated_audio_data(std::string* audio_data) {
  if (has_streaming_request()) {
    clear_streaming_request();
  }
  if (audio_data != nullptr) {
    set_has_audio_data();
    _impl_.streaming_request_.audio_data_.InitAllocated(audio_data, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:nvidia.audio2face.PushAudioStreamRequest.audio_data)
}

inline bool PushAudioStreamRequest::has_streaming_request() const {
  return streaming_request_case() != STREAMING_REQUEST_NOT_SET;
}
inline void PushAudioStreamRequest::clear_has_streaming_request() {
  _impl_._oneof_case_[0] = STREAMING_REQUEST_NOT_SET;
}
inline PushAudioStreamRequest::StreamingRequestCase PushAudioStreamRequest::streaming_request_case() const {
  return PushAudioStreamRequest::StreamingRequestCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PushAudioRequestStart

// string instance_name = 1;
inline void PushAudioRequestStart::clear_instance_name() {
  _impl_.instance_name_.ClearToEmpty();
}
inline const std::string& PushAudioRequestStart::instance_name() const {
  // @@protoc_insertion_point(field_get:nvidia.audio2face.PushAudioRequestStart.instance_name)
  return _internal_instance_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PushAudioRequestStart::set_instance_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instance_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nvidia.audio2face.PushAudioRequestStart.instance_name)
}
inline std::string* PushAudioRequestStart::mutable_instance_name() {
  std::string* _s = _internal_mutable_instance_name();
  // @@protoc_insertion_point(field_mutable:nvidia.audio2face.PushAudioRequestStart.instance_name)
  return _s;
}
inline const std::string& PushAudioRequestStart::_internal_instance_name() const {
  return _impl_.instance_name_.Get();
}
inline void PushAudioRequestStart::_internal_set_instance_name(const std::string& value) {
  
  _impl_.instance_name_.Set(value, GetArenaForAllocation());
}
inline std::string* PushAudioRequestStart::_internal_mutable_instance_name() {
  
  return _impl_.instance_name_.Mutable(GetArenaForAllocation());
}
inline std::string* PushAudioRequestStart::release_instance_name() {
  // @@protoc_insertion_point(field_release:nvidia.audio2face.PushAudioRequestStart.instance_name)
  return _impl_.instance_name_.Release();
}
inline void PushAudioRequestStart::set_allocated_instance_name(std::string* instance_name) {
  if (instance_name != nullptr) {
    
  } else {
    
  }
  _impl_.instance_name_.SetAllocated(instance_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_name_.IsDefault()) {
    _impl_.instance_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.audio2face.PushAudioRequestStart.instance_name)
}

// int32 samplerate = 2;
inline void PushAudioRequestStart::clear_samplerate() {
  _impl_.samplerate_ = 0;
}
inline int32_t PushAudioRequestStart::_internal_samplerate() const {
  return _impl_.samplerate_;
}
inline int32_t PushAudioRequestStart::samplerate() const {
  // @@protoc_insertion_point(field_get:nvidia.audio2face.PushAudioRequestStart.samplerate)
  return _internal_samplerate();
}
inline void PushAudioRequestStart::_internal_set_samplerate(int32_t value) {
  
  _impl_.samplerate_ = value;
}
inline void PushAudioRequestStart::set_samplerate(int32_t value) {
  _internal_set_samplerate(value);
  // @@protoc_insertion_point(field_set:nvidia.audio2face.PushAudioRequestStart.samplerate)
}

// bool block_until_playback_is_finished = 3;
inline void PushAudioRequestStart::clear_block_until_playback_is_finished() {
  _impl_.block_until_playback_is_finished_ = false;
}
inline bool PushAudioRequestStart::_internal_block_until_playback_is_finished() const {
  return _impl_.block_until_playback_is_finished_;
}
inline bool PushAudioRequestStart::block_until_playback_is_finished() const {
  // @@protoc_insertion_point(field_get:nvidia.audio2face.PushAudioRequestStart.block_until_playback_is_finished)
  return _internal_block_until_playback_is_finished();
}
inline void PushAudioRequestStart::_internal_set_block_until_playback_is_finished(bool value) {
  
  _impl_.block_until_playback_is_finished_ = value;
}
inline void PushAudioRequestStart::set_block_until_playback_is_finished(bool value) {
  _internal_set_block_until_playback_is_finished(value);
  // @@protoc_insertion_point(field_set:nvidia.audio2face.PushAudioRequestStart.block_until_playback_is_finished)
}

// -------------------------------------------------------------------

// PushAudioStreamResponse

// bool success = 1;
inline void PushAudioStreamResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool PushAudioStreamResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool PushAudioStreamResponse::success() const {
  // @@protoc_insertion_point(field_get:nvidia.audio2face.PushAudioStreamResponse.success)
  return _internal_success();
}
inline void PushAudioStreamResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void PushAudioStreamResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:nvidia.audio2face.PushAudioStreamResponse.success)
}

// string message = 2;
inline void PushAudioStreamResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& PushAudioStreamResponse::message() const {
  // @@protoc_insertion_point(field_get:nvidia.audio2face.PushAudioStreamResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PushAudioStreamResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nvidia.audio2face.PushAudioStreamResponse.message)
}
inline std::string* PushAudioStreamResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:nvidia.audio2face.PushAudioStreamResponse.message)
  return _s;
}
inline const std::string& PushAudioStreamResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void PushAudioStreamResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* PushAudioStreamResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* PushAudioStreamResponse::release_message() {
  // @@protoc_insertion_point(field_release:nvidia.audio2face.PushAudioStreamResponse.message)
  return _impl_.message_.Release();
}
inline void PushAudioStreamResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.audio2face.PushAudioStreamResponse.message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace audio2face
}  // namespace nvidia

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_audio2face_2eproto
